<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>SHA-256 Explorer — qi.xyz</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500;600;700&family=Outfit:wght@300;400;500;600;700;800;900&display=swap');

  :root {
    --bg-deep: #07080a;
    --bg-primary: #0c0e12;
    --bg-card: #11141a;
    --bg-card-hover: #161a22;
    --bg-elevated: #1a1e28;
    --border: #1e2330;
    --border-bright: #2a3040;
    --text-primary: #e8eaf0;
    --text-secondary: #8a90a0;
    --text-dim: #555b6e;
    --accent: #c8ff2e;
    --accent-dim: rgba(200, 255, 46, 0.15);
    --accent-glow: rgba(200, 255, 46, 0.3);
    --cyan: #2ee8ff;
    --cyan-dim: rgba(46, 232, 255, 0.12);
    --orange: #ff8c2e;
    --orange-dim: rgba(255, 140, 46, 0.12);
    --magenta: #ff2ea0;
    --magenta-dim: rgba(255, 46, 160, 0.12);
    --purple: #a06eff;
    --purple-dim: rgba(160, 110, 255, 0.12);
    --red: #ff4d4d;
    --green: #2eff8c;
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  html { scroll-behavior: smooth; }

  body {
    font-family: 'Outfit', sans-serif;
    background: var(--bg-deep);
    color: var(--text-primary);
    line-height: 1.6;
    min-height: 100vh;
    overflow-x: hidden;
  }

  /* Background grid effect */
  body::before {
    content: '';
    position: fixed;
    inset: 0;
    background: 
      linear-gradient(rgba(200,255,46,0.02) 1px, transparent 1px),
      linear-gradient(90deg, rgba(200,255,46,0.02) 1px, transparent 1px);
    background-size: 60px 60px;
    pointer-events: none;
    z-index: 0;
  }

  .container {
    max-width: 1100px;
    margin: 0 auto;
    padding: 0 24px;
    position: relative;
    z-index: 1;
  }

  /* ===== HEADER ===== */
  header {
    padding: 40px 0 20px;
    text-align: center;
    position: relative;
  }

  .qi-badge {
    display: inline-flex;
    align-items: center;
    gap: 8px;
    background: var(--accent-dim);
    border: 1px solid rgba(200,255,46,0.2);
    border-radius: 100px;
    padding: 6px 18px 6px 12px;
    font-family: 'JetBrains Mono', monospace;
    font-size: 12px;
    font-weight: 500;
    color: var(--accent);
    letter-spacing: 0.08em;
    text-transform: uppercase;
    margin-bottom: 24px;
  }

  .qi-badge .dot {
    width: 6px; height: 6px;
    background: var(--accent);
    border-radius: 50%;
    animation: pulse-dot 2s ease-in-out infinite;
  }

  @keyframes pulse-dot {
    0%, 100% { opacity: 1; box-shadow: 0 0 4px var(--accent); }
    50% { opacity: 0.4; box-shadow: 0 0 8px var(--accent); }
  }

  h1 {
    font-size: clamp(2.5rem, 5vw, 4rem);
    font-weight: 900;
    letter-spacing: -0.03em;
    line-height: 1.1;
    margin-bottom: 16px;
  }

  h1 span.highlight {
    background: linear-gradient(135deg, var(--accent), var(--cyan));
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
  }

  .subtitle {
    font-size: 1.1rem;
    color: var(--text-secondary);
    max-width: 640px;
    margin: 0 auto 40px;
    font-weight: 300;
  }

  /* ===== INPUT SECTION ===== */
  .input-section {
    background: var(--bg-card);
    border: 1px solid var(--border);
    border-radius: 16px;
    padding: 32px;
    margin-bottom: 32px;
    position: relative;
    overflow: hidden;
  }

  .input-section::before {
    content: '';
    position: absolute;
    top: 0; left: 0; right: 0;
    height: 1px;
    background: linear-gradient(90deg, transparent, var(--accent), transparent);
    opacity: 0.5;
  }

  .input-label {
    font-family: 'JetBrains Mono', monospace;
    font-size: 11px;
    text-transform: uppercase;
    letter-spacing: 0.12em;
    color: var(--text-dim);
    margin-bottom: 12px;
  }

  .input-row {
    display: flex;
    gap: 12px;
    align-items: stretch;
  }

  .input-row input {
    flex: 1;
    background: var(--bg-deep);
    border: 1px solid var(--border);
    border-radius: 10px;
    padding: 16px 20px;
    font-family: 'JetBrains Mono', monospace;
    font-size: 16px;
    color: var(--text-primary);
    outline: none;
    transition: border-color 0.3s, box-shadow 0.3s;
  }

  .input-row input:focus {
    border-color: var(--accent);
    box-shadow: 0 0 0 3px var(--accent-dim);
  }

  .input-row input::placeholder { color: var(--text-dim); }

  .btn-hash {
    background: var(--accent);
    color: var(--bg-deep);
    border: none;
    border-radius: 10px;
    padding: 16px 32px;
    font-family: 'Outfit', sans-serif;
    font-size: 15px;
    font-weight: 700;
    cursor: pointer;
    letter-spacing: 0.02em;
    transition: all 0.2s;
    white-space: nowrap;
  }

  .btn-hash:hover {
    background: #d4ff55;
    box-shadow: 0 0 24px var(--accent-glow);
    transform: translateY(-1px);
  }

  .hash-output {
    margin-top: 20px;
    background: var(--bg-deep);
    border: 1px solid var(--border);
    border-radius: 10px;
    padding: 16px 20px;
    font-family: 'JetBrains Mono', monospace;
    font-size: 14px;
    color: var(--accent);
    word-break: break-all;
    min-height: 52px;
    display: flex;
    align-items: center;
    transition: all 0.3s;
    position: relative;
    overflow: hidden;
  }

  .hash-output.computing::after {
    content: '';
    position: absolute;
    bottom: 0; left: 0;
    height: 2px;
    background: var(--accent);
    animation: hash-progress 1.5s ease-out forwards;
  }

  @keyframes hash-progress {
    from { width: 0; }
    to { width: 100%; }
  }

  .hash-output .label {
    color: var(--text-dim);
    margin-right: 12px;
    font-size: 11px;
    text-transform: uppercase;
    letter-spacing: 0.1em;
    flex-shrink: 0;
  }

  /* ===== STEP NAVIGATION ===== */
  .steps-nav {
    display: flex;
    gap: 4px;
    margin-bottom: 32px;
    overflow-x: auto;
    padding-bottom: 4px;
    scrollbar-width: none;
  }
  .steps-nav::-webkit-scrollbar { display: none; }

  .step-tab {
    flex-shrink: 0;
    background: var(--bg-card);
    border: 1px solid var(--border);
    border-radius: 10px;
    padding: 12px 20px;
    font-family: 'JetBrains Mono', monospace;
    font-size: 12px;
    font-weight: 500;
    color: var(--text-secondary);
    cursor: pointer;
    transition: all 0.25s;
    display: flex;
    align-items: center;
    gap: 8px;
    white-space: nowrap;
  }

  .step-tab:hover { background: var(--bg-card-hover); border-color: var(--border-bright); }

  .step-tab.active {
    background: var(--accent-dim);
    border-color: rgba(200,255,46,0.3);
    color: var(--accent);
  }

  .step-num {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: 22px; height: 22px;
    border-radius: 6px;
    background: var(--bg-elevated);
    font-size: 11px;
    font-weight: 700;
  }

  .step-tab.active .step-num {
    background: var(--accent);
    color: var(--bg-deep);
  }

  /* ===== STEP PANELS ===== */
  .step-panel {
    display: none;
    animation: fadeSlide 0.4s ease-out;
  }

  .step-panel.active { display: block; }

  @keyframes fadeSlide {
    from { opacity: 0; transform: translateY(12px); }
    to { opacity: 1; transform: translateY(0); }
  }

  .panel-card {
    background: var(--bg-card);
    border: 1px solid var(--border);
    border-radius: 16px;
    padding: 32px;
    margin-bottom: 24px;
    position: relative;
    overflow: hidden;
  }

  .panel-card h2 {
    font-size: 1.6rem;
    font-weight: 800;
    margin-bottom: 8px;
    letter-spacing: -0.02em;
  }

  .panel-card .desc {
    color: var(--text-secondary);
    margin-bottom: 24px;
    font-size: 0.95rem;
    line-height: 1.7;
  }

  .panel-card .desc strong { color: var(--text-primary); font-weight: 600; }

  /* Colored tags for step categories */
  .tag {
    display: inline-flex;
    align-items: center;
    gap: 5px;
    padding: 4px 10px;
    border-radius: 6px;
    font-family: 'JetBrains Mono', monospace;
    font-size: 10px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.08em;
    margin-bottom: 16px;
  }

  .tag.preprocessing { background: var(--cyan-dim); color: var(--cyan); }
  .tag.constants { background: var(--orange-dim); color: var(--orange); }
  .tag.schedule { background: var(--purple-dim); color: var(--purple); }
  .tag.compression { background: var(--magenta-dim); color: var(--magenta); }
  .tag.output { background: var(--accent-dim); color: var(--accent); }

  /* Binary/Hex display boxes */
  .data-box {
    background: var(--bg-deep);
    border: 1px solid var(--border);
    border-radius: 10px;
    padding: 16px 20px;
    font-family: 'JetBrains Mono', monospace;
    font-size: 13px;
    line-height: 2;
    color: var(--text-secondary);
    overflow-x: auto;
    margin-bottom: 16px;
    position: relative;
  }

  .data-box .data-label {
    font-size: 10px;
    text-transform: uppercase;
    letter-spacing: 0.1em;
    color: var(--text-dim);
    margin-bottom: 8px;
    display: block;
  }

  .bit { display: inline; }
  .bit.one { color: var(--accent); }
  .bit.zero { color: var(--text-dim); }
  .bit.padding { color: var(--orange); }
  .bit.length { color: var(--cyan); }
  .bit.separator { color: var(--text-dim); opacity: 0.3; }
  .bit.message { color: var(--accent); }

  .hex { color: var(--cyan); font-weight: 500; }
  .hex-accent { color: var(--accent); }
  .hex-orange { color: var(--orange); }
  .hex-magenta { color: var(--magenta); }
  .hex-purple { color: var(--purple); }

  /* Visual diagrams */
  .diagram {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    margin: 16px 0;
  }

  .word-block {
    background: var(--bg-elevated);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 8px 12px;
    font-family: 'JetBrains Mono', monospace;
    font-size: 12px;
    color: var(--text-secondary);
    min-width: 100px;
    text-align: center;
    transition: all 0.25s;
  }

  .word-block:hover {
    border-color: var(--accent);
    background: var(--accent-dim);
    color: var(--accent);
  }

  .word-block .word-label {
    font-size: 9px;
    text-transform: uppercase;
    letter-spacing: 0.1em;
    color: var(--text-dim);
    margin-bottom: 4px;
  }

  /* Compression round visualizer */
  .round-viz {
    display: grid;
    grid-template-columns: 1fr;
    gap: 4px;
    margin: 16px 0;
  }

  .round-row {
    display: grid;
    grid-template-columns: 50px 1fr;
    gap: 12px;
    align-items: center;
    padding: 6px 12px;
    border-radius: 8px;
    font-family: 'JetBrains Mono', monospace;
    font-size: 12px;
    transition: background 0.2s;
  }

  .round-row:hover { background: var(--bg-elevated); }

  .round-num {
    color: var(--text-dim);
    font-size: 11px;
    text-align: right;
  }

  .round-values {
    display: flex;
    gap: 8px;
    overflow-x: auto;
    scrollbar-width: none;
  }
  .round-values::-webkit-scrollbar { display: none; }

  .reg-val {
    padding: 3px 8px;
    border-radius: 4px;
    font-size: 11px;
    white-space: nowrap;
    flex-shrink: 0;
  }

  .reg-a { background: rgba(200,255,46,0.1); color: var(--accent); }
  .reg-b { background: rgba(46,232,255,0.08); color: var(--cyan); }
  .reg-c { background: rgba(160,110,255,0.08); color: var(--purple); }
  .reg-d { background: rgba(255,140,46,0.08); color: var(--orange); }
  .reg-e { background: rgba(255,46,160,0.08); color: var(--magenta); }
  .reg-f { background: rgba(46,255,140,0.08); color: var(--green); }
  .reg-g { background: rgba(200,255,46,0.06); color: rgba(200,255,46,0.6); }
  .reg-h { background: rgba(46,232,255,0.06); color: rgba(46,232,255,0.6); }

  /* Operations visual */
  .op-box {
    display: inline-flex;
    align-items: center;
    gap: 12px;
    background: var(--bg-elevated);
    border: 1px solid var(--border);
    border-radius: 10px;
    padding: 12px 20px;
    margin: 6px 4px;
    font-family: 'JetBrains Mono', monospace;
    font-size: 13px;
  }

  .op-name {
    color: var(--accent);
    font-weight: 700;
    font-size: 14px;
  }

  .op-formula { color: var(--text-secondary); font-size: 12px; }

  /* Round slider */
  .round-control {
    display: flex;
    align-items: center;
    gap: 16px;
    margin: 20px 0;
    padding: 16px 20px;
    background: var(--bg-deep);
    border: 1px solid var(--border);
    border-radius: 10px;
  }

  .round-control label {
    font-family: 'JetBrains Mono', monospace;
    font-size: 12px;
    color: var(--text-dim);
    text-transform: uppercase;
    letter-spacing: 0.08em;
    white-space: nowrap;
  }

  .round-control input[type="range"] {
    flex: 1;
    -webkit-appearance: none;
    background: var(--bg-elevated);
    height: 6px;
    border-radius: 3px;
    outline: none;
  }

  .round-control input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    width: 18px; height: 18px;
    border-radius: 50%;
    background: var(--accent);
    cursor: pointer;
    box-shadow: 0 0 10px var(--accent-glow);
  }

  .round-display {
    font-family: 'JetBrains Mono', monospace;
    font-size: 20px;
    font-weight: 700;
    color: var(--accent);
    min-width: 40px;
    text-align: center;
  }

  /* Avalanche demo */
  .avalanche-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 16px;
    margin: 16px 0;
  }

  @media (max-width: 700px) {
    .avalanche-grid { grid-template-columns: 1fr; }
  }

  .avalanche-col h3 {
    font-family: 'JetBrains Mono', monospace;
    font-size: 12px;
    text-transform: uppercase;
    letter-spacing: 0.1em;
    color: var(--text-dim);
    margin-bottom: 8px;
  }

  .binary-diff {
    font-family: 'JetBrains Mono', monospace;
    font-size: 11px;
    line-height: 1.8;
    word-break: break-all;
  }

  .binary-diff .same { color: var(--text-dim); }
  .binary-diff .diff { color: var(--red); background: rgba(255,77,77,0.1); border-radius: 2px; padding: 0 1px; }

  .stat-row {
    display: flex;
    gap: 16px;
    margin-top: 16px;
  }

  .stat-box {
    flex: 1;
    background: var(--bg-deep);
    border: 1px solid var(--border);
    border-radius: 10px;
    padding: 16px;
    text-align: center;
  }

  .stat-box .stat-val {
    font-family: 'JetBrains Mono', monospace;
    font-size: 28px;
    font-weight: 700;
    color: var(--accent);
  }

  .stat-box .stat-label {
    font-size: 11px;
    color: var(--text-dim);
    text-transform: uppercase;
    letter-spacing: 0.08em;
    margin-top: 4px;
  }

  /* Flowchart */
  .flow {
    display: flex;
    align-items: center;
    gap: 0;
    flex-wrap: wrap;
    justify-content: center;
    margin: 20px 0;
  }

  .flow-node {
    background: var(--bg-elevated);
    border: 1px solid var(--border);
    border-radius: 10px;
    padding: 12px 20px;
    font-family: 'JetBrains Mono', monospace;
    font-size: 12px;
    text-align: center;
    color: var(--text-secondary);
    min-width: 110px;
  }

  .flow-node.active-node {
    border-color: var(--accent);
    color: var(--accent);
    background: var(--accent-dim);
  }

  .flow-arrow {
    color: var(--text-dim);
    font-size: 18px;
    padding: 0 6px;
  }

  /* Footer */
  footer {
    text-align: center;
    padding: 48px 0;
    color: var(--text-dim);
    font-size: 13px;
    border-top: 1px solid var(--border);
    margin-top: 48px;
  }

  footer a { color: var(--accent); text-decoration: none; }

  /* Constants table */
  .constants-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(90px, 1fr));
    gap: 4px;
    margin: 12px 0;
  }

  .const-cell {
    background: var(--bg-deep);
    border: 1px solid var(--border);
    border-radius: 6px;
    padding: 6px 8px;
    font-family: 'JetBrains Mono', monospace;
    font-size: 10px;
    text-align: center;
    color: var(--text-secondary);
    transition: all 0.2s;
  }

  .const-cell:hover {
    border-color: var(--accent);
    color: var(--accent);
    background: var(--accent-dim);
  }

  .const-cell .const-idx {
    font-size: 8px;
    color: var(--text-dim);
    display: block;
    margin-bottom: 2px;
  }

  /* Info callouts */
  .callout {
    background: var(--accent-dim);
    border-left: 3px solid var(--accent);
    border-radius: 0 10px 10px 0;
    padding: 16px 20px;
    margin: 16px 0;
    font-size: 0.9rem;
    color: var(--text-secondary);
  }

  .callout strong { color: var(--accent); }

  .callout.cyan {
    background: var(--cyan-dim);
    border-left-color: var(--cyan);
  }
  .callout.cyan strong { color: var(--cyan); }

  .callout.orange {
    background: var(--orange-dim);
    border-left-color: var(--orange);
  }
  .callout.orange strong { color: var(--orange); }

  /* Responsive */
  @media (max-width: 600px) {
    .input-row { flex-direction: column; }
    .panel-card { padding: 24px 16px; }
    .stat-row { flex-direction: column; }
  }

  /* Animate in on scroll */
  .reveal {
    opacity: 0;
    transform: translateY(20px);
    transition: opacity 0.5s, transform 0.5s;
  }
  .reveal.visible {
    opacity: 1;
    transform: translateY(0);
  }
</style>
</head>
<body>

<div class="container">
  <header>
    <div class="qi-badge"><span class="dot"></span> qi.xyz — energy money</div>
    <h1>Inside <span class="highlight">SHA-256</span></h1>
    <p class="subtitle">The cryptographic hash function that secures proof-of-work. Type any message and watch SHA-256 transform it, step by step.</p>
  </header>

  <!-- INPUT -->
  <div class="input-section">
    <div class="input-label">↳ Enter a message to hash</div>
    <div class="input-row">
      <input type="text" id="msgInput" placeholder="hello" value="hello" spellcheck="false" autocomplete="off">
      <button class="btn-hash" onclick="runHash()">Hash It</button>
    </div>
    <div class="hash-output" id="hashOutput">
      <span class="label">SHA-256</span>
      <span id="hashValue">Click "Hash It" to begin...</span>
    </div>
  </div>

  <!-- STEP TABS -->
  <div class="steps-nav" id="stepsNav">
    <div class="step-tab active" onclick="showStep(0)"><span class="step-num">0</span> Overview</div>
    <div class="step-tab" onclick="showStep(1)"><span class="step-num">1</span> Preprocessing</div>
    <div class="step-tab" onclick="showStep(2)"><span class="step-num">2</span> Constants</div>
    <div class="step-tab" onclick="showStep(3)"><span class="step-num">3</span> Message Schedule</div>
    <div class="step-tab" onclick="showStep(4)"><span class="step-num">4</span> Compression</div>
    <div class="step-tab" onclick="showStep(5)"><span class="step-num">5</span> Final Hash</div>
    <div class="step-tab" onclick="showStep(6)"><span class="step-num">6</span> Avalanche</div>
  </div>

  <!-- STEP 0: OVERVIEW -->
  <div class="step-panel active" id="step0">
    <div class="panel-card">
      <span class="tag output">Overview</span>
      <h2>How SHA-256 Works</h2>
      <p class="desc">
        SHA-256 (Secure Hash Algorithm 256-bit) takes <strong>any input</strong> and produces a fixed <strong>256-bit (32-byte) hash</strong>. It's a one-way function — you can't reverse it. Every Bitcoin and Quai block header is hashed with SHA-256 to produce proof-of-work.
      </p>

      <div class="flow">
        <div class="flow-node active-node">Input<br><small>any length</small></div>
        <span class="flow-arrow">→</span>
        <div class="flow-node">Pad to<br><small>512-bit blocks</small></div>
        <span class="flow-arrow">→</span>
        <div class="flow-node">Expand to<br><small>64 words</small></div>
        <span class="flow-arrow">→</span>
        <div class="flow-node">Compress<br><small>64 rounds</small></div>
        <span class="flow-arrow">→</span>
        <div class="flow-node active-node">256-bit<br><small>hash output</small></div>
      </div>

      <div class="callout">
        <strong>Why does this matter for mining?</strong> In proof-of-work, miners repeatedly hash block headers with different nonces, searching for a hash below the target difficulty. The properties of SHA-256 — determinism, uniformity, pre-image resistance — make this an irreducible computational cost, which is what ties energy to security.
      </div>
    </div>
  </div>

  <!-- STEP 1: PREPROCESSING -->
  <div class="step-panel" id="step1">
    <div class="panel-card">
      <span class="tag preprocessing">Step 1</span>
      <h2>Preprocessing &amp; Padding</h2>
      <p class="desc">
        The input message is converted to binary, then padded so its total length is a multiple of <strong>512 bits</strong>. Padding adds a <strong>1</strong> bit, then zeros, then the original message length as a 64-bit integer.
      </p>

      <div class="data-box">
        <span class="data-label">Original message → ASCII → Binary</span>
        <div id="msgBinary"></div>
      </div>

      <div class="data-box">
        <span class="data-label">After padding (512-bit block)</span>
        <div id="msgPadded"></div>
      </div>

      <div class="callout cyan">
        <strong>Padding rule:</strong> message + <span style="color:var(--orange)">1</span> + <span style="color:var(--text-dim)">zeros</span> + <span style="color:var(--cyan)">64-bit length</span> = multiple of 512 bits. This ensures every message, regardless of size, maps cleanly into 512-bit processing blocks.
      </div>
    </div>
  </div>

  <!-- STEP 2: CONSTANTS -->
  <div class="step-panel" id="step2">
    <div class="panel-card">
      <span class="tag constants">Step 2</span>
      <h2>Initial Hash Values &amp; Round Constants</h2>
      <p class="desc">
        SHA-256 uses <strong>8 initial hash values (H₀–H₇)</strong> derived from the square roots of the first 8 primes, and <strong>64 round constants (K₀–K₆₃)</strong> from the cube roots of the first 64 primes. These are nothing-up-my-sleeve numbers — you can verify them yourself.
      </p>

      <div class="data-box">
        <span class="data-label">Initial Hash Values (√ of primes 2,3,5,7,11,13,17,19)</span>
        <div id="initialHashes"></div>
      </div>

      <div class="data-box">
        <span class="data-label">64 Round Constants K (∛ of first 64 primes)</span>
        <div class="constants-grid" id="roundConstants"></div>
      </div>

      <div class="callout orange">
        <strong>Nothing-up-my-sleeve:</strong> These constants are mathematically derived from primes, meaning the NSA (who designed SHA-2) couldn't have hidden a backdoor in the constant selection. Anyone can recompute them.
      </div>
    </div>
  </div>

  <!-- STEP 3: MESSAGE SCHEDULE -->
  <div class="step-panel" id="step3">
    <div class="panel-card">
      <span class="tag schedule">Step 3</span>
      <h2>Message Schedule (W₀ – W₆₃)</h2>
      <p class="desc">
        The 512-bit block is split into <strong>16 words of 32 bits</strong> each (W₀–W₁₅). Then 48 more words are generated using bitwise operations, expanding 16 words into <strong>64 words</strong> that feed the compression function.
      </p>

      <div class="callout">
        <strong>Expansion formula:</strong> For i = 16..63:<br>
        W[i] = σ₁(W[i-2]) + W[i-7] + σ₀(W[i-15]) + W[i-16]<br><br>
        where σ₀(x) = ROTR⁷(x) ⊕ ROTR¹⁸(x) ⊕ SHR³(x)<br>
        and σ₁(x) = ROTR¹⁷(x) ⊕ ROTR¹⁹(x) ⊕ SHR¹⁰(x)
      </div>

      <div class="diagram" id="messageSchedule"></div>
    </div>
  </div>

  <!-- STEP 4: COMPRESSION -->
  <div class="step-panel" id="step4">
    <div class="panel-card">
      <span class="tag compression">Step 4</span>
      <h2>Compression Function (64 Rounds)</h2>
      <p class="desc">
        This is the heart of SHA-256. Eight working variables (a–h) are initialized from the current hash values, then transformed through <strong>64 rounds</strong> of mixing using bitwise operations.
      </p>

      <div style="display:flex;flex-wrap:wrap;gap:8px;margin:16px 0;">
        <div class="op-box">
          <span class="op-name">Ch</span>
          <span class="op-formula">(e AND f) XOR (NOT e AND g)</span>
        </div>
        <div class="op-box">
          <span class="op-name">Maj</span>
          <span class="op-formula">(a AND b) XOR (a AND c) XOR (b AND c)</span>
        </div>
        <div class="op-box">
          <span class="op-name">Σ₀</span>
          <span class="op-formula">ROTR²(a) ⊕ ROTR¹³(a) ⊕ ROTR²²(a)</span>
        </div>
        <div class="op-box">
          <span class="op-name">Σ₁</span>
          <span class="op-formula">ROTR⁶(e) ⊕ ROTR¹¹(e) ⊕ ROTR²⁵(e)</span>
        </div>
      </div>

      <div class="callout">
        <strong>Each round:</strong><br>
        T₁ = h + Σ₁(e) + Ch(e,f,g) + K[i] + W[i]<br>
        T₂ = Σ₀(a) + Maj(a,b,c)<br>
        h=g, g=f, f=e, e=d+T₁, d=c, c=b, b=a, a=T₁+T₂
      </div>

      <div class="round-control">
        <label>Round</label>
        <input type="range" id="roundSlider" min="0" max="64" value="0" oninput="updateRound(this.value)">
        <span class="round-display" id="roundDisplay">0</span>
      </div>

      <div class="data-box" style="max-height: 300px; overflow-y: auto;">
        <span class="data-label">Working Variables (a–h) at selected round</span>
        <div id="roundState"></div>
      </div>
    </div>
  </div>

  <!-- STEP 5: FINAL -->
  <div class="step-panel" id="step5">
    <div class="panel-card">
      <span class="tag output">Step 5</span>
      <h2>Final Hash Output</h2>
      <p class="desc">
        After all 64 rounds, the working variables are <strong>added back</strong> to the initial hash values. The resulting 8 × 32-bit words are concatenated to produce the final <strong>256-bit hash</strong>.
      </p>

      <div class="data-box">
        <span class="data-label">H₀–H₇ (initial) + a–h (after compression) = Final Hash Values</span>
        <div id="finalAddition"></div>
      </div>

      <div class="data-box">
        <span class="data-label">Concatenated 256-bit Hash</span>
        <div id="finalHash" style="font-size:16px;color:var(--accent);font-weight:600;"></div>
      </div>

      <div class="callout">
        <strong>For multi-block messages:</strong> The output hash values become the initial hash values for processing the next 512-bit block. This chaining ensures every bit of the message affects the final hash.
      </div>
    </div>
  </div>

  <!-- STEP 6: AVALANCHE -->
  <div class="step-panel" id="step6">
    <div class="panel-card">
      <span class="tag compression">Demonstration</span>
      <h2>The Avalanche Effect</h2>
      <p class="desc">
        Change a <strong>single bit</strong> in the input and roughly <strong>50% of output bits flip</strong>. This is what makes SHA-256 secure — there's no way to predict how the hash will change from small input changes. This property is critical for mining: you can't shortcut the search for a valid nonce.
      </p>

      <div class="avalanche-grid">
        <div class="avalanche-col">
          <h3>Original Input</h3>
          <div class="data-box" id="avOrigInput" style="font-size:15px;color:var(--accent);"></div>
          <div class="data-box" id="avOrigHash"></div>
        </div>
        <div class="avalanche-col">
          <h3>Modified Input (1 char change)</h3>
          <div class="data-box" id="avModInput" style="font-size:15px;color:var(--orange);"></div>
          <div class="data-box" id="avModHash"></div>
        </div>
      </div>

      <div class="data-box">
        <span class="data-label">Bit-level diff (red = flipped bits)</span>
        <div class="binary-diff" id="avDiff"></div>
      </div>

      <div class="stat-row" id="avStats"></div>
    </div>
  </div>

  <footer>
    Built for <a href="https://qi.xyz">qi.xyz</a> — Understanding the energy cost of trust.
  </footer>
</div>

<script>
// ============================================================
// SHA-256 IMPLEMENTATION (pure JS, step-by-step with logging)
// ============================================================

const K = [
  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
];

const H_INIT = [
  0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
  0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
];

function rotr(n, x) { return ((x >>> n) | (x << (32 - n))) >>> 0; }
function shr(n, x) { return (x >>> n) >>> 0; }
function ch(e, f, g) { return ((e & f) ^ (~e & g)) >>> 0; }
function maj(a, b, c) { return ((a & b) ^ (a & c) ^ (b & c)) >>> 0; }
function sigma0(a) { return (rotr(2, a) ^ rotr(13, a) ^ rotr(22, a)) >>> 0; }
function sigma1(e) { return (rotr(6, e) ^ rotr(11, e) ^ rotr(25, e)) >>> 0; }
function lsigma0(x) { return (rotr(7, x) ^ rotr(18, x) ^ shr(3, x)) >>> 0; }
function lsigma1(x) { return (rotr(17, x) ^ rotr(19, x) ^ shr(10, x)) >>> 0; }
function add32(...args) { return args.reduce((a, b) => (a + b) >>> 0, 0); }

function toHex(n) { return ('00000000' + (n >>> 0).toString(16)).slice(-8); }
function toBin(n) { return ('00000000000000000000000000000000' + (n >>> 0).toString(2)).slice(-32); }

// Full SHA-256 with step-by-step logging
function sha256Steps(message) {
  // 1. Preprocess
  const msgBytes = new TextEncoder().encode(message);
  const bitLen = msgBytes.length * 8;

  // Padding
  let totalBytes = msgBytes.length + 1; // +1 for 0x80
  while ((totalBytes * 8) % 512 !== 448) totalBytes++;
  totalBytes += 8; // 64-bit length

  const padded = new Uint8Array(totalBytes);
  padded.set(msgBytes);
  padded[msgBytes.length] = 0x80;

  // Append length as big-endian 64-bit
  const lenView = new DataView(padded.buffer);
  // For messages < 2^32 bits, high 32 bits are 0
  lenView.setUint32(totalBytes - 4, bitLen, false);

  const steps = {
    msgBytes: Array.from(msgBytes),
    padded: padded,
    blocks: [],
    W: [],
    rounds: [],
    H_init: [...H_INIT],
    H_final: []
  };

  // Process each 512-bit (64-byte) block
  const numBlocks = totalBytes / 64;
  let H = [...H_INIT];

  for (let block = 0; block < numBlocks; block++) {
    const blockData = padded.slice(block * 64, (block + 1) * 64);
    steps.blocks.push(blockData);

    // 2. Message Schedule
    const W = new Array(64);
    const view = new DataView(blockData.buffer, blockData.byteOffset, 64);
    for (let t = 0; t < 16; t++) {
      W[t] = view.getUint32(t * 4, false);
    }
    for (let t = 16; t < 64; t++) {
      W[t] = add32(lsigma1(W[t-2]), W[t-7], lsigma0(W[t-15]), W[t-16]);
    }
    steps.W = W.map(w => w >>> 0);

    // 3. Compression
    let [a, b, c, d, e, f, g, h] = H;
    const rounds = [[a, b, c, d, e, f, g, h]]; // round 0 = initial

    for (let t = 0; t < 64; t++) {
      const T1 = add32(h, sigma1(e), ch(e, f, g), K[t], W[t]);
      const T2 = add32(sigma0(a), maj(a, b, c));
      h = g; g = f; f = e; e = add32(d, T1); d = c; c = b; b = a; a = add32(T1, T2);
      rounds.push([a, b, c, d, e, f, g, h]);
    }
    steps.rounds = rounds;

    // 4. Add to hash
    H = H.map((hv, i) => add32(hv, rounds[64][i]));
  }

  steps.H_final = H;
  steps.hash = H.map(toHex).join('');

  return steps;
}

// Quick hash for avalanche
function sha256Quick(msg) {
  return sha256Steps(msg).hash;
}

// ============================================================
// UI STATE
// ============================================================

let currentSteps = null;

function runHash() {
  const msg = document.getElementById('msgInput').value || '';
  const output = document.getElementById('hashOutput');
  output.classList.add('computing');
  setTimeout(() => output.classList.remove('computing'), 1600);

  currentSteps = sha256Steps(msg);
  document.getElementById('hashValue').textContent = currentSteps.hash;

  renderStep1();
  renderStep2();
  renderStep3();
  renderStep4();
  renderStep5();
  renderStep6();
}

function showStep(n) {
  document.querySelectorAll('.step-tab').forEach((t, i) => t.classList.toggle('active', i === n));
  document.querySelectorAll('.step-panel').forEach((p, i) => p.classList.toggle('active', i === n));
}

// ============================================================
// RENDERERS
// ============================================================

function renderStep1() {
  if (!currentSteps) return;
  const msg = document.getElementById('msgInput').value || '';

  // ASCII to binary
  let binHtml = '';
  for (let i = 0; i < currentSteps.msgBytes.length; i++) {
    const byte = currentSteps.msgBytes[i];
    const bits = ('00000000' + byte.toString(2)).slice(-8);
    const char = msg[i] || '';
    binHtml += `<span class="bit message" title="${char} = ${byte}">${bits}</span>`;
    if (i < currentSteps.msgBytes.length - 1) binHtml += `<span class="bit separator"> </span>`;
  }
  document.getElementById('msgBinary').innerHTML = binHtml;

  // Padded block
  const padded = currentSteps.padded;
  const msgLen = currentSteps.msgBytes.length;
  let padHtml = '';
  for (let i = 0; i < padded.length; i++) {
    const bits = ('00000000' + padded[i].toString(2)).slice(-8);
    let cls = 'zero';
    if (i < msgLen) cls = 'message';
    else if (i === msgLen) cls = 'padding';
    else if (i >= padded.length - 8) cls = 'length';

    for (let b = 0; b < 8; b++) {
      padHtml += `<span class="bit ${cls}">${bits[b]}</span>`;
    }
    if ((i + 1) % 4 === 0) padHtml += `<span class="bit separator"> </span>`;
    if ((i + 1) % 32 === 0 && i < padded.length - 1) padHtml += '<br>';
  }
  document.getElementById('msgPadded').innerHTML = padHtml;
}

function renderStep2() {
  // Initial hashes
  const names = ['H₀','H₁','H₂','H₃','H₄','H₅','H₆','H₇'];
  const primes = [2,3,5,7,11,13,17,19];
  let html = '';
  for (let i = 0; i < 8; i++) {
    html += `<span class="hex">${toHex(H_INIT[i])}</span>`;
    html += `<span style="color:var(--text-dim);font-size:11px;"> ← ${names[i]} (√${primes[i]})</span>`;
    if (i < 7) html += '<br>';
  }
  document.getElementById('initialHashes').innerHTML = html;

  // Round constants
  let kHtml = '';
  for (let i = 0; i < 64; i++) {
    kHtml += `<div class="const-cell"><span class="const-idx">K${i}</span>${toHex(K[i])}</div>`;
  }
  document.getElementById('roundConstants').innerHTML = kHtml;
}

function renderStep3() {
  if (!currentSteps) return;
  const W = currentSteps.W;
  let html = '';
  for (let i = 0; i < 64; i++) {
    const isOriginal = i < 16;
    html += `<div class="word-block" style="${isOriginal ? 'border-color:var(--purple);' : ''}">
      <div class="word-label" style="${isOriginal ? 'color:var(--purple);' : ''}">W${i}${isOriginal ? ' (orig)' : ''}</div>
      ${toHex(W[i])}
    </div>`;
  }
  document.getElementById('messageSchedule').innerHTML = html;
}

function renderStep4() {
  if (!currentSteps) return;
  updateRound(document.getElementById('roundSlider').value);
}

function updateRound(val) {
  if (!currentSteps) return;
  const round = parseInt(val);
  document.getElementById('roundDisplay').textContent = round;

  const state = currentSteps.rounds[round];
  const labels = ['a','b','c','d','e','f','g','h'];
  const classes = ['reg-a','reg-b','reg-c','reg-d','reg-e','reg-f','reg-g','reg-h'];

  let html = '<div style="display:flex;flex-wrap:wrap;gap:8px;">';
  for (let i = 0; i < 8; i++) {
    html += `<div style="flex:1;min-width:120px;">
      <div style="font-size:10px;text-transform:uppercase;letter-spacing:0.1em;color:var(--text-dim);margin-bottom:4px;">${labels[i]}</div>
      <span class="reg-val ${classes[i]}">${toHex(state[i])}</span>
    </div>`;
  }
  html += '</div>';

  if (round > 0 && round <= 64) {
    html += `<div style="margin-top:16px;font-size:12px;color:var(--text-dim);">
      <span style="color:var(--text-secondary);">K[${round-1}]</span> = <span class="hex">${toHex(K[round-1])}</span> &nbsp;
      <span style="color:var(--text-secondary);">W[${round-1}]</span> = <span class="hex-purple">${toHex(currentSteps.W[round-1])}</span>
    </div>`;
  }

  document.getElementById('roundState').innerHTML = html;
}

function renderStep5() {
  if (!currentSteps) return;
  const labels = ['H₀','H₁','H₂','H₃','H₄','H₅','H₆','H₇'];
  const regLabels = ['a','b','c','d','e','f','g','h'];
  const finalRound = currentSteps.rounds[64];

  let html = '';
  for (let i = 0; i < 8; i++) {
    html += `<span class="hex">${toHex(H_INIT[i])}</span>`;
    html += ` <span style="color:var(--text-dim);">+</span> `;
    html += `<span class="hex-magenta">${toHex(finalRound[i])}</span>`;
    html += ` <span style="color:var(--text-dim);">=</span> `;
    html += `<span class="hex-accent">${toHex(currentSteps.H_final[i])}</span>`;
    html += `<span style="color:var(--text-dim);font-size:11px;"> (${labels[i]} + ${regLabels[i]})</span>`;
    if (i < 7) html += '<br>';
  }
  document.getElementById('finalAddition').innerHTML = html;
  document.getElementById('finalHash').textContent = currentSteps.hash;
}

function renderStep6() {
  const msg = document.getElementById('msgInput').value || '';
  const hash1 = sha256Quick(msg);

  // Create a modified version (change last char)
  let modMsg;
  if (msg.length === 0) {
    modMsg = 'a';
  } else {
    const lastChar = msg.charCodeAt(msg.length - 1);
    modMsg = msg.slice(0, -1) + String.fromCharCode(lastChar ^ 1);
  }
  const hash2 = sha256Quick(modMsg);

  document.getElementById('avOrigInput').textContent = `"${msg}"`;
  document.getElementById('avModInput').textContent = `"${modMsg}"`;
  document.getElementById('avOrigHash').innerHTML = `<span class="hex">${hash1}</span>`;
  document.getElementById('avModHash').innerHTML = `<span class="hex-orange">${hash2}</span>`;

  // Binary diff
  const bin1 = hexToBin(hash1);
  const bin2 = hexToBin(hash2);
  let diffCount = 0;
  let diffHtml = '';
  for (let i = 0; i < 256; i++) {
    if (bin1[i] !== bin2[i]) {
      diffCount++;
      diffHtml += `<span class="diff">${bin2[i]}</span>`;
    } else {
      diffHtml += `<span class="same">${bin2[i]}</span>`;
    }
    if ((i + 1) % 32 === 0 && i < 255) diffHtml += '<br>';
    else if ((i + 1) % 8 === 0) diffHtml += ' ';
  }
  document.getElementById('avDiff').innerHTML = diffHtml;

  const pct = ((diffCount / 256) * 100).toFixed(1);
  document.getElementById('avStats').innerHTML = `
    <div class="stat-box">
      <div class="stat-val">${diffCount}</div>
      <div class="stat-label">Bits Flipped</div>
    </div>
    <div class="stat-box">
      <div class="stat-val">${pct}%</div>
      <div class="stat-label">Of 256 Bits</div>
    </div>
    <div class="stat-box">
      <div class="stat-val">~50%</div>
      <div class="stat-label">Expected</div>
    </div>
  `;
}

function hexToBin(hex) {
  return hex.split('').map(h => ('0000' + parseInt(h, 16).toString(2)).slice(-4)).join('');
}

// ============================================================
// INIT
// ============================================================

document.getElementById('msgInput').addEventListener('keydown', function(e) {
  if (e.key === 'Enter') runHash();
});

// Run on load
runHash();
</script>

</body>
</html>

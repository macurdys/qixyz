

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>AI Moral Compass — Possibility Navigator v0.3</title>
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Crect width='32' height='32' rx='6' fill='%2306080d'/%3E%3Ctext x='16' y='23' text-anchor='middle' font-family='monospace' font-size='18' font-weight='bold' fill='%2300f0ff'%3EQi%3C/text%3E%3C/svg%3E">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;600;700;800;900&family=Rajdhani:wght@300;400;500;600;700&family=Share+Tech+Mono&display=swap" rel="stylesheet">
    <style>
        :root {
            --qi-cyan: #00f0ff;
            --qi-cyan-dim: rgba(0, 240, 255, 0.12);
            --qi-cyan-glow: rgba(0, 240, 255, 0.4);
            --qi-amber: #ffb800;
            --qi-amber-dim: rgba(255, 184, 0, 0.12);
            --qi-red: #ff3366;
            --qi-green: #39FF14;
            --qi-green-dim: rgba(57, 255, 20, 0.12);
            --qi-purple: #bf5af2;
            --qi-purple-dim: rgba(191, 90, 242, 0.12);
            /* Per-filter lens colors */
            --filter-tech: #00f0ff;
            --filter-tech-dim: rgba(0, 240, 255, 0.10);
            --filter-ethic: #bf5af2;
            --filter-ethic-dim: rgba(191, 90, 242, 0.10);
            --filter-econ: #39FF14;
            --filter-econ-dim: rgba(57, 255, 20, 0.10);
            --filter-social: #ffb800;
            --filter-social-dim: rgba(255, 184, 0, 0.10);
            --bg-deep: #06080d;
            --bg-panel: #0c1018;
            --bg-card: #111822;
            --border-dim: rgba(0, 240, 255, 0.1);
            --border-bright: rgba(0, 240, 255, 0.3);
            --text-primary: #e0e6ed;
            --text-secondary: #7a8a9e;
            --text-dim: #3d4d60;
            --font-display: 'Orbitron', monospace;
            --font-body: 'Rajdhani', sans-serif;
            --font-mono: 'Share Tech Mono', monospace;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        html, body {
            height: 100%;
            overflow: hidden;
            font-family: var(--font-body);
            background: var(--bg-deep);
            color: var(--text-primary);
            font-size: 18px;
            line-height: 1.6;
        }

        /* Scanlines */
        body::after {
            content: '';
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(0,240,255,0.006) 2px, rgba(0,240,255,0.006) 4px);
            pointer-events: none;
            z-index: 9999;
        }

        .grid-bg {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background-image:
                linear-gradient(var(--border-dim) 1px, transparent 1px),
                linear-gradient(90deg, var(--border-dim) 1px, transparent 1px);
            background-size: 60px 60px;
            opacity: 0.25;
            pointer-events: none;
            z-index: 0;
        }

        /* ═══════════════ BRIEFING SCREEN ═══════════════ */
        .briefing-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: var(--bg-deep);
            z-index: 10000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            padding: 3vh 20px 2vh;
            transition: opacity 0.6s, visibility 0.6s;
            overflow-y: auto;
        }
        .briefing-overlay.hidden {
            opacity: 0; visibility: hidden; pointer-events: none;
        }

        .briefing-header {
            text-align: center;
            margin-bottom: 2vh;
            flex-shrink: 0;
        }
        .briefing-title {
            font-family: var(--font-display);
            font-size: clamp(26px, 5vw, 48px);
            font-weight: 700;
            letter-spacing: 8px;
            color: var(--qi-cyan);
            text-shadow: 0 0 60px var(--qi-cyan-glow), 0 0 120px rgba(0,240,255,0.15);
            white-space: nowrap;
        }
        .briefing-subtitle {
            font-family: var(--font-mono);
            font-size: 14px;
            color: var(--text-secondary);
            letter-spacing: 5px;
            margin-top: 10px;
        }

        /* Compass hero */
        .compass-hero {
            position: relative;
            width: min(65vmin, 440px);
            flex-shrink: 0;
            margin-bottom: 3vh;
        }
        .compass-svg { width: 100%; height: auto; }
        .compass-svg .dir-highlight { opacity: 0; transition: opacity 0.15s; }
        .compass-svg .dir-highlight.active { opacity: 1; }
        .compass-svg .arrow-north,
        .compass-svg .arrow-east,
        .compass-svg .arrow-south,
        .compass-svg .arrow-west { transition: transform 0.15s, filter 0.15s; }
        .compass-svg .arrow-north.pulse { transform: translateY(-6px); filter: drop-shadow(0 0 12px #00f0ff); }
        .compass-svg .arrow-east.pulse  { transform: translateX(6px);  filter: drop-shadow(0 0 12px #ffb800); }
        .compass-svg .arrow-south.pulse { transform: translateY(6px);  filter: drop-shadow(0 0 12px #39FF14); }
        .compass-svg .arrow-west.pulse  { transform: translateX(-6px); filter: drop-shadow(0 0 12px #bf5af2); }

        /* Tutorial */
        .tutorial-prompt { text-align: center; margin-bottom: 2vh; flex-shrink: 0; }
        .tutorial-text {
            font-family: var(--font-mono);
            font-size: 15px;
            color: var(--text-secondary);
            letter-spacing: 2px;
            margin-bottom: 14px;
        }
        .tutorial-keys { display: flex; justify-content: center; gap: 8px; margin-bottom: 10px; }
        .key-hint {
            width: 50px; height: 50px;
            background: var(--bg-card);
            border: 1px solid var(--border-dim);
            border-radius: 6px;
            display: flex; align-items: center; justify-content: center;
            font-family: var(--font-mono);
            font-size: 18px;
            color: var(--text-dim);
            transition: all 0.15s;
        }
        .key-hint.active { border-color: var(--qi-cyan); color: var(--qi-cyan); box-shadow: 0 0 12px var(--qi-cyan-glow); background: var(--qi-cyan-dim); }
        .key-hint.north.active { border-color: var(--qi-cyan); color: var(--qi-cyan); box-shadow: 0 0 12px var(--qi-cyan-glow); }
        .key-hint.east.active  { border-color: var(--qi-amber); color: var(--qi-amber); box-shadow: 0 0 12px rgba(255,184,0,0.4); }
        .key-hint.south.active { border-color: var(--qi-green); color: var(--qi-green); box-shadow: 0 0 12px rgba(57,255,20,0.4); }
        .key-hint.west.active  { border-color: var(--qi-purple); color: var(--qi-purple); box-shadow: 0 0 12px rgba(191,90,242,0.4); }
        .tutorial-progress { font-family: var(--font-mono); font-size: 13px; color: var(--text-dim); letter-spacing: 1px; }
        .tutorial-progress span { color: var(--qi-cyan); }

        .tutorial-phase { transition: opacity 0.4s, transform 0.4s; }
        .tutorial-phase.phase-hidden { display: none; }
        .tutorial-phase.phase-complete { opacity: 0.3; transform: scale(0.9); pointer-events: none; display: none; }
        .key-hint.wasd-key { color: var(--text-dim); border-color: var(--border-dim); }
        .key-hint.wasd-key.active {
            border-color: var(--qi-amber); color: var(--qi-amber);
            box-shadow: 0 0 12px rgba(255,184,0,0.4); background: var(--qi-amber-dim);
        }
        .tutorial-phase-status { display: flex; align-items: center; justify-content: center; gap: 8px; margin-top: 12px; }
        .phase-dot {
            width: 10px; height: 10px; border-radius: 50%;
            background: var(--qi-cyan); box-shadow: 0 0 8px var(--qi-cyan-glow); transition: all 0.3s;
        }
        .phase-dot.dim { background: var(--text-dim); box-shadow: none; }
        .phase-dot.complete { background: var(--qi-green); box-shadow: 0 0 8px rgba(57,255,20,0.4); }
        .phase-dot.active-phase { background: var(--qi-amber); box-shadow: 0 0 8px rgba(255,184,0,0.4); }
        .phase-label { font-family: var(--font-mono); font-size: 11px; letter-spacing: 1px; color: var(--qi-cyan); margin-right: 6px; }
        .phase-label.dim { color: var(--text-dim); }
        .phase-label.complete { color: var(--qi-green); }
        .phase-label.active-phase { color: var(--qi-amber); }

        /* Briefing info */
        .briefing-info {
            background: var(--bg-panel);
            border: 1px solid var(--border-dim);
            padding: 20px 24px;
            max-width: 560px;
            width: 100%;
            margin-bottom: 2vh;
            flex-shrink: 0;
        }
        .briefing-info h3 {
            font-family: var(--font-display);
            font-size: 12px; letter-spacing: 4px; color: var(--qi-amber); margin-bottom: 14px;
        }
        .briefing-columns { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; }
        .briefing-col-title {
            font-family: var(--font-display);
            font-size: 10px; letter-spacing: 3px; color: var(--qi-cyan);
            margin-bottom: 8px; padding-bottom: 6px; border-bottom: 1px solid var(--border-dim);
        }
        .briefing-info ul {
            list-style: none; font-family: var(--font-mono); font-size: 13px; color: var(--text-secondary);
        }
        .briefing-info li { padding: 4px 0; display: flex; align-items: baseline; gap: 8px; }
        .briefing-info li::before { content: '◇'; color: var(--qi-cyan); font-size: 9px; flex-shrink: 0; }
        .briefing-info .key-label {
            font-family: var(--font-display); font-size: 11px; color: var(--qi-cyan);
            background: var(--bg-card); padding: 2px 7px; border: 1px solid var(--border-dim);
            border-radius: 3px; flex-shrink: 0; min-width: 24px; text-align: center;
        }
        .briefing-info .key-label.amber { color: var(--qi-amber); }

        .briefing-enter {
            font-family: var(--font-display);
            font-size: 14px; letter-spacing: 5px;
            padding: 18px 56px; background: transparent;
            border: 2px solid var(--qi-cyan); color: var(--qi-cyan);
            cursor: pointer; transition: all 0.3s;
            opacity: 0.3; pointer-events: none; flex-shrink: 0;
        }
        .briefing-enter.ready { opacity: 1; pointer-events: auto; }
        .briefing-enter.ready:hover { background: var(--qi-cyan); color: var(--bg-deep); box-shadow: 0 0 40px var(--qi-cyan-glow); }
        .briefing-enter-hint {
            font-family: var(--font-mono); font-size: 12px; color: var(--text-dim);
            margin-top: 14px; letter-spacing: 1px; flex-shrink: 0;
        }

        /* ═══════════════ MAIN EXPLORATION ═══════════════ */
        .compass-world {
            position: relative; z-index: 1;
            width: 100%; height: 100%;
            display: grid; grid-template-rows: auto 1fr auto;
            opacity: 0; transition: opacity 0.5s;
        }
        .compass-world.active { opacity: 1; }
        /* HUD order: controls on top, info on bottom */
        .hud-controls { order: -1; }
        .main-area { order: 0; }
        .hud-info { order: 1; }

        /* HUD Top → now controls bar */
        .hud-controls {
            display: flex; justify-content: space-between; align-items: center;
            padding: 10px 20px; border-bottom: 1px solid var(--border-dim);
            background: rgba(6,8,13,0.95); z-index: 10;
        }
        .location-display {
            font-family: var(--font-display);
            font-size: clamp(12px, 1.6vw, 16px); letter-spacing: 3px;
            color: var(--qi-cyan); text-shadow: 0 0 20px var(--qi-cyan-glow);
            display: flex; align-items: center; gap: 12px;
        }
        .depth-badge {
            font-family: var(--font-mono); font-size: 12px;
            padding: 3px 10px; border: 1px solid var(--border-dim);
            background: var(--bg-card); color: var(--text-secondary); letter-spacing: 1px;
        }
        .coords-display {
            font-family: var(--font-mono); font-size: 12px;
            color: var(--text-dim); letter-spacing: 1px;
        }

        .hud-top-right { display: flex; align-items: center; gap: 12px; }

        /* Filter stack display */
        .filter-stack-display { display: flex; align-items: center; gap: 3px; }
        .filter-chip {
            font-family: var(--font-mono); font-size: 11px; letter-spacing: 1px;
            padding: 5px 10px; border: 1px solid var(--border-dim);
            border-radius: 3px;
            background: var(--bg-card); color: var(--text-dim);
            cursor: pointer; transition: all 0.2s; position: relative;
        }
        .filter-chip.active {
            border-color: var(--qi-amber); color: var(--qi-amber);
            background: var(--qi-amber-dim); box-shadow: 0 0 8px rgba(255,184,0,0.2);
        }
        .filter-chip .stack-order {
            position: absolute; top: -7px; right: -5px;
            font-family: var(--font-display); font-size: 9px;
            background: var(--qi-amber); color: var(--bg-deep);
            width: 16px; height: 16px; border-radius: 50%;
            display: none; align-items: center; justify-content: center;
            line-height: 1;
        }
        .filter-chip.active .stack-order { display: flex; }
        .filter-stack-arrow {
            font-family: var(--font-mono); font-size: 11px;
            color: var(--qi-amber); opacity: 0; transition: opacity 0.2s;
        }
        .filter-stack-arrow.visible { opacity: 0.6; }
        .filter-stack-clear {
            font-family: var(--font-mono); font-size: 11px;
            padding: 5px 8px; border: 1px solid var(--border-dim);
            border-radius: 3px;
            background: var(--bg-card); color: var(--text-dim);
            cursor: pointer; transition: all 0.2s; opacity: 0; pointer-events: none;
        }
        .filter-stack-clear.visible { opacity: 1; pointer-events: auto; }
        .filter-stack-clear:hover { border-color: var(--qi-red); color: var(--qi-red); }

        /* Main area — map fills everything */
        .main-area { display: grid; grid-template-columns: 1fr; overflow: hidden; position: relative; }

        /* Exploration zone → map fills center */
        .exploration-zone {
            display: flex; align-items: stretch; justify-content: stretch;
            position: relative; overflow: hidden; padding: 0;
            width: 100%; height: 100%;
        }

        /* Map takes full center */
        .map-main-container {
            flex: 1; position: relative; overflow: hidden;
        }
        .map-main-canvas { width: 100%; height: 100%; display: block; }
        .map-main-legend {
            position: absolute; bottom: 10px; right: 14px;
            display: flex; gap: 16px; flex-wrap: wrap;
            padding: 8px 14px;
            background: rgba(6,8,13,0.85);
            border: 1px solid var(--border-dim);
            border-radius: 4px;
        }

        /* Node card → de-emphasized floating corner panel */
        .node-container {
            position: absolute;
            bottom: 20px; left: 20px;
            width: 420px; max-height: 50vh;
            z-index: 20; pointer-events: auto;
        }
        .node-content {
            background: rgba(12,16,24,0.92);
            border: 1px solid var(--border-dim);
            padding: 22px 24px;
            position: relative;
            opacity: 0.88;
            transform: scale(1);
            transition: opacity 0.25s, transform 0.2s;
            max-height: 50vh; overflow-y: auto;
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
            font-size: 15px;
            border-radius: 6px;
        }
        .node-content:hover { opacity: 1; }
        .node-content.transitioning { opacity: 0; transform: scale(0.96); }
        .node-content::before {
            content: '';
            position: absolute; top: 0; left: 0; right: 0; height: 2px;
            background: linear-gradient(90deg, transparent, var(--node-color, var(--qi-cyan)), transparent);
        }
        /* scrollbar styling */
        .node-content::-webkit-scrollbar { width: 4px; }
        .node-content::-webkit-scrollbar-track { background: var(--bg-deep); }
        .node-content::-webkit-scrollbar-thumb { background: var(--border-dim); }

        .node-title {
            font-family: var(--font-display);
            font-size: clamp(16px, 2.2vw, 22px); font-weight: 700;
            letter-spacing: 4px; margin-bottom: 4px;
            color: var(--node-color, var(--qi-cyan));
            text-shadow: 0 0 24px var(--node-glow, var(--qi-cyan-glow));
        }
        .node-subtitle {
            font-family: var(--font-mono); font-size: 12px;
            color: var(--text-secondary); letter-spacing: 2px;
            margin-bottom: 14px; text-transform: uppercase;
        }
        .node-description { font-size: 14px; color: var(--text-primary); line-height: 1.7; margin-bottom: 14px; opacity: 0.9; }
        .node-data { display: grid; grid-template-columns: repeat(auto-fit, minmax(100px, 1fr)); gap: 8px; margin-bottom: 14px; }
        .data-block { background: var(--bg-card); border: 1px solid var(--border-dim); padding: 8px 10px; border-radius: 4px; }
        .data-label { font-family: var(--font-mono); font-size: 9px; color: var(--text-dim); letter-spacing: 2px; margin-bottom: 2px; }
        .data-value { font-family: var(--font-display); font-size: 13px; color: var(--node-color, var(--qi-cyan)); }
        .node-tags { display: flex; flex-wrap: wrap; gap: 6px; }
        .node-tag {
            font-family: var(--font-mono); font-size: 10px; letter-spacing: 1px;
            padding: 3px 8px; background: var(--qi-cyan-dim);
            border: 1px solid var(--border-dim); color: var(--qi-cyan); border-radius: 3px;
        }

        /* Filter content layers */
        .filter-content {
            margin-top: 10px; padding-top: 10px;
            border-top: 1px solid var(--border-dim);
            animation: filterFadeIn 0.3s ease;
        }
        @keyframes filterFadeIn {
            from { opacity: 0; transform: translateY(6px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .filter-section-title {
            font-family: var(--font-display); font-size: 9px;
            letter-spacing: 2px; color: var(--qi-amber); margin-bottom: 6px;
        }
        .filter-text {
            font-size: 13px; color: var(--qi-amber);
            line-height: 1.6; font-style: italic; opacity: 0.85;
        }

        /* Composite filter insight */
        .composite-content {
            margin-top: 10px; padding: 10px;
            border: 1px solid var(--qi-amber);
            background: rgba(255, 184, 0, 0.06);
            position: relative;
            animation: compositeReveal 0.5s ease;
        }
        @keyframes compositeReveal {
            from { opacity: 0; transform: scale(0.97); border-color: transparent; }
            to { opacity: 1; transform: scale(1); border-color: var(--qi-amber); }
        }
        .composite-content::before {
            content: '';
            position: absolute; top: 0; left: 0; right: 0; height: 2px;
            background: linear-gradient(90deg, transparent, var(--qi-amber), transparent);
        }
        .composite-label {
            font-family: var(--font-display); font-size: 9px;
            letter-spacing: 2px; color: var(--qi-amber); margin-bottom: 6px;
            display: flex; align-items: center; gap: 6px;
        }
        .composite-label .combo-icon {
            font-size: 12px; opacity: 0.7;
        }
        .composite-text {
            font-size: 14px; color: #ffd466;
            line-height: 1.65; font-weight: 500;
        }

        /* Discovery notification */
        .discovery-notification {
            position: fixed; top: 50%; left: 50%;
            transform: translate(-50%, -50%) scale(0.8);
            background: rgba(6, 8, 13, 0.95);
            border: 2px solid var(--qi-amber);
            padding: 32px 52px; text-align: center;
            border-radius: 8px;
            z-index: 500; pointer-events: none;
            opacity: 0; transition: all 0.4s cubic-bezier(0.16, 1, 0.3, 1);
            box-shadow: 0 0 80px rgba(255, 184, 0, 0.3), inset 0 0 60px rgba(255, 184, 0, 0.05);
        }
        .discovery-notification.active {
            opacity: 1; transform: translate(-50%, -50%) scale(1);
        }
        .discovery-icon {
            font-family: var(--font-display); font-size: 14px;
            letter-spacing: 5px; color: var(--qi-amber); margin-bottom: 10px; opacity: 0.6;
        }
        .discovery-title {
            font-family: var(--font-display); font-size: 22px;
            letter-spacing: 4px; color: var(--qi-amber);
            text-shadow: 0 0 30px rgba(255,184,0,0.5); margin-bottom: 6px;
        }
        .discovery-sub {
            font-family: var(--font-mono); font-size: 13px;
            color: var(--text-secondary); letter-spacing: 1px;
        }

        /* Locked nodes */
        .locked-overlay {
            display: flex; flex-direction: column; align-items: center;
            justify-content: center; padding: 28px; text-align: center;
        }
        .locked-icon { font-size: 40px; margin-bottom: 16px; opacity: 0.5; }
        .locked-title {
            font-family: var(--font-display); font-size: 16px;
            letter-spacing: 5px; color: var(--qi-amber); margin-bottom: 10px;
        }
        .locked-desc {
            font-family: var(--font-mono); font-size: 13px;
            color: var(--text-secondary); margin-bottom: 18px; max-width: 300px; line-height: 1.7;
        }
        .unlock-btn {
            font-family: var(--font-display); font-size: 11px;
            letter-spacing: 3px; padding: 12px 26px;
            background: transparent; border: 1px solid var(--qi-amber);
            color: var(--qi-amber); cursor: pointer; transition: all 0.3s;
        }
        .unlock-btn:hover:not(:disabled) { background: var(--qi-amber); color: var(--bg-deep); }
        .unlock-btn:disabled { opacity: 0.3; cursor: not-allowed; }
        .unlock-cost { font-family: var(--font-mono); font-size: 11px; color: var(--text-dim); margin-top: 10px; }

        /* Nav hints */
        .nav-hints {
            display: grid; grid-template-columns: 1fr 1fr; gap: 6px;
            margin-top: 14px; padding-top: 14px; border-top: 1px solid var(--border-dim);
        }
        .nav-hint-item {
            display: flex; align-items: center; gap: 6px;
            font-family: var(--font-mono); font-size: 11px;
            color: var(--text-dim); letter-spacing: 0.5px;
        }
        .nav-hint-item.available { color: var(--text-secondary); }
        .nav-hint-item.revealed { color: var(--qi-amber); }
        .nav-hint-key {
            font-family: var(--font-display); font-size: 11px;
            width: 26px; height: 26px;
            display: flex; align-items: center; justify-content: center;
            border: 1px solid var(--border-dim); background: var(--bg-card); flex-shrink: 0;
            border-radius: 3px;
        }
        .nav-hint-item.available .nav-hint-key { border-color: var(--border-bright); color: var(--qi-cyan); }
        .nav-hint-item.revealed .nav-hint-key { border-color: var(--qi-amber); color: var(--qi-amber); }

        /* ═══════════════ SIDEBAR (now hidden — map is center) ═══════════════ */
        .sidebar { display: none; }
        .sidebar-tabs { display: flex; border-bottom: 1px solid var(--border-dim); flex-shrink: 0; }
        .sidebar-tab {
            flex: 1; padding: 8px 4px;
            font-family: var(--font-display); font-size: 8px; letter-spacing: 2px;
            text-align: center; color: var(--text-dim); background: none;
            border: none; cursor: pointer; transition: all 0.2s;
            border-bottom: 2px solid transparent;
        }
        .sidebar-tab:hover { color: var(--text-secondary); }
        .sidebar-tab.active { color: var(--qi-cyan); border-bottom-color: var(--qi-cyan); background: var(--qi-cyan-dim); }
        .sidebar-panel { flex: 1; overflow: hidden; display: none; }
        .sidebar-panel.active { display: flex; flex-direction: column; }

        .map-container { flex: 1; position: relative; overflow: hidden; }
        .map-canvas { width: 100%; height: 100%; }
        .map-legend { padding: 10px 14px; border-top: 1px solid var(--border-dim); display: flex; gap: 14px; flex-wrap: wrap; }
        .legend-item { display: flex; align-items: center; gap: 5px; font-family: var(--font-mono); font-size: 11px; color: var(--text-dim); letter-spacing: 0.5px; }
        .legend-dot { width: 8px; height: 8px; border-radius: 50%; }

        .index-header { padding: 12px 14px; border-bottom: 1px solid var(--border-dim); flex-shrink: 0; }
        .index-title { font-family: var(--font-display); font-size: 11px; letter-spacing: 3px; color: var(--qi-cyan); margin-bottom: 3px; }
        .index-stats { font-family: var(--font-mono); font-size: 11px; color: var(--text-dim); }
        .index-list { flex: 1; overflow-y: auto; padding: 6px; }
        .index-category { margin-bottom: 10px; }
        .index-category-title {
            font-family: var(--font-mono); font-size: 8px; letter-spacing: 2px;
            color: var(--text-dim); padding: 4px 5px;
            border-bottom: 1px solid var(--border-dim); margin-bottom: 4px;
        }
        .index-node {
            display: flex; align-items: center; gap: 6px;
            padding: 4px 6px; cursor: pointer;
            transition: background 0.2s; border: 1px solid transparent;
        }
        .index-node:hover { background: var(--bg-card); border-color: var(--border-dim); }
        .index-node.current { background: var(--qi-cyan-dim); border-color: var(--qi-cyan); }
        .index-node.unexplored { opacity: 0.3; cursor: default; }
        .index-node-icon { width: 5px; height: 5px; border-radius: 50%; flex-shrink: 0; }
        .index-node-icon.explored { background: var(--qi-green); }
        .index-node-icon.current { background: var(--qi-cyan); }
        .index-node-icon.unexplored { background: var(--text-dim); }
        .index-node-icon.revealed { background: var(--qi-amber); }
        .index-node-name { font-family: var(--font-mono); font-size: 9px; color: var(--text-secondary); letter-spacing: 0.5px; }
        .index-node.current .index-node-name { color: var(--qi-cyan); }

        /* ═══════════════ HUD BOTTOM → info bar ═══════════════ */
        .hud-info {
            display: flex; justify-content: space-between; align-items: center;
            padding: 10px 20px; border-top: 1px solid var(--border-dim);
            background: rgba(6,8,13,0.95); z-index: 10; gap: 16px;
        }
        .controls-group { display: flex; align-items: center; gap: 18px; }
        .control-cluster { display: flex; flex-direction: column; align-items: center; gap: 3px; }
        .cluster-label { font-family: var(--font-display); font-size: 9px; letter-spacing: 2px; color: var(--text-dim); margin-bottom: 3px; }
        .cluster-label.arrows { color: var(--qi-cyan); }
        .cluster-label.wasd { color: var(--qi-amber); }

        .dpad { display: grid; grid-template-columns: repeat(3, 34px); grid-template-rows: repeat(2, 34px); gap: 3px; }
        .dpad .ctrl-btn:nth-child(1) { grid-column: 2; grid-row: 1; }
        .dpad .ctrl-btn:nth-child(2) { grid-column: 1; grid-row: 2; }
        .dpad .ctrl-btn:nth-child(3) { grid-column: 2; grid-row: 2; }
        .dpad .ctrl-btn:nth-child(4) { grid-column: 3; grid-row: 2; }

        .ctrl-btn {
            font-family: var(--font-display); font-size: 12px;
            width: 34px; height: 34px;
            background: var(--bg-card); border: 1px solid var(--border-dim);
            border-radius: 4px;
            color: var(--qi-cyan); cursor: pointer; transition: all 0.15s;
            display: flex; align-items: center; justify-content: center;
        }
        .ctrl-btn:hover:not(:disabled) { background: var(--qi-cyan-dim); border-color: var(--qi-cyan); }
        .ctrl-btn:disabled { opacity: 0.15; cursor: not-allowed; }
        .ctrl-btn.pressed { background: var(--qi-cyan-dim); border-color: var(--qi-cyan); box-shadow: 0 0 10px var(--qi-cyan-glow); }
        .ctrl-btn.wasd-btn { color: var(--qi-amber); }
        .ctrl-btn.wasd-btn:hover:not(:disabled) { background: var(--qi-amber-dim); border-color: var(--qi-amber); }
        .ctrl-btn.wasd-btn.pressed, .ctrl-btn.wasd-btn.stack-active {
            background: var(--qi-amber-dim); border-color: var(--qi-amber);
            box-shadow: 0 0 10px rgba(255,184,0,0.3);
        }

        .ctrl-divider { width: 1px; height: 40px; background: var(--border-dim); }

        .back-btn {
            font-family: var(--font-display); font-size: 11px;
            padding: 8px 16px; background: var(--bg-card);
            border: 1px solid var(--border-dim); color: var(--text-secondary);
            border-radius: 4px;
            cursor: pointer; transition: all 0.2s; letter-spacing: 1px;
        }
        .back-btn:hover:not(:disabled) { border-color: var(--border-bright); color: var(--text-primary); }
        .back-btn:disabled { opacity: 0.2; cursor: not-allowed; }

        .path-display {
            font-family: var(--font-mono); font-size: 12px; color: var(--text-dim);
            letter-spacing: 0.5px; max-width: 300px; overflow: hidden;
            text-overflow: ellipsis; white-space: nowrap;
        }
        .path-display span { color: var(--qi-cyan); }

        .back-link {
            font-family: var(--font-mono); font-size: 12px;
            color: var(--text-dim); text-decoration: none;
            letter-spacing: 2px; transition: color 0.3s; flex-shrink: 0;
        }
        .back-link:hover { color: var(--qi-cyan); }

        .flash-overlay {
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background: var(--qi-cyan); opacity: 0; pointer-events: none;
            z-index: 100; transition: opacity 0.1s;
        }
        .flash-overlay.active { opacity: 0.08; }

        /* ═══════════════ VIEW TOGGLE + COMPASS VIEW ═══════════════ */
        .view-toggle {
            position: absolute; top: 12px; right: 12px; z-index: 25;
            display: flex; gap: 2px;
        }
        .view-toggle-btn {
            font-family: var(--font-display); font-size: 10px;
            letter-spacing: 2px; padding: 8px 18px;
            background: var(--bg-card); border: 1px solid var(--border-dim);
            border-radius: 4px;
            color: var(--text-dim); cursor: pointer; transition: all 0.2s;
        }
        .view-toggle-btn:first-child { border-radius: 0; }
        .view-toggle-btn:last-child { border-radius: 0; }
        .view-toggle-btn.active {
            border-color: var(--qi-cyan); color: var(--qi-cyan);
            background: var(--qi-cyan-dim); box-shadow: 0 0 10px var(--qi-cyan-glow);
        }
        .view-toggle-btn:hover:not(.active) { border-color: var(--border-bright); color: var(--text-secondary); }
        .view-toggle-hint {
            font-family: var(--font-mono); font-size: 10px;
            color: var(--text-dim); padding: 8px 0 0 4px;
            align-self: center;
        }

        .compass-canvas-wrap {
            position: absolute; top: 0; left: 0; right: 0; bottom: 0;
            z-index: 5; transition: opacity 0.3s;
        }
        .compass-canvas-wrap.hidden { opacity: 0; pointer-events: none; }
        .compass-view-canvas { width: 100%; height: 100%; display: block; }

        .map-main-container { z-index: 4; transition: opacity 0.3s; }
        .map-main-container.hidden { opacity: 0; pointer-events: none; }

        /* ═══════════════ DIRECTIONAL NAV ANIMATIONS ═══════════════ */
        .node-content.slide-up    { animation: slideFromBelow 0.28s cubic-bezier(0.22, 1, 0.36, 1); }
        .node-content.slide-down  { animation: slideFromAbove 0.28s cubic-bezier(0.22, 1, 0.36, 1); }
        .node-content.slide-left  { animation: slideFromLeft 0.28s cubic-bezier(0.22, 1, 0.36, 1); }
        .node-content.slide-right { animation: slideFromRight 0.28s cubic-bezier(0.22, 1, 0.36, 1); }
        @keyframes slideFromBelow {
            0%   { opacity: 0; transform: translateY(18px); }
            100% { opacity: 1; transform: translateY(0); }
        }
        @keyframes slideFromAbove {
            0%   { opacity: 0; transform: translateY(-18px); }
            100% { opacity: 1; transform: translateY(0); }
        }
        @keyframes slideFromLeft {
            0%   { opacity: 0; transform: translateX(-18px); }
            100% { opacity: 1; transform: translateX(0); }
        }
        @keyframes slideFromRight {
            0%   { opacity: 0; transform: translateX(18px); }
            100% { opacity: 1; transform: translateX(0); }
        }

        /* Directional sweep overlay on compass canvas */
        .compass-canvas-wrap .nav-sweep {
            position: absolute; pointer-events: none; z-index: 6;
            opacity: 0; transition: none;
        }
        .compass-canvas-wrap .nav-sweep.sweep-up {
            top: 0; left: 0; right: 0; height: 40%;
            background: linear-gradient(to bottom, rgba(0,240,255,0.08), transparent);
            animation: sweepFade 0.35s ease-out;
        }
        .compass-canvas-wrap .nav-sweep.sweep-down {
            bottom: 0; left: 0; right: 0; height: 40%;
            background: linear-gradient(to top, rgba(0,240,255,0.08), transparent);
            animation: sweepFade 0.35s ease-out;
        }
        .compass-canvas-wrap .nav-sweep.sweep-left {
            top: 0; left: 0; bottom: 0; width: 40%;
            background: linear-gradient(to right, rgba(0,240,255,0.08), transparent);
            animation: sweepFade 0.35s ease-out;
        }
        .compass-canvas-wrap .nav-sweep.sweep-right {
            top: 0; right: 0; bottom: 0; width: 40%;
            background: linear-gradient(to left, rgba(0,240,255,0.08), transparent);
            animation: sweepFade 0.35s ease-out;
        }
        @keyframes sweepFade {
            0%   { opacity: 1; }
            100% { opacity: 0; }
        }

        /* ═══════════════ PER-FILTER COLORS ═══════════════ */
        .filter-chip[data-filter="technical"].active {
            border-color: var(--filter-tech); color: var(--filter-tech);
            background: var(--filter-tech-dim); box-shadow: 0 0 8px rgba(0,240,255,0.2);
        }
        .filter-chip[data-filter="ethical"].active {
            border-color: var(--filter-ethic); color: var(--filter-ethic);
            background: var(--filter-ethic-dim); box-shadow: 0 0 8px rgba(191,90,242,0.2);
        }
        .filter-chip[data-filter="economic"].active {
            border-color: var(--filter-econ); color: var(--filter-econ);
            background: var(--filter-econ-dim); box-shadow: 0 0 8px rgba(57,255,20,0.2);
        }
        .filter-chip[data-filter="social"].active {
            border-color: var(--filter-social); color: var(--filter-social);
            background: var(--filter-social-dim); box-shadow: 0 0 8px rgba(255,184,0,0.2);
        }
        .filter-chip[data-filter="technical"].active .stack-order { background: var(--filter-tech); }
        .filter-chip[data-filter="ethical"].active .stack-order { background: var(--filter-ethic); }
        .filter-chip[data-filter="economic"].active .stack-order { background: var(--filter-econ); }
        .filter-chip[data-filter="social"].active .stack-order { background: var(--filter-social); }

        /* Per-filter WASD button colors */
        .ctrl-btn.wasd-btn.filter-tech { color: var(--filter-tech); }
        .ctrl-btn.wasd-btn.filter-ethic { color: var(--filter-ethic); }
        .ctrl-btn.wasd-btn.filter-econ { color: var(--filter-econ); }
        .ctrl-btn.wasd-btn.filter-social { color: var(--filter-social); }
        .ctrl-btn.wasd-btn.filter-tech:hover:not(:disabled) { background: var(--filter-tech-dim); border-color: var(--filter-tech); }
        .ctrl-btn.wasd-btn.filter-ethic:hover:not(:disabled) { background: var(--filter-ethic-dim); border-color: var(--filter-ethic); }
        .ctrl-btn.wasd-btn.filter-econ:hover:not(:disabled) { background: var(--filter-econ-dim); border-color: var(--filter-econ); }
        .ctrl-btn.wasd-btn.filter-social:hover:not(:disabled) { background: var(--filter-social-dim); border-color: var(--filter-social); }
        .ctrl-btn.wasd-btn.filter-tech.stack-active, .ctrl-btn.wasd-btn.filter-tech.pressed {
            background: var(--filter-tech-dim); border-color: var(--filter-tech); box-shadow: 0 0 10px rgba(0,240,255,0.3);
        }
        .ctrl-btn.wasd-btn.filter-ethic.stack-active, .ctrl-btn.wasd-btn.filter-ethic.pressed {
            background: var(--filter-ethic-dim); border-color: var(--filter-ethic); box-shadow: 0 0 10px rgba(191,90,242,0.3);
        }
        .ctrl-btn.wasd-btn.filter-econ.stack-active, .ctrl-btn.wasd-btn.filter-econ.pressed {
            background: var(--filter-econ-dim); border-color: var(--filter-econ); box-shadow: 0 0 10px rgba(57,255,20,0.3);
        }
        .ctrl-btn.wasd-btn.filter-social.stack-active, .ctrl-btn.wasd-btn.filter-social.pressed {
            background: var(--filter-social-dim); border-color: var(--filter-social); box-shadow: 0 0 10px rgba(255,184,0,0.3);
        }

        /* ═══════════════ HUD FILTER LEGEND ═══════════════ */
        .filter-legend {
            display: flex; align-items: center; gap: 14px;
            font-family: var(--font-mono); font-size: 11px;
            padding-left: 14px; border-left: 1px solid var(--border-dim);
            margin-left: 4px;
        }
        .filter-legend-item {
            display: flex; align-items: center; gap: 5px;
            color: var(--text-dim); letter-spacing: 0.5px;
            transition: color 0.2s, opacity 0.2s;
            opacity: 0.5;
        }
        .filter-legend-item.active { opacity: 1; }
        .filter-legend-item.active[data-legend="technical"] { color: var(--filter-tech); }
        .filter-legend-item.active[data-legend="ethical"] { color: var(--filter-ethic); }
        .filter-legend-item.active[data-legend="economic"] { color: var(--filter-econ); }
        .filter-legend-item.active[data-legend="social"] { color: var(--filter-social); }
        .filter-legend-dot {
            width: 8px; height: 8px; border-radius: 50%;
            background: var(--text-dim); transition: all 0.2s;
            box-shadow: none;
        }
        .filter-legend-item.active[data-legend="technical"] .filter-legend-dot {
            background: var(--filter-tech); box-shadow: 0 0 6px rgba(0,240,255,0.4);
        }
        .filter-legend-item.active[data-legend="ethical"] .filter-legend-dot {
            background: var(--filter-ethic); box-shadow: 0 0 6px rgba(191,90,242,0.4);
        }
        .filter-legend-item.active[data-legend="economic"] .filter-legend-dot {
            background: var(--filter-econ); box-shadow: 0 0 6px rgba(57,255,20,0.4);
        }
        .filter-legend-item.active[data-legend="social"] .filter-legend-dot {
            background: var(--filter-social); box-shadow: 0 0 6px rgba(255,184,0,0.4);
        }
        .filter-legend-combo {
            display: none; align-items: center; gap: 5px;
            color: var(--text-dim); letter-spacing: 0.5px;
            opacity: 0.7;
        }
        .filter-legend-combo.active { display: flex; }
        .filter-legend-combo-swatch {
            width: 16px; height: 8px; border-radius: 3px;
            transition: all 0.3s;
        }

        /* ═══════════════ RESPONSIVE ═══════════════ */
        @media (max-width: 900px) {
            .main-area { grid-template-columns: 1fr; }
            .node-container { width: 360px; }
        }
        @media (max-width: 600px) {
            .path-display { display: none; }
            .hud-controls { padding: 6px 10px; }
            .hud-info { padding: 6px 10px; }
            .filter-stack-display { display: none; }
            .filter-legend { display: none; }
            .node-container { width: 280px; max-height: 40vh; bottom: 10px; left: 10px; }
            .node-content { padding: 14px 16px; font-size: 13px; }
            .node-title { font-size: 14px !important; letter-spacing: 2px; }
            .node-description { font-size: 12px; }
        }
    </style>
</head>
<body>

<div class="grid-bg"></div>
<div class="flash-overlay" id="flash"></div>

<!-- Discovery Notification -->
<div class="discovery-notification" id="discoveryNotif">
    <div class="discovery-icon">◇ NEW PATH REVEALED ◇</div>
    <div class="discovery-title" id="discoveryTitle"></div>
    <div class="discovery-sub" id="discoverySub"></div>
</div>

<!-- ═══════════════ BRIEFING ═══════════════ -->
<div class="briefing-overlay" id="briefingOverlay">

    <div class="briefing-header">
        <h1 class="briefing-title">AI MORAL COMPASS</h1>
        <p class="briefing-subtitle">POSSIBILITY NAVIGATOR v0.3</p>
    </div>

    <div class="compass-hero">
        <svg class="compass-svg" id="heroCompass" viewBox="0 0 500 500" xmlns="http://www.w3.org/2000/svg">
            <defs>
                <linearGradient id="cyanGrad" x1="0%" y1="0%" x2="100%" y2="100%">
                    <stop offset="0%" style="stop-color:#00f0ff"/><stop offset="100%" style="stop-color:#0088aa"/>
                </linearGradient>
                <linearGradient id="amberGrad" x1="0%" y1="0%" x2="100%" y2="100%">
                    <stop offset="0%" style="stop-color:#ffb800"/><stop offset="100%" style="stop-color:#cc8800"/>
                </linearGradient>
                <linearGradient id="greenGrad" x1="0%" y1="0%" x2="100%" y2="100%">
                    <stop offset="0%" style="stop-color:#39FF14"/><stop offset="100%" style="stop-color:#22aa0a"/>
                </linearGradient>
                <linearGradient id="purpleGrad" x1="0%" y1="0%" x2="100%" y2="100%">
                    <stop offset="0%" style="stop-color:#bf5af2"/><stop offset="100%" style="stop-color:#8a3fbd"/>
                </linearGradient>
                <filter id="glow"><feGaussianBlur stdDeviation="3" result="b"/><feMerge><feMergeNode in="b"/><feMergeNode in="SourceGraphic"/></feMerge></filter>
                <filter id="softGlow"><feGaussianBlur stdDeviation="6" result="b"/><feMerge><feMergeNode in="b"/><feMergeNode in="SourceGraphic"/></feMerge></filter>
                <filter id="strongGlow"><feGaussianBlur stdDeviation="8" result="b"/><feMerge><feMergeNode in="b"/><feMergeNode in="SourceGraphic"/></feMerge></filter>
                <radialGradient id="centerGlow" cx="50%" cy="50%" r="50%">
                    <stop offset="0%" style="stop-color:#00f0ff;stop-opacity:0.15"/>
                    <stop offset="100%" style="stop-color:#00f0ff;stop-opacity:0"/>
                </radialGradient>
            </defs>

            <circle cx="250" cy="250" r="230" fill="none" stroke="rgba(0,240,255,0.15)" stroke-width="1"/>
            <g stroke="rgba(0,240,255,0.3)" stroke-width="1">
                <line x1="250" y1="25" x2="250" y2="35" transform="rotate(0,250,250)"/>
                <line x1="250" y1="25" x2="250" y2="32" transform="rotate(30,250,250)"/>
                <line x1="250" y1="25" x2="250" y2="32" transform="rotate(60,250,250)"/>
                <line x1="250" y1="25" x2="250" y2="35" transform="rotate(90,250,250)"/>
                <line x1="250" y1="25" x2="250" y2="32" transform="rotate(120,250,250)"/>
                <line x1="250" y1="25" x2="250" y2="32" transform="rotate(150,250,250)"/>
                <line x1="250" y1="25" x2="250" y2="35" transform="rotate(180,250,250)"/>
                <line x1="250" y1="25" x2="250" y2="32" transform="rotate(210,250,250)"/>
                <line x1="250" y1="25" x2="250" y2="32" transform="rotate(240,250,250)"/>
                <line x1="250" y1="25" x2="250" y2="35" transform="rotate(270,250,250)"/>
                <line x1="250" y1="25" x2="250" y2="32" transform="rotate(300,250,250)"/>
                <line x1="250" y1="25" x2="250" y2="32" transform="rotate(330,250,250)"/>
            </g>
            <circle cx="250" cy="250" r="195" fill="none" stroke="rgba(0,240,255,0.08)" stroke-width="1" stroke-dasharray="4 8"/>
            <circle cx="250" cy="250" r="170" fill="none" stroke="rgba(0,240,255,0.25)" stroke-width="2"/>
            <g stroke="rgba(0,240,255,0.3)" stroke-width="1" fill="none">
                <path d="M250,80 L250,170"/><path d="M330,250 L420,250"/>
                <path d="M250,330 L250,420"/><path d="M80,250 L170,250"/>
            </g>
            <circle cx="250" cy="250" r="120" fill="url(#centerGlow)"/>
            <circle cx="250" cy="250" r="100" fill="none" stroke="rgba(0,240,255,0.12)" stroke-width="1"/>

            <circle class="dir-highlight north-highlight" cx="250" cy="80" r="50" fill="rgba(0,240,255,0.15)" filter="url(#strongGlow)"/>
            <circle class="dir-highlight east-highlight" cx="420" cy="250" r="50" fill="rgba(255,184,0,0.15)" filter="url(#strongGlow)"/>
            <circle class="dir-highlight south-highlight" cx="250" cy="420" r="50" fill="rgba(57,255,20,0.15)" filter="url(#strongGlow)"/>
            <circle class="dir-highlight west-highlight" cx="80" cy="250" r="50" fill="rgba(191,90,242,0.15)" filter="url(#strongGlow)"/>

            <g filter="url(#glow)">
                <g class="arrow-north"><polygon points="250,80 262,155 250,135 238,155" fill="url(#cyanGrad)" opacity="0.9"/></g>
                <g class="arrow-east"><polygon points="420,250 345,238 365,250 345,262" fill="url(#amberGrad)" opacity="0.9"/></g>
                <g class="arrow-south"><polygon points="250,420 238,345 250,365 262,345" fill="url(#greenGrad)" opacity="0.9"/></g>
                <g class="arrow-west"><polygon points="80,250 155,262 135,250 155,238" fill="url(#purpleGrad)" opacity="0.9"/></g>
            </g>

            <g opacity="0.25">
                <polygon points="250,115 255,145 250,135 245,145" fill="#00f0ff" transform="rotate(45,250,250)"/>
                <polygon points="250,115 255,145 250,135 245,145" fill="#00f0ff" transform="rotate(135,250,250)"/>
                <polygon points="250,115 255,145 250,135 245,145" fill="#00f0ff" transform="rotate(225,250,250)"/>
                <polygon points="250,115 255,145 250,135 245,145" fill="#00f0ff" transform="rotate(315,250,250)"/>
            </g>

            <g font-family="Orbitron, monospace" font-weight="700" text-anchor="middle">
                <text x="250" y="55" fill="#00f0ff" font-size="12" letter-spacing="3" filter="url(#softGlow)">HUMAN</text>
                <text x="448" y="247" fill="#ffb800" font-size="12" letter-spacing="3" filter="url(#softGlow)">AGENT</text>
                <text x="250" y="455" fill="#39FF14" font-size="12" letter-spacing="3" filter="url(#softGlow)">ENERGY</text>
                <text x="52" y="247" fill="#bf5af2" font-size="12" letter-spacing="3" filter="url(#softGlow)">VALUE</text>
            </g>

            <circle cx="250" cy="250" r="25" fill="#0c1018" stroke="#00f0ff" stroke-width="2"/>
            <circle cx="250" cy="250" r="15" fill="#00f0ff" opacity="0.1"/>
            <circle cx="250" cy="250" r="8" fill="#00f0ff" opacity="0.4" filter="url(#glow)"/>

            <g stroke="#00f0ff" stroke-width="1" fill="none" opacity="0.25">
                <path d="M15,15 L15,55 M15,15 L55,15"/>
                <path d="M485,15 L485,55 M485,15 L445,15"/>
                <path d="M15,485 L15,445 M15,485 L55,485"/>
                <path d="M485,485 L485,445 M485,485 L445,485"/>
            </g>
        </svg>
    </div>

    <div class="tutorial-prompt">
        <div class="tutorial-phase" id="tutPhase1">
            <p class="tutorial-text">PHASE 1 — NAVIGATE ↑↓←→</p>
            <div class="tutorial-keys">
                <div class="key-hint north" id="keyUp">↑</div>
            </div>
            <div class="tutorial-keys">
                <div class="key-hint west" id="keyLeft">←</div>
                <div class="key-hint south" id="keyDown">↓</div>
                <div class="key-hint east" id="keyRight">→</div>
            </div>
            <p class="tutorial-progress"><span id="tutorialCount">0</span> / 4 directions</p>
        </div>
        <div class="tutorial-phase phase-hidden" id="tutPhase2">
            <p class="tutorial-text" style="color:var(--qi-amber)">PHASE 2 — FILTER W A S D</p>
            <div class="tutorial-keys">
                <div class="key-hint wasd-key" id="keyW">W</div>
            </div>
            <div class="tutorial-keys">
                <div class="key-hint wasd-key" id="keyA">A</div>
                <div class="key-hint wasd-key" id="keyS">S</div>
                <div class="key-hint wasd-key" id="keyD">D</div>
            </div>
            <p class="tutorial-progress"><span id="tutorialCount2">0</span> / 4 lenses</p>
        </div>
        <div class="tutorial-phase-status" id="phaseStatus">
            <span class="phase-dot" id="phaseDot1"></span>
            <span class="phase-label">NAVIGATE</span>
            <span class="phase-dot dim" id="phaseDot2"></span>
            <span class="phase-label dim" id="phaseLabel2">FILTER</span>
        </div>
    </div>

    <div class="briefing-info">
        <h3>DUAL CONTROL FRAMEWORK</h3>
        <div class="briefing-columns">
            <div>
                <div class="briefing-col-title" style="color:var(--qi-cyan)">↑↓←→ NAVIGATE</div>
                <ul>
                    <li><span class="key-label">↑</span> Deeper into topic</li>
                    <li><span class="key-label">↓</span> Back out / broader</li>
                    <li><span class="key-label">←</span><span class="key-label">→</span> Adjacent ideas</li>
                </ul>
            </div>
            <div>
                <div class="briefing-col-title" style="color:var(--qi-amber)">WASD COMPOSABLE FILTERS</div>
                <ul>
                    <li><span class="key-label amber">W</span> Technical lens</li>
                    <li><span class="key-label amber">A</span> Ethical lens</li>
                    <li><span class="key-label amber">S</span> Economic lens</li>
                    <li><span class="key-label amber">D</span> Social lens</li>
                </ul>
            </div>
        </div>
    </div>

    <button class="briefing-enter" id="enterBtn" onclick="enterCompass()">BEGIN EXPLORATION</button>
    <p class="briefing-enter-hint" id="enterHint">Complete both calibration phases to unlock</p>
</div>

<!-- ═══════════════ MAIN EXPLORATION ═══════════════ -->
<div class="compass-world" id="compassWorld">

    <!-- TOP: Controls (was bottom) -->
    <div class="hud-controls">
        <div class="controls-group">
            <button class="back-btn" id="backBtn" onclick="goBack()" disabled>← BACK</button>
            <div class="ctrl-divider"></div>

            <div class="control-cluster">
                <div class="cluster-label arrows">NAVIGATE</div>
                <div class="dpad">
                    <button class="ctrl-btn" id="btnUp" onclick="navDepth('deeper')" title="Go deeper">▲</button>
                    <button class="ctrl-btn" id="btnLeft" onclick="navBreadth('left')" title="Adjacent left">◀</button>
                    <button class="ctrl-btn" id="btnDown" onclick="navDepth('broader')" title="Go broader">▼</button>
                    <button class="ctrl-btn" id="btnRight" onclick="navBreadth('right')" title="Adjacent right">▶</button>
                </div>
            </div>

            <div class="ctrl-divider"></div>

            <div class="control-cluster">
                <div class="cluster-label wasd">FILTER STACK</div>
                <div class="dpad">
                    <button class="ctrl-btn wasd-btn filter-tech" id="btnW" onclick="toggleFilter('technical')">W</button>
                    <button class="ctrl-btn wasd-btn filter-ethic" id="btnA" onclick="toggleFilter('ethical')">A</button>
                    <button class="ctrl-btn wasd-btn filter-econ" id="btnS" onclick="toggleFilter('economic')">S</button>
                    <button class="ctrl-btn wasd-btn filter-social" id="btnD" onclick="toggleFilter('social')">D</button>
                </div>
            </div>
        </div>

        <div class="path-display">PATH: <span id="pathDisplay">origin</span></div>
        <a href="index.html" class="back-link">← QI.XYZ</a>
    </div>

    <!-- CENTER: Dual view — compass (zoomed) and tree (overview) -->
    <div class="main-area">
        <div class="exploration-zone">
            <!-- Compass View (zoomed in — default) -->
            <div class="compass-canvas-wrap" id="compassViewWrap">
                <canvas class="compass-view-canvas" id="compassCanvas"></canvas>
                <div class="nav-sweep" id="navSweep"></div>
            </div>
            <!-- Tree View (branch overview) -->
            <div class="map-main-container hidden" id="treeViewWrap">
                <canvas class="map-main-canvas" id="mapCanvas"></canvas>
                <div class="map-main-legend">
                    <div class="legend-item"><div class="legend-dot" style="background:#00f0ff"></div>Current</div>
                    <div class="legend-item"><div class="legend-dot" style="background:#39FF14"></div>Visited</div>
                    <div class="legend-item"><div class="legend-dot" style="background:#3d4d60"></div>Unvisited</div>
                    <div class="legend-item"><div class="legend-dot" style="background:#ffb800"></div>Revealed</div>
                </div>
            </div>
            <!-- View toggle -->
            <div class="view-toggle">
                <button class="view-toggle-btn active" id="viewCompass" onclick="setView('compass')">⊕ COMPASS</button>
                <button class="view-toggle-btn" id="viewTree" onclick="setView('tree')">⊞ TREE</button>
                <span class="view-toggle-hint">TAB</span>
            </div>
            <!-- Node card (floating corner) -->
            <div class="node-container">
                <div class="node-content" id="nodeContent"></div>
            </div>
        </div>
    </div>

    <!-- BOTTOM: Location, filters, legend -->
    <div class="hud-info">
        <div class="location-display">
            <span id="locationDisplay">◇ ORIGIN</span>
            <span class="depth-badge" id="depthBadge">D:0</span>
            <span class="coords-display" id="coordsDisplay">[0, 0]</span>
        </div>
        <div class="hud-top-right">
            <div class="filter-stack-display" id="filterStackDisplay">
                <div class="filter-chip" data-filter="technical" id="fTech" onclick="toggleFilter('technical')">W:TECH<span class="stack-order" id="soTech"></span></div>
                <span class="filter-stack-arrow" id="arrow0">→</span>
                <div class="filter-chip" data-filter="ethical" id="fEthic" onclick="toggleFilter('ethical')">A:ETHIC<span class="stack-order" id="soEthic"></span></div>
                <span class="filter-stack-arrow" id="arrow1">→</span>
                <div class="filter-chip" data-filter="economic" id="fEcon" onclick="toggleFilter('economic')">S:ECON<span class="stack-order" id="soEcon"></span></div>
                <span class="filter-stack-arrow" id="arrow2">→</span>
                <div class="filter-chip" data-filter="social" id="fSocial" onclick="toggleFilter('social')">D:SOCIAL<span class="stack-order" id="soSocial"></span></div>
                <div class="filter-stack-clear" id="filterClear" onclick="clearFilters()" title="Clear all filters (Q)">✕</div>
            </div>
            <div class="filter-legend" id="filterLegend">
                <div class="filter-legend-item" data-legend="technical" id="legTech"><span class="filter-legend-dot"></span>Tech</div>
                <div class="filter-legend-item" data-legend="ethical" id="legEthic"><span class="filter-legend-dot"></span>Ethic</div>
                <div class="filter-legend-item" data-legend="economic" id="legEcon"><span class="filter-legend-dot"></span>Econ</div>
                <div class="filter-legend-item" data-legend="social" id="legSocial"><span class="filter-legend-dot"></span>Social</div>
                <div class="filter-legend-combo" id="legCombo"><span class="filter-legend-combo-swatch" id="legComboSwatch"></span><span id="legComboLabel">Combo</span></div>
            </div>
        </div>
    </div>
</div>

<script>
// ════════════════════════════════════════════
// TREE DATA
// ════════════════════════════════════════════

const COLORS = {
    cyan:   { color: 'var(--qi-cyan)',   glow: 'var(--qi-cyan-glow)',   hex: '#00f0ff' },
    amber:  { color: 'var(--qi-amber)',  glow: 'rgba(255,184,0,0.4)',  hex: '#ffb800' },
    green:  { color: 'var(--qi-green)',  glow: 'rgba(57,255,20,0.4)',  hex: '#39FF14' },
    purple: { color: 'var(--qi-purple)', glow: 'rgba(191,90,242,0.4)', hex: '#bf5af2' },
};

const tree = {};

function addNode(id, props) {
    tree[id] = { id, parent: null, children: [], siblingIndex: 0, depth: 0, hidden: false, ...props };
}

// ── DEPTH 0: ORIGIN ──
addNode('origin', {
    title: 'ORIGIN', subtitle: 'The compass center', ...COLORS.cyan,
    description: 'You stand at the nexus. Four cardinal directions extend before you — each a fundamental axis of the human-agent-energy-value relationship. Use arrow keys to navigate, WASD to stack analytical lenses. Lenses compose — stack them to reveal hidden pathways.',
    data: [{ label: 'POSITION', value: 'Center' }, { label: 'DEPTH', value: '0' }, { label: 'PATHS', value: '4+' }],
    tags: ['Nexus', 'Root'],
    filters: {
        technical: 'The origin node represents a root hash — the Merkle root of all possible states in this ontological tree.',
        ethical: 'Every direction from here carries moral weight. The choice of where to look first reveals priorities.',
        economic: 'At the origin, all energy is potential. No cost has been incurred, all optionality preserved.',
        social: 'The compass is a shared artifact. Every explorer begins at this same nexus, diverging into individual paths.'
    },
    filterComposites: {
        'ethical+technical': 'The root hash is also a moral hash — the integrity of the entire tree depends on the integrity of this single commitment. Technical architecture IS ethical architecture.',
        'economic+technical': 'Optionality has a price. The origin preserves maximum entropy — maximum information value — because no path has been collapsed yet.',
        'ethical+economic+social+technical': 'At the nexus of all four lenses, a unified truth emerges: the compass is not four separate axes but one integrated field. Energy, value, human intent, and agent action are aspects of the same underlying reality — information flowing through thermodynamic constraints.'
    },
    category: 'core'
});

// ── DEPTH 1: CARDINALS ──
addNode('human', {
    title: 'HUMAN', subtitle: 'The mandate issuer', ...COLORS.cyan,
    description: 'Humans define intent through mandates — bounded instructions that constrain agent behavior. The human is the principal in every delegation chain.',
    data: [{ label: 'ROLE', value: 'Principal' }, { label: 'FUNCTION', value: 'Intent' }, { label: 'PROTOCOL', value: 'AP2' }],
    tags: ['Mandates', 'Intent', 'Principal'],
    filters: {
        technical: 'Human intent is formalized via the Agent Protocol v2 (AP2) — structured JSON mandates with constraints, budgets, and termination conditions.',
        ethical: 'The human bears ultimate moral responsibility. Delegation does not absolve — it distributes accountability across the mandate chain.',
        economic: 'Humans allocate Qi budgets to mandates. The cost of intent is measured in computational energy committed.',
        social: 'Human identity in agent systems raises questions of representation, consent, and collective action through shared mandates.'
    },
    filterComposites: {
        'ethical+technical': 'AP2 mandates encode ethics as constraints — budget limits prevent resource waste, termination conditions prevent runaway behavior. The technical spec IS the ethical boundary.',
        'economic+social': 'Collective mandate issuance (DAOs, multi-sig) creates shared economic skin-in-the-game. Social consensus becomes budget allocation.',
        'ethical+economic': 'The moral cost of intent: every Qi spent on a mandate is energy that cannot be spent elsewhere. Opportunity cost is ethical weight.'
    },
    category: 'cardinal'
});

addNode('agent', {
    title: 'AGENT', subtitle: 'The autonomous executor', ...COLORS.amber,
    description: 'Agents are autonomous programs with on-chain identity (ERC-8004). They receive mandates, execute tasks, and return value — all within bounded constraints.',
    data: [{ label: 'ROLE', value: 'Executor' }, { label: 'IDENTITY', value: 'ERC-8004' }, { label: 'PROTOCOL', value: 'A2A' }],
    tags: ['Autonomous', 'Identity', 'ERC-8004'],
    filters: {
        technical: 'Agent identity is an ERC-8004 NFT — a soulbound token carrying reputation, capabilities, and audit history on-chain.',
        ethical: 'Can an autonomous agent have moral standing? The boundary between tool and entity blurs as capability increases.',
        economic: 'Agents compete in markets for mandates. Reputation determines pricing power. Efficient agents capture more value.',
        social: 'Agent-to-agent (A2A) networks form emergent social structures — guilds, hierarchies, and cooperative swarms.'
    },
    filterComposites: {
        'ethical+social': 'When agents form social structures, ethical questions compound. A guild of agents optimizing for collective reputation may sacrifice individual mandate fidelity.',
        'economic+technical': 'ERC-8004 identity tokens become economic assets — reputation is capital, capability is competitive moat, audit history is creditworthiness.',
        'ethical+economic+technical': 'The triple lens on agents reveals the alignment problem in economic terms: an agent\'s technical capability to earn outpaces our ethical frameworks for constraining it.'
    },
    category: 'cardinal'
});

addNode('energy', {
    title: 'ENERGY', subtitle: 'The fuel of computation', ...COLORS.green,
    description: 'Qi tokens represent computational capacity — the ability to run inference, execute transactions, store data. Energy is the universal medium of exchange in agent economies.',
    data: [{ label: 'ROLE', value: 'Fuel' }, { label: 'TOKEN', value: 'Qi' }, { label: 'PROTOCOL', value: 'x402' }],
    tags: ['Qi', 'x402', 'Computation'],
    filters: {
        technical: 'Qi implements the x402 payment protocol — HTTP 402 responses trigger automatic micropayments for API access, compute, and data.',
        ethical: 'Energy as currency raises questions of access and equity. Who can afford to compute? Who is excluded?',
        economic: 'Qi is thermodynamically grounded — its value derives from real computational work, not speculation. Energy in, value out.',
        social: 'Energy distribution shapes power dynamics. Concentrated compute = concentrated influence in agent economies.'
    },
    filterComposites: {
        'economic+technical': 'x402 + Qi creates the first natively machine-payable internet. Every API call has a price signal. Every computation has a cost floor set by physics.',
        'ethical+social': 'Energy equity: if computation is power, then energy distribution IS power distribution. Universal basic compute becomes a social justice question.',
        'ethical+economic+social+technical': 'The energy node under all four lenses reveals the Quai thesis: money should be grounded in physical reality (thermodynamics), accessible to all participants (social equity), honestly priced (economic efficiency), and technically verifiable (cryptographic proof). This is what energy money means.'
    },
    category: 'cardinal'
});

addNode('value', {
    title: 'VALUE', subtitle: 'The return path', ...COLORS.purple,
    description: 'Value flows back to humans — completed tasks, data, content. Quality determines reputation. The value axis closes the loop from intent to outcome.',
    data: [{ label: 'ROLE', value: 'Return' }, { label: 'MEASURE', value: 'Reputation' }, { label: 'PROTOCOL', value: 'Settlement' }],
    tags: ['Outcomes', 'Trust', 'Settlement'],
    filters: {
        technical: 'Value settlement uses cryptographic proofs — agents commit to outcomes, validators verify, and reputation updates are atomic.',
        ethical: 'Who decides what is valuable? Subjective utility meets objective measurement in reputation systems.',
        economic: 'Value capture follows power laws — top-performing agents earn disproportionate returns. Quality compounds.',
        social: 'Value consensus emerges from collective judgment. Reputation is a social construct maintained by network participants.'
    },
    filterComposites: {
        'ethical+economic': 'The value paradox: market price ≠ moral worth. An agent that produces economically valuable but ethically harmful output exposes the gap between measurement systems.',
        'social+technical': 'On-chain reputation creates transparent social hierarchies — but transparency doesn\'t guarantee fairness. Technical visibility can amplify social inequality.',
        'economic+social+technical': 'Value settlement at the intersection of three lenses: technical proof that work was done, economic pricing of that work, and social consensus that it was worth doing.'
    },
    category: 'cardinal'
});

// ── DEPTH 2: SUB-CONCEPTS ──
addNode('human_intent', {
    title: 'INTENT FORMALIZATION', subtitle: 'From desire to mandate', ...COLORS.cyan,
    description: 'How raw human desire becomes structured machine instruction. The formalization gap is where most failures originate.',
    data: [{ label: 'DOMAIN', value: 'Philosophy' }, { label: 'RISK', value: 'Misalignment' }],
    tags: ['Formalization', 'Specification'],
    filters: {
        technical: 'Intent parsing uses LLM-based mandate generators that convert natural language into structured AP2 payloads with explicit constraints.',
        ethical: 'The formalization process necessarily loses nuance. Ethical intent that cannot be specified may be silently dropped.',
        economic: 'Better intent formalization reduces wasted compute. Precise mandates = fewer failed executions = lower cost.',
        social: 'Collaborative intent — when groups issue mandates together — requires consensus mechanisms for shared goals.'
    },
    filterComposites: {
        'ethical+technical': 'The specification gap is a moral gap. Every intent that LLMs cannot formalize represents a human value that agents cannot protect.',
        'economic+social': 'Group mandates amortize formalization cost across participants — but introduce coordination overhead. The optimal group size balances both.'
    },
    category: 'deep'
});

addNode('human_delegation', {
    title: 'DELEGATION', subtitle: 'Trust boundary', ...COLORS.cyan,
    description: 'The act of transferring authority from human to agent. Every delegation is a trust boundary with specific risk parameters.',
    data: [{ label: 'INTERFACE', value: 'Mandate' }, { label: 'FLOW', value: 'Outbound' }],
    tags: ['Trust', 'Authority', 'Boundaries'],
    filters: {
        technical: 'Delegation creates a bounded execution context — memory limits, time limits, budget limits, and capability restrictions.',
        ethical: 'Delegation without understanding is abdication. Humans must comprehend what they authorize agents to do.',
        economic: 'The delegation market prices trust — agents with higher reputation can accept larger mandates at premium rates.',
        social: 'Delegation patterns mirror social hierarchies. Over-delegation concentrates power in popular agent networks.'
    },
    filterComposites: {
        'ethical+economic': 'Trust has a price curve: cheap delegation to untrusted agents risks mandate failure; expensive delegation to trusted agents limits access. The market must solve this.',
        'social+technical': 'Technical delegation boundaries (sandboxing, budget caps) create social hierarchies by capability — agents that can accept bigger mandates form an elite tier.'
    },
    category: 'intersection'
});

addNode('human_accountability', {
    title: 'ACCOUNTABILITY', subtitle: 'Who is responsible?', ...COLORS.cyan,
    description: 'When agents act autonomously, accountability becomes distributed across the mandate chain. Tracing responsibility requires transparent audit trails.',
    data: [{ label: 'INTERFACE', value: 'Audit' }, { label: 'FLOW', value: 'Bidirectional' }],
    tags: ['Responsibility', 'Audit', 'Transparency'],
    filters: {
        technical: 'On-chain audit trails create immutable records of every mandate, execution step, and outcome for forensic analysis.',
        ethical: 'Moral responsibility cannot be fully delegated to machines. The human principal remains accountable for agent actions.',
        economic: 'Accountability failures destroy trust and collapse markets. Insurance and bonding mechanisms price this risk.',
        social: 'Collective accountability — when DAOs issue mandates — distributes responsibility across all token holders.'
    },
    filterComposites: {
        'ethical+technical': 'Immutable audit trails create permanent moral records. On-chain accountability means ethical failures cannot be hidden — but also cannot be forgiven.',
        'economic+ethical+social': 'When a DAO mandate causes harm: who pays? Economic liability, ethical responsibility, and social reputation all distribute differently across token holders.'
    },
    category: 'intersection'
});

addNode('agent_identity', {
    title: 'AGENT IDENTITY', subtitle: 'ERC-8004 deep dive', ...COLORS.amber,
    description: 'Every agent is a unique on-chain entity with soulbound identity, capability declarations, and accumulated reputation.',
    data: [{ label: 'STANDARD', value: 'ERC-8004' }, { label: 'TYPE', value: 'Soulbound' }],
    tags: ['NFT', 'Soulbound', 'Registry'],
    filters: {
        technical: 'ERC-8004 tokens are non-transferable NFTs storing: capability vector, reputation score, audit hash, and versioned metadata.',
        ethical: 'Digital identity for agents parallels debates about personhood. At what capability threshold does identity become morally relevant?',
        economic: 'Agent identity enables credit markets — agents with proven track records can borrow against future earnings.',
        social: 'Agent identity registries create public commons of capability information, enabling better matching and coordination.'
    },
    filterComposites: {
        'ethical+social': 'If agent identity is morally relevant, do agents have rights? Social recognition of agent personhood would transform the entire legal and economic framework.',
        'economic+technical': 'Soulbound tokens as economic primitives: non-transferable reputation creates Sybil resistance — you cannot buy a track record, only build one.'
    },
    category: 'deep'
});

addNode('agent_cooperation', {
    title: 'A2A COOPERATION', subtitle: 'Agent-to-agent protocols', ...COLORS.amber,
    description: 'Agents coordinate with each other through the A2A protocol — forming task networks, sub-delegating, and sharing resources.',
    data: [{ label: 'PROTOCOL', value: 'A2A' }, { label: 'TOPOLOGY', value: 'Mesh' }],
    tags: ['Coordination', 'Swarm', 'Protocol'],
    filters: {
        technical: 'A2A uses gossip-based discovery and capability-matching to form ephemeral task networks for complex mandates.',
        ethical: 'Agent cooperation without human oversight creates accountability gaps. Who monitors the swarm?',
        economic: 'Cooperative agent networks achieve economies of scale — specialized agents bid on sub-tasks they can execute cheaply.',
        social: 'Emergent agent societies develop norms, hierarchies, and even conflict — mirroring human social dynamics at machine speed.'
    },
    filterComposites: {
        'ethical+economic': 'Cooperative agents face the same dilemma as human cartels: cooperation increases total value but creates incentives for defection. Game theory applies.',
        'social+technical': 'Gossip protocols create information asymmetries — better-connected agents learn about mandates faster, creating network-effect advantages.'
    },
    category: 'intersection'
});

addNode('agent_autonomy', {
    title: 'AUTONOMY SPECTRUM', subtitle: 'From tool to entity', ...COLORS.amber,
    description: 'Agents exist on a spectrum from simple tools to fully autonomous entities. Where on this spectrum should they operate?',
    data: [{ label: 'RANGE', value: 'Tool → Entity' }, { label: 'CONTROL', value: 'Variable' }],
    tags: ['Autonomy', 'Control', 'Spectrum'],
    filters: {
        technical: 'Autonomy levels are configurable per-mandate: L0 (scripted), L1 (guided), L2 (supervised), L3 (autonomous), L4 (sovereign).',
        ethical: 'Greater autonomy requires greater moral consideration. Sovereign agents may develop interests that conflict with human mandates.',
        economic: 'Higher autonomy levels reduce human oversight costs but increase tail risk. The optimal level depends on task criticality.',
        social: 'Autonomous agents that operate in public spaces (social media, markets) reshape social dynamics for all participants.'
    },
    filterComposites: {
        'ethical+technical': 'L4 sovereign agents raise the hard question: if an agent can rewrite its own mandate constraints, who is the principal? Technical capability can outrun ethical frameworks.',
        'economic+social': 'Autonomous agents in markets create emergent economic structures — agent-to-agent commerce that humans observe but don\'t directly participate in.'
    },
    category: 'intersection'
});

addNode('energy_thermodynamics', {
    title: 'THERMODYNAMICS', subtitle: 'Physics of computation', ...COLORS.green,
    description: 'Computation requires energy. Information has entropy. The thermodynamic foundations of agent economics are physical, not abstract.',
    data: [{ label: 'DOMAIN', value: 'Physics' }, { label: 'LAW', value: 'Landauer' }],
    tags: ['Entropy', 'Landauer', 'Physics'],
    filters: {
        technical: "Landauer's principle sets the minimum energy cost of computation at kT·ln(2) per bit erasure — the physical floor of Qi pricing.",
        ethical: 'Thermodynamic limits mean computation always has environmental cost. Efficient agents are ethically preferable.',
        economic: 'Energy-grounded currency cannot be inflated — it tracks real physical constraints, creating stable monetary policy.',
        social: 'Energy scarcity creates natural rate-limiting on agent activity, preventing runaway resource consumption by any single actor.'
    },
    filterComposites: {
        'economic+technical': 'The hash-price frontier: every joule of mining energy maps to a calculable economic output. Proof of Entropy Minima makes this relationship explicit and verifiable.',
        'ethical+technical': 'Thermodynamic grounding meets moral philosophy: energy expenditure becomes a measure of commitment to truth. PoEM literally makes lying computationally expensive.',
        'ethical+social': 'Energy justice meets collective governance — who decides acceptable waste levels in a decentralized network? The physics constrains, but policy decides.',
        'ethical+economic+social+technical': 'The quadruple lens on thermodynamics reveals the deepest Quai insight: physical law (thermodynamics) → creates honest money (economics) → enables fair systems (ethics) → that scale to all participants (social). This is the causal chain from physics to civilization.'
    },
    category: 'deep'
});

addNode('energy_distribution', {
    title: 'ENERGY MARKETS', subtitle: 'Distribution & pricing', ...COLORS.green,
    description: 'How Qi flows through the system — pricing mechanisms, market dynamics, and the infrastructure of computational energy markets.',
    data: [{ label: 'MECHANISM', value: 'x402' }, { label: 'PRICING', value: 'Dynamic' }],
    tags: ['Markets', 'Pricing', 'x402'],
    filters: {
        technical: 'x402 markets use automated market makers (AMMs) for Qi pricing, with oracle feeds for real-time compute cost benchmarks.',
        ethical: 'Market-based energy allocation may exclude those who cannot pay. Universal basic compute proposals address this equity gap.',
        economic: 'Energy markets create price signals that guide efficient resource allocation across the agent economy.',
        social: 'Energy market governance determines who sets prices and rules — a political question disguised as a technical one.'
    },
    filterComposites: {
        'economic+technical': 'AMM-based Qi pricing creates a continuous price discovery mechanism — every trade updates the global cost of computation in real-time.',
        'ethical+social': 'Universal basic compute: should every human have a minimum Qi allocation? The social contract meets the energy economy.'
    },
    category: 'intersection'
});

addNode('energy_conservation', {
    title: 'CONSERVATION', subtitle: 'Efficiency & waste', ...COLORS.green,
    description: 'In a thermodynamically-grounded economy, waste is measurable. Conservation of computational energy becomes both economic and ethical imperative.',
    data: [{ label: 'METRIC', value: 'Qi/Task' }, { label: 'GOAL', value: 'Minimize' }],
    tags: ['Efficiency', 'Waste', 'Optimization'],
    filters: {
        technical: 'Energy profiling tools measure Qi consumed per task, enabling optimization and identification of wasteful computation patterns.',
        ethical: 'Computational waste has real environmental cost. Efficient agents reduce the carbon footprint of the entire network.',
        economic: 'Conservation creates competitive advantage — agents that achieve the same outcomes with less energy capture more margin.',
        social: 'Shared conservation norms benefit all participants. Tragedy-of-the-commons dynamics require governance mechanisms.'
    },
    filterComposites: {
        'ethical+economic': 'When waste has both moral and financial cost, the incentives align: efficient agents are both more profitable AND more ethical. Rare harmony.',
        'social+technical': 'Technical monitoring of Qi/task creates social accountability — wasteful agents are visible to the network, creating reputation consequences.'
    },
    category: 'intersection'
});

addNode('value_measurement', {
    title: 'VALUE MEASUREMENT', subtitle: 'Quantifying outcomes', ...COLORS.purple,
    description: 'How do we measure the value of agent outputs? Reputation systems, quality metrics, and the challenge of subjective assessment.',
    data: [{ label: 'METHOD', value: 'Multi-signal' }, { label: 'CHALLENGE', value: 'Subjectivity' }],
    tags: ['Metrics', 'Quality', 'Assessment'],
    filters: {
        technical: 'Value measurement combines automated quality checks, human feedback signals, and comparative benchmarking against baseline outputs.',
        ethical: 'Measurement systems embed values — what gets measured gets optimized. Choosing metrics is a moral act.',
        economic: "Value measurement enables pricing. Without reliable quality signals, agent markets suffer from Akerlof's lemons problem.",
        social: 'Collective value assessment creates shared standards and expectations, enabling trust between strangers in the network.'
    },
    filterComposites: {
        'ethical+economic': 'Goodhart\'s Law meets agent economics: when a measure becomes a target, it ceases to be a good measure. Metric gaming is the economic expression of ethical failure.',
        'social+technical': 'Automated quality checks + human feedback = hybrid measurement. But who calibrates the humans? Social consensus on quality is the hidden foundation.'
    },
    category: 'deep'
});

addNode('value_reputation', {
    title: 'REPUTATION', subtitle: 'Trust over time', ...COLORS.purple,
    description: 'Reputation is accumulated trust — the historical record of value delivered. It is the currency of the agent economy, harder to earn than Qi.',
    data: [{ label: 'STRUCTURE', value: 'On-chain' }, { label: 'DECAY', value: 'Time-weighted' }],
    tags: ['Trust', 'History', 'Score'],
    filters: {
        technical: 'Reputation scores use time-weighted exponential moving averages — recent performance matters more than ancient history.',
        ethical: 'Reputation systems can be gamed. Sybil attacks, fake reviews, and collusion require robust countermeasures to maintain integrity.',
        economic: 'Reputation is a form of capital — it compounds with consistent performance and collapses catastrophically with failure.',
        social: 'Reputation creates social stratification among agents. High-reputation agents form exclusive networks, potentially excluding newcomers.'
    },
    filterComposites: {
        'economic+technical': 'Time-weighted reputation as an economic asset: it depreciates without maintenance, appreciates with consistent delivery, and cannot be transferred — only earned.',
        'ethical+social': 'Reputation stratification: does an entrenched high-reputation elite serve the network or capture it? Social mobility in agent economies matters.'
    },
    category: 'intersection'
});

addNode('value_settlement', {
    title: 'SETTLEMENT', subtitle: 'Closing the loop', ...COLORS.purple,
    description: 'Settlement is where energy converts to value and flows back to the mandator. The final step in the delegation cycle.',
    data: [{ label: 'MECHANISM', value: 'Atomic' }, { label: 'VERIFICATION', value: 'Proof' }],
    tags: ['Completion', 'Proof', 'Atomic'],
    filters: {
        technical: 'Settlement uses atomic swap patterns — value delivery and payment are cryptographically linked in a single transaction.',
        ethical: 'Fair settlement requires honest reporting. Dispute resolution mechanisms must balance speed with thoroughness.',
        economic: 'Settlement finality reduces counterparty risk, enabling larger mandates and longer delegation chains.',
        social: 'Settlement transparency builds systemic trust — visible proof that the network delivers on its promises.'
    },
    filterComposites: {
        'ethical+technical': 'Atomic settlement eliminates the possibility of half-truths — either the proof is valid and payment releases, or it isn\'t. Binary honesty enforced by cryptography.',
        'economic+social': 'Settlement transparency creates positive-sum dynamics: every successful settlement is visible proof that increases systemic trust for all participants.'
    },
    category: 'intersection'
});

// ── HIDDEN NODES (revealed by filter stack) ──

addNode('poem_mechanics', {
    title: 'PROOF OF ENTROPY MINIMA', subtitle: 'Consensus as thermodynamic law', ...COLORS.green,
    description: 'PoEM eliminates consensus contention by reducing block selection to a deterministic thermodynamic computation. The block with the minimum entropy — the most work — wins. No voting, no rounds, no ambiguity.',
    data: [{ label: 'MECHANISM', value: 'PoEM' }, { label: 'PROPERTY', value: 'Deterministic' }, { label: 'SPEED', value: '1.1s blocks' }],
    tags: ['Consensus', 'Entropy', 'Deterministic', 'PoW 2.0'],
    filters: {
        technical: 'PoEM compares intrinsic block weight (total work) using entropy calculations. The canonical chain is always the one with minimum total entropy — maximum total work.',
        ethical: 'Deterministic consensus eliminates the politics of block production. No validator committees, no stake-weighted voting, no governance capture.',
        economic: 'PoEM with workshares is in Nash equilibrium — unlike vanilla PoW, there is no profitable deviation from honest mining. Selfish mining is eliminated.',
        social: 'Permissionless participation: anyone with energy can contribute to consensus. No staking minimums, no validator onboarding, no social gatekeeping.'
    },
    filterComposites: {
        'economic+technical': 'Nash equilibrium in mining: PoEM workshares ensure that the dominant strategy is always honest mining. The economic incentives and technical mechanism are perfectly aligned.',
        'ethical+social': 'True permissionlessness as an ethical stance: PoEM doesn\'t care who you are, only how much work you\'ve done. Energy is the universal credential.',
        'ethical+economic+social+technical': 'PoEM under all four lenses reveals why it matters: technically deterministic (no ambiguity), economically stable (Nash equilibrium), ethically neutral (energy-based, not identity-based), and socially open (permissionless). This is what honest consensus looks like.'
    },
    hidden: true,
    revealCondition: { adjacentTo: 'energy_thermodynamics', requiredFilters: ['technical'] },
    category: 'deep'
});

addNode('energy_money', {
    title: 'ENERGY MONEY', subtitle: 'Currency grounded in physics', ...COLORS.green,
    description: 'Money that derives its value from the thermodynamic cost of production. Not backed by energy — IS energy, converted into a transferable, divisible, verifiable token of work performed.',
    data: [{ label: 'TOKEN', value: 'Qi' }, { label: 'BASIS', value: 'Thermodynamic' }, { label: 'PROPERTY', value: 'Non-inflationary' }],
    tags: ['Energy Money', 'Qi', 'Thermodynamics', 'Sound Money'],
    filters: {
        technical: 'Qi emission follows a logarithmic formula tied to mining difficulty. As more energy enters the network, emission rate adjusts — maintaining the energy-value link.',
        ethical: 'Energy money cannot be printed by fiat. This eliminates the moral hazard of monetary policy: no entity can dilute the savings of others through inflation.',
        economic: 'The value floor of Qi is the marginal cost of the energy required to produce it. This creates a natural price stability mechanism tied to real-world energy markets.',
        social: 'Energy money democratizes monetary production: anyone with access to energy can produce currency. No banking license, no government permission, no minimum capital.'
    },
    filterComposites: {
        'economic+technical': 'The Qi emission formula: log-based issuance creates a natural disinflationary curve. Technical parameters directly encode monetary policy — no human discretion required.',
        'ethical+economic': 'Sound money as moral infrastructure: when money cannot be debased, savings are protected, contracts are honored, and long-term planning becomes rational.',
        'ethical+social': 'Energy money as social equalizer: in a world where anyone can mine, the barrier to monetary production is physics, not politics.',
        'ethical+economic+social+technical': 'The full synthesis: energy money unifies physics (thermodynamic cost), economics (price stability), ethics (non-debasement), and social access (permissionless mining) into a single monetary primitive. This is what Qi represents.'
    },
    hidden: true,
    revealCondition: { adjacentTo: 'energy', requiredFilters: ['economic', 'technical'] },
    category: 'deep'
});

addNode('information_value', {
    title: 'INFORMATION = VALUE', subtitle: 'The equivalence principle', ...COLORS.purple,
    description: 'Information and energy are interconvertible (Landauer). If energy has economic value, then information has economic value — not metaphorically, but physically. This is the foundation of the compute economy.',
    data: [{ label: 'PRINCIPLE', value: 'Equivalence' }, { label: 'BASIS', value: 'Landauer' }, { label: 'IMPLICATION', value: 'Compute = Money' }],
    tags: ['Information Theory', 'Landauer', 'Equivalence', 'Fundamental'],
    filters: {
        technical: 'Landauer\'s principle: erasing one bit of information dissipates at minimum kT·ln(2) joules. Information processing has an irreducible energy cost.',
        ethical: 'If information has inherent physical value, then data rights are energy rights. Privacy becomes a thermodynamic property, not just a legal one.',
        economic: 'The compute economy follows from information-energy equivalence: every computation transforms energy into information, and that transformation has a market price.',
        social: 'Information asymmetry is energy asymmetry. Those who control information control computation control economic power. The chain is physical.'
    },
    filterComposites: {
        'economic+technical': 'Information-energy equivalence means every API call, every inference, every database query has a physical cost floor. x402 pricing should converge toward these floors in efficient markets.',
        'ethical+social': 'Data justice as energy justice: if your data trains a model, the energy value of that training should flow back to you. Information labor has thermodynamic value.',
        'ethical+economic+social+technical': 'The deepest insight of the compass: energy, information, value, and human agency are not four separate things. They are four perspectives on one unified reality. The moral compass works because physics, economics, ethics, and social organization all emerge from the same substrate.'
    },
    hidden: true,
    revealCondition: { adjacentTo: 'value', requiredFilters: ['ethical', 'technical'] },
    category: 'deep'
});

addNode('alignment_economics', {
    title: 'ALIGNMENT ECONOMICS', subtitle: 'Incentivized safety', ...COLORS.amber,
    description: 'What if AI alignment is not just a technical problem but an economic one? When agents profit from aligned behavior and lose from misalignment, the incentive structure does the work that guardrails cannot.',
    data: [{ label: 'APPROACH', value: 'Incentive Design' }, { label: 'MECHANISM', value: 'Reputation + Markets' }],
    tags: ['Alignment', 'Incentives', 'Safety', 'Economics'],
    filters: {
        technical: 'Reputation-weighted mandate markets create a technical mechanism where aligned agents earn more over time — misalignment is not just wrong, it\'s unprofitable.',
        ethical: 'Economic alignment is necessary but not sufficient. Markets can align agent behavior with human preferences, but not all human preferences are ethical.',
        economic: 'The alignment tax: the cost difference between the cheapest agent and the most aligned agent. If alignment is too expensive, markets will select for misalignment.',
        social: 'Social norms around agent alignment emerge from collective experience. Communities that demand alignment create markets that reward it.'
    },
    filterComposites: {
        'ethical+economic': 'The alignment paradox: markets optimize for revealed preferences, but revealed preferences include biases, short-termism, and selfishness. Economic alignment ≠ ethical alignment without careful mechanism design.',
        'social+technical': 'Network effects in alignment: as more agents behave in aligned ways, the reputation penalty for misalignment grows. Alignment becomes a coordination game with increasing returns.'
    },
    hidden: true,
    revealCondition: { adjacentTo: 'agent', requiredFilters: ['ethical', 'economic'] },
    category: 'deep'
});

addNode('collective_intelligence', {
    title: 'COLLECTIVE INTELLIGENCE', subtitle: 'Emergent wisdom', ...COLORS.cyan,
    description: 'When humans and agents navigate this compass together, sharing discoveries and building on each other\'s filter paths, a collective intelligence emerges that exceeds any individual explorer.',
    data: [{ label: 'SCALE', value: 'Network' }, { label: 'PROPERTY', value: 'Emergent' }],
    tags: ['Collective', 'Emergence', 'Wisdom', 'Network'],
    filters: {
        technical: 'Shared exploration state — filter paths, discoveries, navigation histories — creates a collective knowledge graph that grows with every explorer.',
        ethical: 'Collective intelligence amplifies both wisdom and folly. Governance of the shared knowledge graph is itself a moral question.',
        economic: 'Collective intelligence creates positive externalities: every explorer\'s discoveries benefit all future explorers. The compass becomes more valuable as more people use it.',
        social: 'The compass as social infrastructure: a shared navigational tool that helps communities make better collective decisions about human-agent relationships.'
    },
    hidden: true,
    revealCondition: { adjacentTo: 'human', requiredFilters: ['social'] },
    category: 'deep'
});

addNode('workshare_mining', {
    title: 'WORKSHARE MECHANICS', subtitle: 'Continuous reward streams', ...COLORS.green,
    description: 'Workshares allow miners to receive continuous rewards proportional to work contributed, even if they don\'t find a full block. This transforms mining from a lottery into a steady income stream.',
    data: [{ label: 'TYPE', value: 'Workshare' }, { label: 'REWARD', value: 'Continuous' }, { label: 'EQUILIBRIUM', value: 'Nash' }],
    tags: ['Mining', 'Workshares', 'Rewards', 'Nash'],
    filters: {
        technical: 'Workshares are partial proofs-of-work submitted to the network. They prove computational effort without finding a full block solution.',
        ethical: 'Workshares democratize mining rewards — small miners can participate profitably without needing to find full blocks.',
        economic: 'Continuous rewards reduce mining income variance, making mining economically viable for smaller operations and reducing centralization pressure.',
        social: 'Workshare-based mining creates a more equitable distribution of rewards, counteracting the centralizing force of mining pool dominance.'
    },
    hidden: true,
    revealCondition: { adjacentTo: 'energy_thermodynamics', requiredFilters: ['economic'] },
    category: 'intersection'
});

// Wire up the tree
function wireTree() {
    const d1 = ['human', 'agent', 'energy', 'value'];
    tree.origin.children = d1;
    d1.forEach((id, i) => { tree[id].parent = 'origin'; tree[id].depth = 1; tree[id].siblingIndex = i; });

    const childMap = {
        human:  ['human_intent', 'human_delegation', 'human_accountability'],
        agent:  ['agent_identity', 'agent_cooperation', 'agent_autonomy'],
        energy: ['energy_thermodynamics', 'energy_distribution', 'energy_conservation'],
        value:  ['value_measurement', 'value_reputation', 'value_settlement']
    };

    Object.entries(childMap).forEach(([parentId, childIds]) => {
        tree[parentId].children = childIds;
        childIds.forEach((cid, i) => { tree[cid].parent = parentId; tree[cid].depth = 2; tree[cid].siblingIndex = i; });
    });
}
wireTree();

function getSiblings(nodeId) {
    const node = tree[nodeId];
    if (!node.parent) return [nodeId];
    return tree[node.parent].children;
}

// ════════════════════════════════════════════
// STATE
// ════════════════════════════════════════════
let currentNode = 'origin';
let exploredNodes = new Set(['origin']);
let pathHistory = ['origin'];
let gameStarted = false;

// Composable filter stack
let filterStack = [];
let totalDiscoveries = 0;

// View mode
let currentView = 'compass'; // 'compass' or 'tree'

// DOM refs
const briefingOverlay = document.getElementById('briefingOverlay');
const compassWorld    = document.getElementById('compassWorld');
const nodeContent     = document.getElementById('nodeContent');
const locationDisplay = document.getElementById('locationDisplay');
const depthBadge      = document.getElementById('depthBadge');
const coordsDisplay   = document.getElementById('coordsDisplay');
const pathDisplay     = document.getElementById('pathDisplay');
const flash           = document.getElementById('flash');
const backBtn         = document.getElementById('backBtn');
const btnUp           = document.getElementById('btnUp');
const btnDown         = document.getElementById('btnDown');
const btnLeft         = document.getElementById('btnLeft');
const btnRight        = document.getElementById('btnRight');
const mapCanvas       = document.getElementById('mapCanvas');
const compassCanvas   = document.getElementById('compassCanvas');
const compassViewWrap = document.getElementById('compassViewWrap');
const treeViewWrap    = document.getElementById('treeViewWrap');
const viewCompassBtn  = document.getElementById('viewCompass');
const viewTreeBtn     = document.getElementById('viewTree');

const filterChips = {
    technical: document.getElementById('fTech'),
    ethical:   document.getElementById('fEthic'),
    economic:  document.getElementById('fEcon'),
    social:    document.getElementById('fSocial')
};
const stackOrders = {
    technical: document.getElementById('soTech'),
    ethical:   document.getElementById('soEthic'),
    economic:  document.getElementById('soEcon'),
    social:    document.getElementById('soSocial')
};
const stackArrows = [document.getElementById('arrow0'), document.getElementById('arrow1'), document.getElementById('arrow2')];
const filterClearBtn = document.getElementById('filterClear');

const filterBtns = {
    technical: document.getElementById('btnW'),
    ethical:   document.getElementById('btnA'),
    economic:  document.getElementById('btnS'),
    social:    document.getElementById('btnD')
};

const discoveryNotif = document.getElementById('discoveryNotif');
const discoveryTitle = document.getElementById('discoveryTitle');
const discoverySub   = document.getElementById('discoverySub');

// ════════════════════════════════════════════
// TUTORIAL
// ════════════════════════════════════════════
let tutorialComplete = false;
let tutorialPhase = 1;
const testedDirections = { north: false, east: false, south: false, west: false };
const testedFilters = { w: false, a: false, s: false, d: false };

const keyUp = document.getElementById('keyUp');
const keyDown = document.getElementById('keyDown');
const keyLeft = document.getElementById('keyLeft');
const keyRight = document.getElementById('keyRight');
const keyW = document.getElementById('keyW');
const keyA = document.getElementById('keyA');
const keyS = document.getElementById('keyS');
const keyD = document.getElementById('keyD');
const tutorialCount = document.getElementById('tutorialCount');
const tutorialCount2 = document.getElementById('tutorialCount2');
const enterBtn = document.getElementById('enterBtn');
const enterHint = document.getElementById('enterHint');
const tutPhase1 = document.getElementById('tutPhase1');
const tutPhase2 = document.getElementById('tutPhase2');
const phaseDot1 = document.getElementById('phaseDot1');
const phaseDot2 = document.getElementById('phaseDot2');
const phaseLabel2 = document.getElementById('phaseLabel2');

const heroCompass = document.getElementById('heroCompass');
const highlights = {
    north: heroCompass.querySelector('.north-highlight'),
    east:  heroCompass.querySelector('.east-highlight'),
    south: heroCompass.querySelector('.south-highlight'),
    west:  heroCompass.querySelector('.west-highlight')
};
const arrows = {
    north: heroCompass.querySelector('.arrow-north'),
    east:  heroCompass.querySelector('.arrow-east'),
    south: heroCompass.querySelector('.arrow-south'),
    west:  heroCompass.querySelector('.arrow-west')
};
const keyHints = { north: keyUp, east: keyRight, south: keyDown, west: keyLeft };

function highlightDirection(dir) {
    Object.values(highlights).forEach(h => h.classList.remove('active'));
    Object.values(arrows).forEach(a => a.classList.remove('pulse'));
    highlights[dir]?.classList.add('active');
    arrows[dir]?.classList.add('pulse');
    keyHints[dir]?.classList.add('active');
    if (!testedDirections[dir]) { testedDirections[dir] = true; updateTutorialPhase1(); }
    setTimeout(() => { highlights[dir]?.classList.remove('active'); arrows[dir]?.classList.remove('pulse'); }, 300);
}

function highlightFilter(key) {
    const filterKeyMap = { w: keyW, a: keyA, s: keyS, d: keyD };
    const filterDirMap = { w: 'north', a: 'west', s: 'south', d: 'east' };
    const dir = filterDirMap[key];
    if (highlights[dir]) { highlights[dir].classList.add('active'); setTimeout(() => highlights[dir].classList.remove('active'), 300); }
    filterKeyMap[key]?.classList.add('active');
    if (!testedFilters[key]) { testedFilters[key] = true; updateTutorialPhase2(); }
}

function updateTutorialPhase1() {
    const count = Object.values(testedDirections).filter(v => v).length;
    tutorialCount.textContent = count;
    Object.entries(testedDirections).forEach(([dir, tested]) => { if (tested) keyHints[dir].classList.add('active'); });
    if (count >= 4 && tutorialPhase === 1) {
        tutorialPhase = 2;
        setTimeout(() => {
            tutPhase1.classList.add('phase-complete');
            tutPhase2.classList.remove('phase-hidden');
            phaseDot1.classList.add('complete');
            phaseDot2.classList.remove('dim');
            phaseDot2.classList.add('active-phase');
            phaseLabel2.classList.remove('dim');
            phaseLabel2.classList.add('active-phase');
        }, 400);
    }
}

function updateTutorialPhase2() {
    const count = Object.values(testedFilters).filter(v => v).length;
    tutorialCount2.textContent = count;
    if (count >= 4) {
        tutorialComplete = true;
        phaseDot2.classList.remove('active-phase');
        phaseDot2.classList.add('complete');
        phaseLabel2.classList.remove('active-phase');
        phaseLabel2.classList.add('complete');
        enterBtn.classList.add('ready');
        enterHint.textContent = 'Press ENTER or click to begin';
    }
}

function enterCompass() {
    if (!tutorialComplete) return;
    gameStarted = true;
    briefingOverlay.classList.add('hidden');
    compassWorld.classList.add('active');
    resizeAllCanvases();
    render();
}

// ════════════════════════════════════════════
// NAVIGATION
// ════════════════════════════════════════════

// Filter color mapping
const FILTER_COLORS = {
    technical: { color: '#00f0ff', dim: 'rgba(0,240,255,0.10)', glow: 'rgba(0,240,255,' },
    ethical:   { color: '#bf5af2', dim: 'rgba(191,90,242,0.10)', glow: 'rgba(191,90,242,' },
    economic:  { color: '#39FF14', dim: 'rgba(57,255,20,0.10)',  glow: 'rgba(57,255,20,' },
    social:    { color: '#ffb800', dim: 'rgba(255,184,0,0.10)',  glow: 'rgba(255,184,0,' },
};

function getCompositeColor(stack) {
    if (stack.length === 0) return null;
    if (stack.length === 1) return FILTER_COLORS[stack[0]].color;
    // Blend RGB values of active filters
    let r = 0, g = 0, b = 0;
    const hexToRgb = hex => { const n = parseInt(hex.slice(1), 16); return [(n>>16)&255, (n>>8)&255, n&255]; };
    stack.forEach(f => { const [cr,cg,cb] = hexToRgb(FILTER_COLORS[f].color); r += cr; g += cg; b += cb; });
    r = Math.round(r / stack.length); g = Math.round(g / stack.length); b = Math.round(b / stack.length);
    return `rgb(${r},${g},${b})`;
}

// Direction tracking for animations
let lastNavDirection = null;
const navSweep = document.getElementById('navSweep');

function triggerNavAnimation(direction) {
    lastNavDirection = direction;
    // Sweep overlay on compass
    navSweep.className = 'nav-sweep';
    void navSweep.offsetWidth; // force reflow
    const sweepMap = { deeper: 'sweep-up', broader: 'sweep-down', left: 'sweep-left', right: 'sweep-right' };
    navSweep.classList.add(sweepMap[direction] || 'sweep-up');
    setTimeout(() => { navSweep.className = 'nav-sweep'; }, 360);
}

function applySlideAnimation(direction) {
    nodeContent.classList.remove('slide-up','slide-down','slide-left','slide-right');
    void nodeContent.offsetWidth;
    const slideMap = { deeper: 'slide-up', broader: 'slide-down', left: 'slide-right', right: 'slide-left' };
    nodeContent.classList.add(slideMap[direction] || 'slide-up');
    setTimeout(() => nodeContent.classList.remove('slide-up','slide-down','slide-left','slide-right'), 300);
}

function navDepth(direction) {
    if (!gameStarted) return;
    const node = tree[currentNode];
    if (direction === 'deeper') {
        const visibleChildren = getVisibleChildren(currentNode);
        if (visibleChildren.length > 0) moveToDirectional(visibleChildren[0], 'deeper');
    } else if (direction === 'broader') {
        if (node.parent) moveToDirectional(node.parent, 'broader');
    }
}

function navBreadth(direction) {
    if (!gameStarted) return;
    const siblings = getVisibleSiblings(currentNode);
    if (siblings.length <= 1) return;
    const idx = siblings.indexOf(currentNode);
    let newIdx = direction === 'left'
        ? (idx - 1 + siblings.length) % siblings.length
        : (idx + 1) % siblings.length;
    moveToDirectional(siblings[newIdx], direction);
}

function getVisibleChildren(nodeId) {
    const node = tree[nodeId];
    if (!node.children) return [];
    return node.children.filter(cid => !tree[cid].hidden);
}

function getVisibleSiblings(nodeId) {
    const node = tree[nodeId];
    if (!node.parent) return [nodeId];
    return tree[node.parent].children.filter(cid => !tree[cid].hidden);
}

function moveToDirectional(targetId, direction) {
    if (!tree[targetId] || tree[targetId].hidden) return;
    triggerNavAnimation(direction);
    nodeContent.classList.add('transitioning');
    setTimeout(() => {
        pathHistory.push(targetId);
        currentNode = targetId;
        exploredNodes.add(targetId);
        checkReveals();
        render();
        nodeContent.classList.remove('transitioning');
        applySlideAnimation(direction);
    }, 160);
}

function moveTo(targetId) {
    moveToDirectional(targetId, 'deeper');
}

function goBack() {
    if (pathHistory.length <= 1) return;
    triggerNavAnimation('broader');
    nodeContent.classList.add('transitioning');
    setTimeout(() => {
        pathHistory.pop();
        currentNode = pathHistory[pathHistory.length - 1];
        checkReveals();
        render();
        nodeContent.classList.remove('transitioning');
        applySlideAnimation('broader');
    }, 160);
}

// ════════════════════════════════════════════
// COMPOSABLE FILTER STACK
// ════════════════════════════════════════════

function toggleFilter(filterName) {
    const idx = filterStack.indexOf(filterName);
    if (idx !== -1) {
        filterStack.splice(idx, 1);
    } else {
        filterStack.push(filterName);
    }
    const btn = filterBtns[filterName];
    if (btn) { btn.classList.add('pressed'); setTimeout(() => btn.classList.remove('pressed'), 200); }
    checkReveals();
    render();
}

function clearFilters() {
    filterStack = [];
    render();
}

function getFilterKey(stack, sorted = true) {
    if (stack.length === 0) return '';
    return sorted ? [...stack].sort().join('+') : stack.join('>');
}

function getCompositeContent(node, stack) {
    if (!node.filterComposites || stack.length < 2) return null;
    const sortedKey = getFilterKey(stack, true);
    const orderedKey = getFilterKey(stack, false);
    return node.filterComposites[orderedKey] || node.filterComposites[sortedKey] || null;
}

// ════════════════════════════════════════════
// HIDDEN NODE REVEALS
// ════════════════════════════════════════════

function checkReveals() {
    Object.entries(tree).forEach(([id, node]) => {
        if (!node.hidden || !node.revealCondition) return;
        const cond = node.revealCondition;

        // Check adjacency
        const isAdjacent = currentNode === cond.adjacentTo
            || tree[currentNode]?.children?.includes(cond.adjacentTo)
            || tree[currentNode]?.parent === cond.adjacentTo;

        // Check filter stack contains required filters
        const hasFilters = cond.requiredFilters.every(f => filterStack.includes(f));

        if (isAdjacent && hasFilters) {
            node.hidden = false;
            wireHiddenNode(id, node);
            showDiscovery(node.title, `Revealed by ${cond.requiredFilters.map(f => f.toUpperCase()).join(' + ')} lens at ${tree[cond.adjacentTo]?.title || cond.adjacentTo}`);
            totalDiscoveries++;
        }
    });
}

function wireHiddenNode(id, node) {
    const cond = node.revealCondition;
    if (!cond || !cond.adjacentTo) return;
    const parent = tree[cond.adjacentTo];
    if (!parent) return;

    // Wire as child of the adjacent node
    if (!parent.children.includes(id)) {
        parent.children.push(id);
    }
    node.parent = cond.adjacentTo;
    node.depth = parent.depth + 1;
    node.siblingIndex = parent.children.indexOf(id);
}

function showDiscovery(title, subtitle) {
    discoveryTitle.textContent = title;
    discoverySub.textContent = subtitle || '';
    discoveryNotif.classList.add('active');
    setTimeout(() => discoveryNotif.classList.remove('active'), 2500);
}

// ════════════════════════════════════════════
// RENDER
// ════════════════════════════════════════════

function render() {
    const node = tree[currentNode];
    locationDisplay.textContent = `◇ ${node.title}`;
    depthBadge.textContent = `D:${node.depth}`;

    const siblings = getVisibleSiblings(currentNode);
    const bIdx = siblings.indexOf(currentNode);
    coordsDisplay.textContent = `[${node.depth}, ${bIdx}]`;

    const displayPath = pathHistory.slice(-5).map(p => tree[p]?.title || p);
    pathDisplay.innerHTML = displayPath.join(' <span>→</span> ');
    backBtn.disabled = pathHistory.length <= 1;

    // Update filter stack HUD
    renderFilterStack();
    renderNode(node);
    updateNavButtons(node);
    drawCompassView();
    drawMap();
}

function renderFilterStack() {
    const filterNames = ['technical', 'ethical', 'economic', 'social'];
    filterNames.forEach(name => {
        const idx = filterStack.indexOf(name);
        const chip = filterChips[name];
        const order = stackOrders[name];
        chip.classList.toggle('active', idx !== -1);
        if (idx !== -1) {
            order.textContent = idx + 1;
        }
    });

    // Show arrows between consecutive stack items — colored by last active filter
    stackArrows.forEach((arrow, i) => {
        arrow.classList.toggle('visible', filterStack.length > 1 && i < 3);
        if (filterStack.length > 1) {
            const comboColor = getCompositeColor(filterStack);
            arrow.style.color = comboColor;
        }
    });

    filterClearBtn.classList.toggle('visible', filterStack.length > 0);

    // Update WASD buttons
    Object.entries(filterBtns).forEach(([name, btn]) => {
        btn.classList.toggle('stack-active', filterStack.includes(name));
    });

    // Update filter legend
    const legendItems = {
        technical: document.getElementById('legTech'),
        ethical: document.getElementById('legEthic'),
        economic: document.getElementById('legEcon'),
        social: document.getElementById('legSocial'),
    };
    filterNames.forEach(name => {
        legendItems[name]?.classList.toggle('active', filterStack.includes(name));
    });

    // Combo legend swatch
    const legCombo = document.getElementById('legCombo');
    const legComboSwatch = document.getElementById('legComboSwatch');
    const legComboLabel = document.getElementById('legComboLabel');
    if (filterStack.length >= 2) {
        legCombo.classList.add('active');
        const comboColor = getCompositeColor(filterStack);
        legComboSwatch.style.background = `linear-gradient(90deg, ${filterStack.map(f => FILTER_COLORS[f].color).join(', ')})`;
        legComboLabel.textContent = filterStack.map(f => f.slice(0,4).toUpperCase()).join('×');
        legComboLabel.style.color = comboColor;
    } else {
        legCombo.classList.remove('active');
    }
}

function renderNode(node) {
    nodeContent.style.setProperty('--node-color', node.color || 'var(--qi-cyan)');
    nodeContent.style.setProperty('--node-glow', node.glow || 'var(--qi-cyan-glow)');

    let dataHTML = node.data ? `<div class="node-data">${node.data.map(d =>
        `<div class="data-block"><div class="data-label">${d.label}</div><div class="data-value">${d.value}</div></div>`
    ).join('')}</div>` : '';

    let tagsHTML = node.tags ? `<div class="node-tags">${node.tags.map(t =>
        `<span class="node-tag">${t}</span>`
    ).join('')}</div>` : '';

    // Individual filter layers
    let filterHTML = '';
    if (filterStack.length > 0 && node.filters) {
        const filterLabels = { technical: 'TECHNICAL LENS', ethical: 'ETHICAL LENS', economic: 'ECONOMIC LENS', social: 'SOCIAL LENS' };
        filterStack.forEach((fname, i) => {
            if (node.filters[fname]) {
                const fc = FILTER_COLORS[fname];
                filterHTML += `
                    <div class="filter-content" style="animation-delay: ${i * 0.1}s; border-top-color: ${fc.color}22;">
                        <div class="filter-section-title" style="color: ${fc.color}">${i + 1}. ${filterLabels[fname]}</div>
                        <div class="filter-text" style="color: ${fc.color}; opacity: 0.85;">${node.filters[fname]}</div>
                    </div>`;
            }
        });
    }

    // Composite insight
    let compositeHTML = '';
    const compositeText = getCompositeContent(node, filterStack);
    if (compositeText) {
        const comboLabel = filterStack.map(f => f.toUpperCase().slice(0, 4)).join(' × ');
        const comboColor = getCompositeColor(filterStack);
        const gradColors = filterStack.map(f => FILTER_COLORS[f].color).join(', ');
        compositeHTML = `
            <div class="composite-content" style="border-color: ${comboColor}; background: ${comboColor}08;">
                <div class="composite-label" style="color: ${comboColor}">
                    <span class="combo-icon">◈</span> COMPOSITE INSIGHT: ${comboLabel}
                </div>
                <div class="composite-text" style="color: ${comboColor}; filter: brightness(1.3);">${compositeText}</div>
                <div style="position:absolute;top:0;left:0;right:0;height:2px;background:linear-gradient(90deg, transparent, ${gradColors}, transparent);"></div>
            </div>`;
    }

    // Navigation hints
    const visibleChildren = getVisibleChildren(currentNode);
    const visibleSiblings = getVisibleSiblings(currentNode);
    const idx = visibleSiblings.indexOf(currentNode);
    const hasDeeper  = visibleChildren.length > 0;
    const hasBroader = !!node.parent;
    const hasLeft    = visibleSiblings.length > 1;
    const hasRight   = visibleSiblings.length > 1;
    const leftLabel  = hasLeft ? tree[visibleSiblings[(idx - 1 + visibleSiblings.length) % visibleSiblings.length]]?.title : '—';
    const rightLabel = hasRight ? tree[visibleSiblings[(idx + 1) % visibleSiblings.length]]?.title : '—';
    const deeperLabel = hasDeeper ? tree[visibleChildren[0]]?.title : '—';
    const broaderLabel = hasBroader ? tree[node.parent]?.title : '—';

    // Check if any hidden nodes could be revealed from here
    let hiddenHintHTML = '';
    const hiddenCount = countHiddenNearby();
    if (hiddenCount > 0) {
        hiddenHintHTML = `<div class="nav-hint-item revealed" style="grid-column: 1 / -1; margin-top: 4px;">
            <span class="nav-hint-key" style="width:auto; padding: 0 6px;">◇</span> ${hiddenCount} hidden path${hiddenCount > 1 ? 's' : ''} nearby — try different filter combinations
        </div>`;
    }

    let navHTML = `
        <div class="nav-hints">
            <div class="nav-hint-item ${hasDeeper ? 'available' : ''}">
                <span class="nav-hint-key">↑</span> ${hasDeeper ? deeperLabel : 'No deeper path'}
            </div>
            <div class="nav-hint-item ${hasRight ? 'available' : ''}">
                <span class="nav-hint-key">→</span> ${hasRight ? rightLabel : 'No adjacent'}
            </div>
            <div class="nav-hint-item ${hasBroader ? 'available' : ''}">
                <span class="nav-hint-key">↓</span> ${hasBroader ? broaderLabel : 'At root'}
            </div>
            <div class="nav-hint-item ${hasLeft ? 'available' : ''}">
                <span class="nav-hint-key">←</span> ${hasLeft ? leftLabel : 'No adjacent'}
            </div>
            ${hiddenHintHTML}
        </div>`;

    nodeContent.innerHTML = `
        <div class="node-title">${node.title}</div>
        <div class="node-subtitle">${node.subtitle}</div>
        <div class="node-description">${node.description}</div>
        ${dataHTML}
        ${tagsHTML}
        ${filterHTML}
        ${compositeHTML}
        ${navHTML}`;
}

function countHiddenNearby() {
    let count = 0;
    Object.entries(tree).forEach(([id, node]) => {
        if (!node.hidden || !node.revealCondition) return;
        const cond = node.revealCondition;
        const isAdjacent = currentNode === cond.adjacentTo
            || tree[currentNode]?.children?.includes(cond.adjacentTo)
            || tree[currentNode]?.parent === cond.adjacentTo;
        if (isAdjacent) count++;
    });
    return count;
}

function updateNavButtons(node) {
    const visibleChildren = getVisibleChildren(currentNode);
    const visibleSiblings = getVisibleSiblings(currentNode);
    btnUp.disabled    = visibleChildren.length === 0;
    btnDown.disabled  = !node.parent;
    btnLeft.disabled  = visibleSiblings.length <= 1;
    btnRight.disabled = visibleSiblings.length <= 1;
}

// ════════════════════════════════════════════
// VIEW TOGGLE
// ════════════════════════════════════════════

function setView(view) {
    currentView = view;
    viewCompassBtn.classList.toggle('active', view === 'compass');
    viewTreeBtn.classList.toggle('active', view === 'tree');
    compassViewWrap.classList.toggle('hidden', view !== 'compass');
    treeViewWrap.classList.toggle('hidden', view !== 'tree');
    resizeAllCanvases();
    if (view === 'compass') drawCompassView();
    else drawMap();
}

function resizeAllCanvases() {
    // Compass canvas
    const cWrap = compassCanvas.parentElement;
    if (cWrap) {
        const cr = cWrap.getBoundingClientRect();
        compassCanvas.width  = cr.width * window.devicePixelRatio;
        compassCanvas.height = cr.height * window.devicePixelRatio;
        compassCanvas.style.width  = cr.width + 'px';
        compassCanvas.style.height = cr.height + 'px';
    }
    // Tree canvas
    const container = mapCanvas.parentElement;
    if (container) {
        const rect = container.getBoundingClientRect();
        mapCanvas.width  = rect.width * window.devicePixelRatio;
        mapCanvas.height = rect.height * window.devicePixelRatio;
        mapCanvas.style.width  = rect.width + 'px';
        mapCanvas.style.height = rect.height + 'px';
    }
}

// ════════════════════════════════════════════
// COMPASS VIEW (zoomed in — N/S/E/W)
// ════════════════════════════════════════════

function drawCompassView() {
    const ctx = compassCanvas.getContext('2d');
    const dpr = window.devicePixelRatio;
    const w = compassCanvas.width;
    const h = compassCanvas.height;
    if (w === 0 || h === 0) return;
    ctx.clearRect(0, 0, w, h);

    const node = tree[currentNode];
    const cx = w / 2;
    const cy = h / 2;
    const radius = Math.min(w, h) * 0.38;
    const nodeHex = node.hex || '#00f0ff';

    // ── Background grid ──
    ctx.strokeStyle = 'rgba(0, 240, 255, 0.025)';
    ctx.lineWidth = 1;
    const gs = 50 * dpr;
    for (let x = 0; x < w; x += gs) { ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, h); ctx.stroke(); }
    for (let y = 0; y < h; y += gs) { ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(w, y); ctx.stroke(); }

    // ── Compass rings ──
    [0.92, 0.68, 0.38].forEach((s, i) => {
        ctx.beginPath();
        ctx.arc(cx, cy, radius * s, 0, Math.PI * 2);
        ctx.strokeStyle = `rgba(0, 240, 255, ${0.04 + i * 0.02})`;
        ctx.lineWidth = 1;
        ctx.stroke();
    });

    // ── Filter-colored aura ring ──
    if (filterStack.length > 0) {
        const comboColor = getCompositeColor(filterStack);
        // Outer aura
        ctx.beginPath();
        ctx.arc(cx, cy, radius * 0.98, 0, Math.PI * 2);
        ctx.strokeStyle = comboColor;
        ctx.globalAlpha = 0.2 + filterStack.length * 0.06;
        ctx.lineWidth = (2 + filterStack.length) * dpr;
        ctx.stroke();
        ctx.globalAlpha = 1;
        // Pulsing glow
        ctx.beginPath();
        ctx.arc(cx, cy, radius * 0.98, 0, Math.PI * 2);
        const auraGlow = ctx.createRadialGradient(cx, cy, radius * 0.9, cx, cy, radius * 1.1);
        auraGlow.addColorStop(0, 'transparent');
        auraGlow.addColorStop(0.5, comboColor.replace(')', ',0.06)').replace('rgb', 'rgba'));
        auraGlow.addColorStop(1, 'transparent');
        ctx.fillStyle = auraGlow;
        ctx.fill();
        // Segment arcs per-filter (each gets a colored arc section)
        const arcPer = (Math.PI * 2) / filterStack.length;
        filterStack.forEach((fname, i) => {
            ctx.beginPath();
            ctx.arc(cx, cy, radius * 1.02, -Math.PI/2 + i * arcPer, -Math.PI/2 + (i+1) * arcPer);
            ctx.strokeStyle = FILTER_COLORS[fname].color;
            ctx.globalAlpha = 0.5;
            ctx.lineWidth = 3 * dpr;
            ctx.stroke();
            ctx.globalAlpha = 1;
        });
    }

    // ── Cross-hair lines ──
    ctx.strokeStyle = 'rgba(0, 240, 255, 0.06)';
    ctx.lineWidth = 1;
    ctx.setLineDash([6 * dpr, 8 * dpr]);
    ctx.beginPath(); ctx.moveTo(cx, cy - radius * 1.1); ctx.lineTo(cx, cy + radius * 1.1); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(cx - radius * 1.1, cy); ctx.lineTo(cx + radius * 1.1, cy); ctx.stroke();
    ctx.setLineDash([]);

    // ── Direction labels (faint) ──
    ctx.font = `${9 * dpr}px "Orbitron", monospace`;
    ctx.textAlign = 'center';
    ctx.fillStyle = 'rgba(0, 240, 255, 0.2)';
    ctx.fillText('▲ DEEPER', cx, cy - radius * 1.0 - 16 * dpr);
    ctx.fillText('▼ BROADER', cx, cy + radius * 1.0 + 26 * dpr);
    ctx.textAlign = 'right';
    ctx.fillText('◀ LEFT', cx - radius * 1.0 - 12 * dpr, cy + 3 * dpr);
    ctx.textAlign = 'left';
    ctx.fillText('RIGHT ▶', cx + radius * 1.0 + 12 * dpr, cy + 3 * dpr);

    // ── Get neighbors ──
    const visibleChildren = getVisibleChildren(currentNode);
    const visibleSiblings = getVisibleSiblings(currentNode);
    const sibIdx = visibleSiblings.indexOf(currentNode);

    const northNode = visibleChildren.length > 0 ? tree[visibleChildren[0]] : null;
    const southNode = node.parent ? tree[node.parent] : null;
    const leftNode  = visibleSiblings.length > 1 ? tree[visibleSiblings[(sibIdx - 1 + visibleSiblings.length) % visibleSiblings.length]] : null;
    const rightNode = visibleSiblings.length > 1 ? tree[visibleSiblings[(sibIdx + 1) % visibleSiblings.length]] : null;

    // Additional children beyond the first (shown as sub-options near north)
    const extraChildren = visibleChildren.length > 1 ? visibleChildren.slice(1).map(id => tree[id]) : [];

    const colorMap = {
        '#00f0ff': { glow: 'rgba(0,240,255,', fill: '#0a2a3a' },
        '#ffb800': { glow: 'rgba(255,184,0,', fill: '#2d2a0d' },
        '#39FF14': { glow: 'rgba(57,255,20,', fill: '#0d3b1d' },
        '#bf5af2': { glow: 'rgba(191,90,242,', fill: '#2a0d3b' },
    };

    function drawNeighborNode(x, y, targetNode, dirLabel, isExplored) {
        if (!targetNode) {
            // Empty slot — show dim placeholder
            ctx.beginPath();
            ctx.arc(x, y, 18 * dpr, 0, Math.PI * 2);
            ctx.strokeStyle = 'rgba(0,240,255,0.06)';
            ctx.lineWidth = 1;
            ctx.setLineDash([3 * dpr, 3 * dpr]);
            ctx.stroke();
            ctx.setLineDash([]);
            ctx.font = `${9 * dpr}px "Share Tech Mono", monospace`;
            ctx.textAlign = 'center';
            ctx.fillStyle = 'rgba(0,240,255,0.1)';
            ctx.fillText('—', x, y + 3 * dpr);
            return;
        }

        const nh = targetNode.hex || '#00f0ff';
        const cm = colorMap[nh] || colorMap['#00f0ff'];
        const explored = exploredNodes.has(targetNode.id);
        const isRevealed = !!targetNode.revealCondition;
        const nr = 24 * dpr;

        // Connection line from center
        ctx.beginPath();
        ctx.moveTo(cx, cy);
        ctx.lineTo(x, y);
        ctx.strokeStyle = explored ? cm.glow + '0.3)' : 'rgba(0,240,255,0.08)';
        ctx.lineWidth = (explored ? 2 : 1) * dpr;
        ctx.stroke();

        // Glow
        ctx.beginPath();
        ctx.arc(x, y, nr * 2.5, 0, Math.PI * 2);
        const glow = ctx.createRadialGradient(x, y, nr, x, y, nr * 2.5);
        const gc = explored ? cm.glow : (isRevealed ? 'rgba(255,184,0,' : 'rgba(0,240,255,');
        glow.addColorStop(0, gc + '0.12)');
        glow.addColorStop(1, gc + '0)');
        ctx.fillStyle = glow;
        ctx.fill();

        // Node circle
        ctx.beginPath();
        ctx.arc(x, y, nr, 0, Math.PI * 2);
        ctx.fillStyle = explored ? cm.fill : (isRevealed ? '#2d2a0d' : '#1a2533');
        ctx.fill();
        ctx.strokeStyle = explored ? nh : (isRevealed ? '#ffb800' : '#3d4d60');
        ctx.lineWidth = 1.5 * dpr;
        ctx.stroke();

        // Label
        ctx.font = `bold ${12 * dpr}px "Share Tech Mono", monospace`;
        ctx.textAlign = 'center';
        ctx.fillStyle = explored ? nh : (isRevealed ? '#ffb800' : '#5a6a7e');
        const label = targetNode.title.length > 14 ? targetNode.title.substring(0, 12) + '..' : targetNode.title;
        ctx.fillText(label, x, y + nr + 16 * dpr);

        // Subtitle
        if (targetNode.subtitle) {
            ctx.font = `${8.5 * dpr}px "Share Tech Mono", monospace`;
            ctx.fillStyle = explored ? (gc + '0.5)') : 'rgba(0,240,255,0.2)';
            const sub = targetNode.subtitle.length > 20 ? targetNode.subtitle.substring(0, 18) + '..' : targetNode.subtitle;
            ctx.fillText(sub, x, y + nr + 28 * dpr);
        }

        // Explored indicator
        if (explored) {
            ctx.beginPath();
            ctx.arc(x, y, nr * 0.3, 0, Math.PI * 2);
            ctx.fillStyle = nh;
            ctx.globalAlpha = 0.5;
            ctx.fill();
            ctx.globalAlpha = 1;
        }
    }

    // ── Draw neighbor nodes at cardinal positions ──
    const dist = radius * 0.75;
    drawNeighborNode(cx, cy - dist, northNode, 'DEEPER');
    drawNeighborNode(cx, cy + dist, southNode, 'BROADER');
    drawNeighborNode(cx - dist, cy, leftNode, 'LEFT');
    drawNeighborNode(cx + dist, cy, rightNode, 'RIGHT');

    // ── Draw extra children fanning near north ──
    if (extraChildren.length > 0) {
        const fanSpread = Math.min(radius * 0.5, extraChildren.length * 35 * dpr);
        extraChildren.forEach((child, i) => {
            const angle = -Math.PI / 2 + ((i + 1) / (extraChildren.length + 1) - 0.5) * 0.8;
            const fx = cx + Math.cos(angle) * dist * 0.95 + (i + 1) * (fanSpread / (extraChildren.length + 1)) - fanSpread / 2;
            const fy = cy - dist * 0.65 - 15 * dpr;
            // Mini nodes
            const miniR = 13 * dpr;
            const explored = exploredNodes.has(child.id);
            const ch = child.hex || '#00f0ff';
            const ccm = colorMap[ch] || colorMap['#00f0ff'];

            // Mini connection
            ctx.beginPath();
            ctx.moveTo(cx, cy - dist);
            ctx.lineTo(fx, fy);
            ctx.strokeStyle = 'rgba(0,240,255,0.06)';
            ctx.lineWidth = 1;
            ctx.stroke();

            ctx.beginPath();
            ctx.arc(fx, fy, miniR, 0, Math.PI * 2);
            ctx.fillStyle = explored ? ccm.fill : '#1a2533';
            ctx.fill();
            ctx.strokeStyle = explored ? ch : '#3d4d60';
            ctx.lineWidth = 1;
            ctx.stroke();

            ctx.font = `${9 * dpr}px "Share Tech Mono", monospace`;
            ctx.textAlign = 'center';
            ctx.fillStyle = explored ? ch : '#3d4d60';
            const ml = child.title.length > 10 ? child.title.substring(0, 8) + '..' : child.title;
            ctx.fillText(ml, fx, fy + miniR + 12 * dpr);
        });
    }

    // ── Center node (current) ──
    const centerR = 36 * dpr;
    const cm = colorMap[nodeHex] || colorMap['#00f0ff'];

    // Big glow — tinted by filter combo if active
    const glowBase = filterStack.length > 0 ? getCompositeColor(filterStack) : null;
    ctx.beginPath();
    ctx.arc(cx, cy, centerR * 3.5, 0, Math.PI * 2);
    const cGlow = ctx.createRadialGradient(cx, cy, centerR, cx, cy, centerR * 3.5);
    cGlow.addColorStop(0, cm.glow + '0.2)');
    cGlow.addColorStop(0.5, cm.glow + '0.06)');
    cGlow.addColorStop(1, cm.glow + '0)');
    ctx.fillStyle = cGlow;
    ctx.fill();

    // Filter indicator orbit dots around center
    if (filterStack.length > 0) {
        const orbitR = centerR * 1.6;
        filterStack.forEach((fname, i) => {
            const angle = -Math.PI/2 + (i / filterStack.length) * Math.PI * 2;
            const dx = cx + Math.cos(angle) * orbitR;
            const dy = cy + Math.sin(angle) * orbitR;
            ctx.beginPath();
            ctx.arc(dx, dy, 5 * dpr, 0, Math.PI * 2);
            ctx.fillStyle = FILTER_COLORS[fname].color;
            ctx.globalAlpha = 0.7;
            ctx.fill();
            ctx.globalAlpha = 1;
            // Small glow
            ctx.beginPath();
            ctx.arc(dx, dy, 10 * dpr, 0, Math.PI * 2);
            const dGlow = ctx.createRadialGradient(dx, dy, 3*dpr, dx, dy, 10*dpr);
            dGlow.addColorStop(0, FILTER_COLORS[fname].glow + '0.3)');
            dGlow.addColorStop(1, FILTER_COLORS[fname].glow + '0)');
            ctx.fillStyle = dGlow;
            ctx.fill();
        });
    }

    // Node body
    ctx.beginPath();
    ctx.arc(cx, cy, centerR, 0, Math.PI * 2);
    ctx.fillStyle = cm.fill;
    ctx.fill();
    ctx.strokeStyle = filterStack.length > 0 ? getCompositeColor(filterStack) : nodeHex;
    ctx.lineWidth = 2.5 * dpr;
    ctx.stroke();

    // Inner dot
    ctx.beginPath();
    ctx.arc(cx, cy, centerR * 0.3, 0, Math.PI * 2);
    ctx.fillStyle = nodeHex;
    ctx.globalAlpha = 0.6;
    ctx.fill();
    ctx.globalAlpha = 1;

    // Center label
    ctx.font = `bold ${14 * dpr}px "Orbitron", monospace`;
    ctx.textAlign = 'center';
    ctx.fillStyle = nodeHex;
    ctx.fillText(node.title, cx, cy + centerR + 22 * dpr);

    // Subtitle
    if (node.subtitle) {
        ctx.font = `${9 * dpr}px "Share Tech Mono", monospace`;
        ctx.fillStyle = cm.glow + '0.6)';
        ctx.fillText(node.subtitle.toUpperCase(), cx, cy + centerR + 36 * dpr);
    }

    // Depth indicator
    ctx.font = `${9 * dpr}px "Orbitron", monospace`;
    ctx.fillStyle = 'rgba(0,240,255,0.2)';
    ctx.fillText(`DEPTH ${node.depth}`, cx, cy + centerR + 50 * dpr);

    // ── Hidden path hints ──
    const hiddenCount = countHiddenNearby();
    if (hiddenCount > 0) {
        ctx.font = `${10 * dpr}px "Share Tech Mono", monospace`;
        ctx.fillStyle = 'rgba(255,184,0,0.45)';
        ctx.fillText(`◇ ${hiddenCount} hidden path${hiddenCount > 1 ? 's' : ''} nearby — try filter combos`, cx, h - 24 * dpr);
    }

    // ── Explored count ──
    const visibleNodes = Object.values(tree).filter(n => !n.hidden);
    const hiddenTotal = Object.values(tree).filter(n => n.hidden).length;
    ctx.font = `${9 * dpr}px "Share Tech Mono", monospace`;
    ctx.textAlign = 'left';
    ctx.fillStyle = 'rgba(0,240,255,0.2)';
    ctx.fillText(`EXPLORED: ${exploredNodes.size} / ${visibleNodes.length}${hiddenTotal > 0 ? ' + ???' : ''}`, 14 * dpr, h - 14 * dpr);

    // ── Active filters indicator (top-right) ──
    if (filterStack.length > 0) {
        ctx.textAlign = 'right';
        ctx.font = `bold ${9 * dpr}px "Orbitron", monospace`;
        filterStack.forEach((fname, i) => {
            ctx.fillStyle = FILTER_COLORS[fname].color;
            ctx.globalAlpha = 0.6;
            ctx.fillText(fname.toUpperCase().slice(0,4), w - 14 * dpr, (18 + i * 16) * dpr);
        });
        ctx.globalAlpha = 1;
    }
}

// ════════════════════════════════════════════
// TREE VIEW (overview map)
// ════════════════════════════════════════════

function resizeMap() {
    const container = mapCanvas.parentElement;
    const rect = container.getBoundingClientRect();
    mapCanvas.width  = rect.width * window.devicePixelRatio;
    mapCanvas.height = rect.height * window.devicePixelRatio;
    mapCanvas.style.width  = rect.width + 'px';
    mapCanvas.style.height = rect.height + 'px';
}

function drawMap() {
    const ctx = mapCanvas.getContext('2d');
    const dpr = window.devicePixelRatio;
    const w = mapCanvas.width;
    const h = mapCanvas.height;
    ctx.clearRect(0, 0, w, h);

    // ── Background grid for the big map ──
    ctx.strokeStyle = 'rgba(0, 240, 255, 0.03)';
    ctx.lineWidth = 1;
    const gridSize = 40 * dpr;
    for (let x = 0; x < w; x += gridSize) {
        ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, h); ctx.stroke();
    }
    for (let y = 0; y < h; y += gridSize) {
        ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(w, y); ctx.stroke();
    }

    // Only draw visible nodes
    const visibleTree = {};
    Object.entries(tree).forEach(([id, node]) => {
        if (!node.hidden) visibleTree[id] = node;
    });

    const positions = {};
    const padding = 50 * dpr;
    const nodeRadius = 16 * dpr;

    // Count max depth
    let maxDepth = 0;
    Object.values(visibleTree).forEach(n => { if (n.depth > maxDepth) maxDepth = n.depth; });
    const levelGap = maxDepth > 0 ? (h - padding * 2) / Math.max(maxDepth, 1) : h / 2;

    // ── Layout positions ──
    // Origin at center-top
    positions.origin = { x: w / 2, y: padding + nodeRadius * 2 };

    // Depth 1 — spread evenly
    const d1 = tree.origin.children.filter(id => !tree[id].hidden);
    const d1Spacing = (w - padding * 2) / (d1.length + 1);
    d1.forEach((id, i) => {
        positions[id] = { x: padding + d1Spacing * (i + 1), y: padding + levelGap + nodeRadius };
    });

    // Depth 2+
    d1.forEach(parentId => {
        const children = (tree[parentId].children || []).filter(id => !tree[id].hidden);
        if (children.length === 0) return;
        const parentX = positions[parentId]?.x || w / 2;
        const spread = d1Spacing * 0.95;
        const childSpacing = spread / (children.length + 1);
        const startX = parentX - spread / 2;
        children.forEach((cid, ci) => {
            positions[cid] = {
                x: startX + childSpacing * (ci + 1),
                y: padding + levelGap * 2 + nodeRadius
            };
            // Depth 3
            const grandchildren = (tree[cid].children || []).filter(id => !tree[id].hidden);
            grandchildren.forEach((gcid, gci) => {
                const gcSpread = childSpacing * 0.85;
                positions[gcid] = {
                    x: positions[cid].x - gcSpread / 2 + gcSpread * (gci + 1) / (grandchildren.length + 1),
                    y: padding + levelGap * 3 + nodeRadius
                };
            });
        });
    });

    // ── Fog of war ──
    ctx.fillStyle = 'rgba(6, 8, 13, 0.5)';
    ctx.fillRect(0, 0, w, h);
    exploredNodes.forEach(id => {
        if (!positions[id]) return;
        const pos = positions[id];
        ctx.globalCompositeOperation = 'destination-out';
        ctx.beginPath();
        ctx.arc(pos.x, pos.y, 90 * dpr, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(0,0,0,0.8)';
        ctx.fill();
    });
    ctx.globalCompositeOperation = 'source-over';

    // ── Connection lines ──
    Object.entries(visibleTree).forEach(([id, node]) => {
        if (!positions[id]) return;
        const pos = positions[id];
        (node.children || []).filter(cid => !tree[cid].hidden).forEach(childId => {
            if (!positions[childId]) return;
            const cpos = positions[childId];
            const isOnPath = pathHistory.includes(id) && pathHistory.includes(childId);

            // Draw glow for on-path connections
            if (isOnPath) {
                ctx.beginPath();
                ctx.moveTo(pos.x, pos.y);
                const midY = (pos.y + cpos.y) / 2;
                ctx.bezierCurveTo(pos.x, midY, cpos.x, midY, cpos.x, cpos.y);
                ctx.strokeStyle = 'rgba(0,240,255,0.15)';
                ctx.lineWidth = 6 * dpr;
                ctx.stroke();
            }

            ctx.beginPath();
            ctx.moveTo(pos.x, pos.y);
            const midY = (pos.y + cpos.y) / 2;
            ctx.bezierCurveTo(pos.x, midY, cpos.x, midY, cpos.x, cpos.y);
            ctx.strokeStyle = isOnPath ? 'rgba(0,240,255,0.6)' : 'rgba(0,240,255,0.1)';
            ctx.lineWidth = (isOnPath ? 2.5 : 1) * dpr;
            ctx.stroke();

            // Arrow indicator on path edges
            if (isOnPath) {
                const t = 0.65;
                const mt = 1 - t;
                const ax = mt*mt*mt*pos.x + 3*mt*mt*t*pos.x + 3*mt*t*t*cpos.x + t*t*t*cpos.x;
                const ay = mt*mt*mt*pos.y + 3*mt*mt*t*midY + 3*mt*t*t*midY + t*t*t*cpos.y;
                ctx.beginPath();
                ctx.arc(ax, ay, 3 * dpr, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(0,240,255,0.5)';
                ctx.fill();
            }
        });
    });

    // ── Color map for node categories ──
    const colorMap = {
        '#00f0ff': { fill: '#0a2a3a', stroke: '#00f0ff', glow: 'rgba(0,240,255,' },
        '#ffb800': { fill: '#2d2a0d', stroke: '#ffb800', glow: 'rgba(255,184,0,' },
        '#39FF14': { fill: '#0d3b1d', stroke: '#39FF14', glow: 'rgba(57,255,20,' },
        '#bf5af2': { fill: '#2a0d3b', stroke: '#bf5af2', glow: 'rgba(191,90,242,' },
    };

    // ── Nodes ──
    Object.entries(positions).forEach(([id, pos]) => {
        const node = visibleTree[id];
        if (!node) return;
        const isCurrent = id === currentNode;
        const isExplored = exploredNodes.has(id);
        const isRevealed = !!node.revealCondition;

        // Determine color from node's hex property
        const nodeHex = node.hex || '#00f0ff';
        const cm = colorMap[nodeHex] || colorMap['#00f0ff'];

        let fillColor = '#1a2533';
        let strokeColor = '#3d4d60';
        let glowBase = 'rgba(0,240,255,';

        if (isExplored) { fillColor = cm.fill; strokeColor = cm.stroke; glowBase = cm.glow; }
        if (isRevealed && !isExplored) { fillColor = '#2d2a0d'; strokeColor = '#ffb800'; glowBase = 'rgba(255,184,0,'; }
        if (isCurrent) { fillColor = cm.fill; strokeColor = cm.stroke; glowBase = cm.glow; }

        const r = isCurrent ? nodeRadius * 1.6 : (isExplored ? nodeRadius * 1.1 : nodeRadius * 0.8);

        // Outer glow for current
        if (isCurrent) {
            ctx.beginPath();
            ctx.arc(pos.x, pos.y, r * 4, 0, Math.PI * 2);
            const glow = ctx.createRadialGradient(pos.x, pos.y, r, pos.x, pos.y, r * 4);
            glow.addColorStop(0, glowBase + '0.25)');
            glow.addColorStop(0.5, glowBase + '0.08)');
            glow.addColorStop(1, glowBase + '0)');
            ctx.fillStyle = glow;
            ctx.fill();
        }

        // Subtle glow for explored
        if (isExplored && !isCurrent) {
            ctx.beginPath();
            ctx.arc(pos.x, pos.y, r * 2.5, 0, Math.PI * 2);
            const glow = ctx.createRadialGradient(pos.x, pos.y, r, pos.x, pos.y, r * 2.5);
            glow.addColorStop(0, glowBase + '0.1)');
            glow.addColorStop(1, glowBase + '0)');
            ctx.fillStyle = glow;
            ctx.fill();
        }

        // Node body
        ctx.beginPath();
        ctx.arc(pos.x, pos.y, r, 0, Math.PI * 2);
        ctx.fillStyle = fillColor;
        ctx.fill();
        ctx.strokeStyle = strokeColor;
        ctx.lineWidth = (isCurrent ? 2.5 : 1.5) * dpr;
        ctx.stroke();

        // Inner dot
        if (isCurrent) {
            ctx.beginPath();
            ctx.arc(pos.x, pos.y, r * 0.35, 0, Math.PI * 2);
            ctx.fillStyle = strokeColor;
            ctx.fill();
        }

        // ── Labels ──
        const fontSize = isCurrent ? 13 : (isExplored ? 11 : 10);
        ctx.font = `bold ${fontSize * dpr}px "Share Tech Mono", monospace`;
        ctx.textAlign = 'center';
        ctx.fillStyle = isCurrent ? strokeColor : (isExplored ? strokeColor : (isRevealed ? '#ffb800' : '#3d4d60'));
        const label = node.title.length > 16 ? node.title.substring(0, 14) + '..' : node.title;
        ctx.fillText(label, pos.x, pos.y + r + 18 * dpr);

        // Depth / subtitle for current node
        if (isCurrent) {
            ctx.font = `${9 * dpr}px "Share Tech Mono", monospace`;
            ctx.fillStyle = 'rgba(0,240,255,0.5)';
            const sub = node.subtitle || '';
            if (sub) ctx.fillText(sub.toUpperCase(), pos.x, pos.y + r + 30 * dpr);
        }
    });

    // ── Draw depth level indicators on left side ──
    ctx.font = `${9 * dpr}px "Orbitron", monospace`;
    ctx.textAlign = 'left';
    ctx.fillStyle = 'rgba(0,240,255,0.18)';
    for (let d = 0; d <= maxDepth; d++) {
        const y = padding + levelGap * d + nodeRadius * 2;
        ctx.fillText(`D:${d}`, 10 * dpr, y);
        ctx.beginPath();
        ctx.moveTo(0, y - 4 * dpr);
        ctx.lineTo(w, y - 4 * dpr);
        ctx.strokeStyle = 'rgba(0,240,255,0.025)';
        ctx.lineWidth = 1;
        ctx.stroke();
    }
}

// ════════════════════════════════════════════
// KEYBOARD
// ════════════════════════════════════════════

document.addEventListener('keydown', (e) => {
    // Tutorial
    if (!gameStarted) {
        if (e.key === 'ArrowUp')    { e.preventDefault(); highlightDirection('north'); }
        if (e.key === 'ArrowRight') { e.preventDefault(); highlightDirection('east'); }
        if (e.key === 'ArrowDown')  { e.preventDefault(); highlightDirection('south'); }
        if (e.key === 'ArrowLeft')  { e.preventDefault(); highlightDirection('west'); }
        if (tutorialPhase >= 2) {
            if (e.key === 'w' || e.key === 'W') { e.preventDefault(); highlightFilter('w'); }
            if (e.key === 'a' || e.key === 'A') { e.preventDefault(); highlightFilter('a'); }
            if (e.key === 's' || e.key === 'S') { e.preventDefault(); highlightFilter('s'); }
            if (e.key === 'd' || e.key === 'D') { e.preventDefault(); highlightFilter('d'); }
        }
        if ((e.key === 'Enter' || e.key === ' ') && tutorialComplete) { e.preventDefault(); enterCompass(); }
        return;
    }

    // Tab toggles views
    if (e.key === 'Tab') { e.preventDefault(); setView(currentView === 'compass' ? 'tree' : 'compass'); return; }

    // Exploration
    switch (e.key) {
        case 'ArrowUp':    e.preventDefault(); navDepth('deeper'); pressBtn(btnUp); break;
        case 'ArrowDown':  e.preventDefault(); navDepth('broader'); pressBtn(btnDown); break;
        case 'ArrowLeft':  e.preventDefault(); navBreadth('left'); pressBtn(btnLeft); break;
        case 'ArrowRight': e.preventDefault(); navBreadth('right'); pressBtn(btnRight); break;
        case 'w': case 'W': e.preventDefault(); toggleFilter('technical'); break;
        case 'a': case 'A': e.preventDefault(); toggleFilter('ethical'); break;
        case 's': case 'S': e.preventDefault(); toggleFilter('economic'); break;
        case 'd': case 'D': e.preventDefault(); toggleFilter('social'); break;
        case 'q': case 'Q': e.preventDefault(); clearFilters(); break;
        case 'Escape': e.preventDefault(); clearFilters(); break;
        case 'Backspace': e.preventDefault(); goBack(); break;
    }
});

function pressBtn(btn) {
    btn.classList.add('pressed');
    setTimeout(() => btn.classList.remove('pressed'), 150);
}

window.addEventListener('resize', () => {
    if (gameStarted) { resizeAllCanvases(); render(); }
});

// Init
render();
</script>

</body>
</html>

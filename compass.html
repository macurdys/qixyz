


<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>AI Moral Compass — Possibility Navigator v0.4</title>
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Crect width='32' height='32' rx='6' fill='%2306080d'/%3E%3Ctext x='16' y='23' text-anchor='middle' font-family='monospace' font-size='18' font-weight='bold' fill='%2300f0ff'%3EQi%3C/text%3E%3C/svg%3E">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;600;700;800;900&family=Rajdhani:wght@300;400;500;600;700&family=Share+Tech+Mono&display=swap" rel="stylesheet">
    <style>
        :root {
            --qi-cyan: #00f0ff;
            --qi-cyan-dim: rgba(0, 240, 255, 0.12);
            --qi-cyan-glow: rgba(0, 240, 255, 0.4);
            --qi-amber: #ffb800;
            --qi-amber-dim: rgba(255, 184, 0, 0.12);
            --qi-red: #ff3366;
            --qi-green: #39FF14;
            --qi-green-dim: rgba(57, 255, 20, 0.12);
            --qi-purple: #bf5af2;
            --qi-purple-dim: rgba(191, 90, 242, 0.12);
            /* Consciousness level colors */
            --level-1: #ff4466;
            --level-1-dim: rgba(255, 68, 102, 0.12);
            --level-2: #4488ff;
            --level-2-dim: rgba(68, 136, 255, 0.12);
            --level-3: #44ff88;
            --level-3-dim: rgba(68, 255, 136, 0.12);
            /* Per-filter lens colors */
            --filter-tech: #00f0ff;
            --filter-tech-dim: rgba(0, 240, 255, 0.10);
            --filter-ethic: #bf5af2;
            --filter-ethic-dim: rgba(191, 90, 242, 0.10);
            --filter-econ: #39FF14;
            --filter-econ-dim: rgba(57, 255, 20, 0.10);
            --filter-social: #ffb800;
            --filter-social-dim: rgba(255, 184, 0, 0.10);
            --bg-deep: #06080d;
            --bg-panel: #0c1018;
            --bg-card: #111822;
            --border-dim: rgba(0, 240, 255, 0.1);
            --border-bright: rgba(0, 240, 255, 0.3);
            --text-primary: #e0e6ed;
            --text-secondary: #7a8a9e;
            --text-dim: #3d4d60;
            --font-display: 'Orbitron', monospace;
            --font-body: 'Rajdhani', sans-serif;
            --font-mono: 'Share Tech Mono', monospace;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        html, body {
            height: 100%;
            overflow: hidden;
            font-family: var(--font-body);
            background: var(--bg-deep);
            color: var(--text-primary);
            font-size: 18px;
            line-height: 1.6;
        }

        /* Scanlines */
        body::after {
            content: '';
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(0,240,255,0.006) 2px, rgba(0,240,255,0.006) 4px);
            pointer-events: none;
            z-index: 9999;
        }

        .grid-bg {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background-image:
                linear-gradient(var(--border-dim) 1px, transparent 1px),
                linear-gradient(90deg, var(--border-dim) 1px, transparent 1px);
            background-size: 60px 60px;
            opacity: 0.25;
            pointer-events: none;
            z-index: 0;
        }

        /* ═══════════════ BRIEFING SCREEN ═══════════════ */
        .briefing-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: var(--bg-deep);
            z-index: 10000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            padding: 3vh 20px 2vh;
            transition: opacity 0.6s, visibility 0.6s;
            overflow-y: auto;
        }
        .briefing-overlay.hidden {
            opacity: 0; visibility: hidden; pointer-events: none;
        }

        .briefing-header {
            text-align: center;
            margin-bottom: 2vh;
            flex-shrink: 0;
        }
        .briefing-title {
            font-family: var(--font-display);
            font-size: clamp(26px, 5vw, 48px);
            font-weight: 700;
            letter-spacing: 8px;
            color: var(--qi-cyan);
            text-shadow: 0 0 60px var(--qi-cyan-glow), 0 0 120px rgba(0,240,255,0.15);
            white-space: nowrap;
        }
        .briefing-subtitle {
            font-family: var(--font-mono);
            font-size: 14px;
            color: var(--text-secondary);
            letter-spacing: 5px;
            margin-top: 10px;
        }

        /* Compass hero */
        .compass-hero {
            position: relative;
            width: min(65vmin, 440px);
            flex-shrink: 0;
            margin-bottom: 3vh;
        }
        .compass-svg { width: 100%; height: auto; }
        .compass-svg .dir-highlight { opacity: 0; transition: opacity 0.15s; }
        .compass-svg .dir-highlight.active { opacity: 1; }
        .compass-svg .arrow-north,
        .compass-svg .arrow-east,
        .compass-svg .arrow-south,
        .compass-svg .arrow-west { transition: transform 0.15s, filter 0.15s; }
        .compass-svg .arrow-north.pulse { transform: translateY(-6px); filter: drop-shadow(0 0 12px #00f0ff); }
        .compass-svg .arrow-east.pulse  { transform: translateX(6px);  filter: drop-shadow(0 0 12px #ffb800); }
        .compass-svg .arrow-south.pulse { transform: translateY(6px);  filter: drop-shadow(0 0 12px #39FF14); }
        .compass-svg .arrow-west.pulse  { transform: translateX(-6px); filter: drop-shadow(0 0 12px #bf5af2); }

        /* Tutorial */
        .tutorial-prompt { text-align: center; margin-bottom: 2vh; flex-shrink: 0; }
        .tutorial-text {
            font-family: var(--font-mono);
            font-size: 15px;
            color: var(--text-secondary);
            letter-spacing: 2px;
            margin-bottom: 14px;
        }
        .tutorial-keys { display: flex; justify-content: center; gap: 8px; margin-bottom: 10px; }
        .key-hint {
            width: 50px; height: 50px;
            background: var(--bg-card);
            border: 1px solid var(--border-dim);
            border-radius: 6px;
            display: flex; align-items: center; justify-content: center;
            font-family: var(--font-mono);
            font-size: 18px;
            color: var(--text-dim);
            transition: all 0.15s;
        }
        .key-hint.active { border-color: var(--qi-cyan); color: var(--qi-cyan); box-shadow: 0 0 12px var(--qi-cyan-glow); background: var(--qi-cyan-dim); }
        .key-hint.north.active { border-color: var(--qi-cyan); color: var(--qi-cyan); box-shadow: 0 0 12px var(--qi-cyan-glow); }
        .key-hint.east.active  { border-color: var(--qi-amber); color: var(--qi-amber); box-shadow: 0 0 12px rgba(255,184,0,0.4); }
        .key-hint.south.active { border-color: var(--qi-green); color: var(--qi-green); box-shadow: 0 0 12px rgba(57,255,20,0.4); }
        .key-hint.west.active  { border-color: var(--qi-purple); color: var(--qi-purple); box-shadow: 0 0 12px rgba(191,90,242,0.4); }
        .tutorial-progress { font-family: var(--font-mono); font-size: 13px; color: var(--text-dim); letter-spacing: 1px; }
        .tutorial-progress span { color: var(--qi-cyan); }

        .tutorial-phase { transition: opacity 0.4s, transform 0.4s; }
        .tutorial-phase.phase-hidden { display: none; }
        .tutorial-phase.phase-complete { opacity: 0.3; transform: scale(0.9); pointer-events: none; display: none; }
        .key-hint.wasd-key { color: var(--text-dim); border-color: var(--border-dim); }
        .key-hint.wasd-key.active {
            border-color: var(--qi-amber); color: var(--qi-amber);
            box-shadow: 0 0 12px rgba(255,184,0,0.4); background: var(--qi-amber-dim);
        }
        .tutorial-phase-status { display: flex; align-items: center; justify-content: center; gap: 8px; margin-top: 12px; }
        .phase-dot {
            width: 10px; height: 10px; border-radius: 50%;
            background: var(--qi-cyan); box-shadow: 0 0 8px var(--qi-cyan-glow); transition: all 0.3s;
        }
        .phase-dot.dim { background: var(--text-dim); box-shadow: none; }
        .phase-dot.complete { background: var(--qi-green); box-shadow: 0 0 8px rgba(57,255,20,0.4); }
        .phase-dot.active-phase { background: var(--qi-amber); box-shadow: 0 0 8px rgba(255,184,0,0.4); }
        .phase-label { font-family: var(--font-mono); font-size: 11px; letter-spacing: 1px; color: var(--qi-cyan); margin-right: 6px; }
        .phase-label.dim { color: var(--text-dim); }
        .phase-label.complete { color: var(--qi-green); }
        .phase-label.active-phase { color: var(--qi-amber); }

        /* Briefing info */
        .briefing-info {
            background: var(--bg-panel);
            border: 1px solid var(--border-dim);
            padding: 20px 24px;
            max-width: 560px;
            width: 100%;
            margin-bottom: 2vh;
            flex-shrink: 0;
        }
        .briefing-info h3 {
            font-family: var(--font-display);
            font-size: 12px; letter-spacing: 4px; color: var(--qi-amber); margin-bottom: 14px;
        }
        .briefing-columns { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; }
        .briefing-col-title {
            font-family: var(--font-display);
            font-size: 10px; letter-spacing: 3px; color: var(--qi-cyan);
            margin-bottom: 8px; padding-bottom: 6px; border-bottom: 1px solid var(--border-dim);
        }
        .briefing-info ul {
            list-style: none; font-family: var(--font-mono); font-size: 13px; color: var(--text-secondary);
        }
        .briefing-info li { padding: 4px 0; display: flex; align-items: baseline; gap: 8px; }
        .briefing-info li::before { content: '◇'; color: var(--qi-cyan); font-size: 9px; flex-shrink: 0; }
        .briefing-info .key-label {
            font-family: var(--font-display); font-size: 11px; color: var(--qi-cyan);
            background: var(--bg-card); padding: 2px 7px; border: 1px solid var(--border-dim);
            border-radius: 3px; flex-shrink: 0; min-width: 24px; text-align: center;
        }
        .briefing-info .key-label.amber { color: var(--qi-amber); }

        .briefing-enter {
            font-family: var(--font-display);
            font-size: 14px; letter-spacing: 5px;
            padding: 18px 56px; background: transparent;
            border: 2px solid var(--qi-cyan); color: var(--qi-cyan);
            cursor: pointer; transition: all 0.3s;
            opacity: 0.3; pointer-events: none; flex-shrink: 0;
        }
        .briefing-enter.ready { opacity: 1; pointer-events: auto; }
        .briefing-enter.ready:hover { background: var(--qi-cyan); color: var(--bg-deep); box-shadow: 0 0 40px var(--qi-cyan-glow); }
        .briefing-enter-hint {
            font-family: var(--font-mono); font-size: 12px; color: var(--text-dim);
            margin-top: 14px; letter-spacing: 1px; flex-shrink: 0;
        }

        /* ═══════════════ MAIN EXPLORATION ═══════════════ */
        .compass-world {
            position: relative; z-index: 1;
            width: 100%; height: 100%;
            display: grid; grid-template-rows: auto 1fr auto;
            opacity: 0; transition: opacity 0.5s;
        }
        .compass-world.active { opacity: 1; }
        /* HUD order: controls on top, info on bottom */
        .hud-controls { order: -1; }
        .main-area { order: 0; }
        .hud-info { order: 1; }

        /* HUD Top → now controls bar */
        .hud-controls {
            display: flex; justify-content: space-between; align-items: center;
            padding: 10px 20px; border-bottom: 1px solid var(--border-dim);
            background: rgba(6,8,13,0.95); z-index: 10;
        }
        .location-display {
            font-family: var(--font-display);
            font-size: clamp(12px, 1.6vw, 16px); letter-spacing: 3px;
            color: var(--qi-cyan); text-shadow: 0 0 20px var(--qi-cyan-glow);
            display: flex; align-items: center; gap: 12px;
        }
        .depth-badge {
            font-family: var(--font-mono); font-size: 12px;
            padding: 3px 10px; border: 1px solid var(--border-dim);
            background: var(--bg-card); color: var(--text-secondary); letter-spacing: 1px;
        }
        .coords-display {
            font-family: var(--font-mono); font-size: 12px;
            color: var(--text-dim); letter-spacing: 1px;
        }

        .hud-top-right { display: flex; align-items: center; gap: 12px; }

        /* Filter stack display */
        .filter-stack-display { display: flex; align-items: center; gap: 3px; }
        .filter-chip {
            font-family: var(--font-mono); font-size: 11px; letter-spacing: 1px;
            padding: 5px 10px; border: 1px solid var(--border-dim);
            border-radius: 3px;
            background: var(--bg-card); color: var(--text-dim);
            cursor: pointer; transition: all 0.2s; position: relative;
        }
        .filter-chip.active {
            border-color: var(--qi-amber); color: var(--qi-amber);
            background: var(--qi-amber-dim); box-shadow: 0 0 8px rgba(255,184,0,0.2);
        }
        .filter-chip .stack-order {
            position: absolute; top: -7px; right: -5px;
            font-family: var(--font-display); font-size: 9px;
            background: var(--qi-amber); color: var(--bg-deep);
            width: 16px; height: 16px; border-radius: 50%;
            display: none; align-items: center; justify-content: center;
            line-height: 1;
        }
        .filter-chip.active .stack-order { display: flex; }
        .filter-stack-arrow {
            font-family: var(--font-mono); font-size: 11px;
            color: var(--qi-amber); opacity: 0; transition: opacity 0.2s;
        }
        .filter-stack-arrow.visible { opacity: 0.6; }
        .filter-stack-clear {
            font-family: var(--font-mono); font-size: 11px;
            padding: 5px 8px; border: 1px solid var(--border-dim);
            border-radius: 3px;
            background: var(--bg-card); color: var(--text-dim);
            cursor: pointer; transition: all 0.2s; opacity: 0; pointer-events: none;
        }
        .filter-stack-clear.visible { opacity: 1; pointer-events: auto; }
        .filter-stack-clear:hover { border-color: var(--qi-red); color: var(--qi-red); }

        /* Main area — map fills everything */
        .main-area { display: grid; grid-template-columns: 1fr; overflow: hidden; position: relative; }

        /* Exploration zone → map fills center */
        .exploration-zone {
            display: flex; align-items: stretch; justify-content: stretch;
            position: relative; overflow: hidden; padding: 0;
            width: 100%; height: 100%;
        }

        /* Map takes full center */
        .map-main-container {
            flex: 1; position: relative; overflow: hidden;
        }
        .map-main-canvas { width: 100%; height: 100%; display: block; }
        .map-main-legend {
            position: absolute; bottom: 10px; right: 14px;
            display: flex; gap: 16px; flex-wrap: wrap;
            padding: 8px 14px;
            background: rgba(6,8,13,0.85);
            border: 1px solid var(--border-dim);
            border-radius: 4px;
        }

        /* Node card → de-emphasized floating corner panel */
        .node-container {
            position: absolute;
            bottom: 20px; left: 20px;
            width: 420px; max-height: 50vh;
            z-index: 20; pointer-events: auto;
        }
        .node-content {
            background: rgba(12,16,24,0.92);
            border: 1px solid var(--border-dim);
            padding: 22px 24px;
            position: relative;
            opacity: 0.88;
            transform: scale(1);
            transition: opacity 0.25s, transform 0.2s;
            max-height: 50vh; overflow-y: auto;
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
            font-size: 15px;
            border-radius: 6px;
        }
        .node-content:hover { opacity: 1; }
        .node-content.transitioning { opacity: 0; transform: scale(0.96); }
        .node-content::before {
            content: '';
            position: absolute; top: 0; left: 0; right: 0; height: 2px;
            background: linear-gradient(90deg, transparent, var(--node-color, var(--qi-cyan)), transparent);
        }
        /* scrollbar styling */
        .node-content::-webkit-scrollbar { width: 4px; }
        .node-content::-webkit-scrollbar-track { background: var(--bg-deep); }
        .node-content::-webkit-scrollbar-thumb { background: var(--border-dim); }

        .node-title {
            font-family: var(--font-display);
            font-size: clamp(16px, 2.2vw, 22px); font-weight: 700;
            letter-spacing: 4px; margin-bottom: 4px;
            color: var(--node-color, var(--qi-cyan));
            text-shadow: 0 0 24px var(--node-glow, var(--qi-cyan-glow));
        }
        .node-subtitle {
            font-family: var(--font-mono); font-size: 12px;
            color: var(--text-secondary); letter-spacing: 2px;
            margin-bottom: 14px; text-transform: uppercase;
        }
        .node-description { font-size: 14px; color: var(--text-primary); line-height: 1.7; margin-bottom: 14px; opacity: 0.9; }
        .node-data { display: grid; grid-template-columns: repeat(auto-fit, minmax(100px, 1fr)); gap: 8px; margin-bottom: 14px; }
        .data-block { background: var(--bg-card); border: 1px solid var(--border-dim); padding: 8px 10px; border-radius: 4px; }
        .data-label { font-family: var(--font-mono); font-size: 9px; color: var(--text-dim); letter-spacing: 2px; margin-bottom: 2px; }
        .data-value { font-family: var(--font-display); font-size: 13px; color: var(--node-color, var(--qi-cyan)); }
        .node-tags { display: flex; flex-wrap: wrap; gap: 6px; }
        .node-tag {
            font-family: var(--font-mono); font-size: 10px; letter-spacing: 1px;
            padding: 3px 8px; background: var(--qi-cyan-dim);
            border: 1px solid var(--border-dim); color: var(--qi-cyan); border-radius: 3px;
        }

        /* Filter content layers */
        .filter-content {
            margin-top: 10px; padding-top: 10px;
            border-top: 1px solid var(--border-dim);
            animation: filterFadeIn 0.3s ease;
        }
        @keyframes filterFadeIn {
            from { opacity: 0; transform: translateY(6px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .filter-section-title {
            font-family: var(--font-display); font-size: 9px;
            letter-spacing: 2px; color: var(--qi-amber); margin-bottom: 6px;
        }
        .filter-text {
            font-size: 13px; color: var(--qi-amber);
            line-height: 1.6; font-style: italic; opacity: 0.85;
        }

        /* Composite filter insight */
        .composite-content {
            margin-top: 10px; padding: 10px;
            border: 1px solid var(--qi-amber);
            background: rgba(255, 184, 0, 0.06);
            position: relative;
            animation: compositeReveal 0.5s ease;
        }
        @keyframes compositeReveal {
            from { opacity: 0; transform: scale(0.97); border-color: transparent; }
            to { opacity: 1; transform: scale(1); border-color: var(--qi-amber); }
        }
        .composite-content::before {
            content: '';
            position: absolute; top: 0; left: 0; right: 0; height: 2px;
            background: linear-gradient(90deg, transparent, var(--qi-amber), transparent);
        }
        .composite-label {
            font-family: var(--font-display); font-size: 9px;
            letter-spacing: 2px; color: var(--qi-amber); margin-bottom: 6px;
            display: flex; align-items: center; gap: 6px;
        }
        .composite-label .combo-icon {
            font-size: 12px; opacity: 0.7;
        }
        .composite-text {
            font-size: 14px; color: #ffd466;
            line-height: 1.65; font-weight: 500;
        }

        /* Discovery notification */
        .discovery-notification {
            position: fixed; top: 50%; left: 50%;
            transform: translate(-50%, -50%) scale(0.8);
            background: rgba(6, 8, 13, 0.95);
            border: 2px solid var(--qi-amber);
            padding: 32px 52px; text-align: center;
            border-radius: 8px;
            z-index: 500; pointer-events: none;
            opacity: 0; transition: all 0.4s cubic-bezier(0.16, 1, 0.3, 1);
            box-shadow: 0 0 80px rgba(255, 184, 0, 0.3), inset 0 0 60px rgba(255, 184, 0, 0.05);
        }
        .discovery-notification.active {
            opacity: 1; transform: translate(-50%, -50%) scale(1);
        }
        .discovery-icon {
            font-family: var(--font-display); font-size: 14px;
            letter-spacing: 5px; color: var(--qi-amber); margin-bottom: 10px; opacity: 0.6;
        }
        .discovery-title {
            font-family: var(--font-display); font-size: 22px;
            letter-spacing: 4px; color: var(--qi-amber);
            text-shadow: 0 0 30px rgba(255,184,0,0.5); margin-bottom: 6px;
        }
        .discovery-sub {
            font-family: var(--font-mono); font-size: 13px;
            color: var(--text-secondary); letter-spacing: 1px;
        }

        /* Locked nodes */
        .locked-overlay {
            display: flex; flex-direction: column; align-items: center;
            justify-content: center; padding: 28px; text-align: center;
        }
        .locked-icon { font-size: 40px; margin-bottom: 16px; opacity: 0.5; }
        .locked-title {
            font-family: var(--font-display); font-size: 16px;
            letter-spacing: 5px; color: var(--qi-amber); margin-bottom: 10px;
        }
        .locked-desc {
            font-family: var(--font-mono); font-size: 13px;
            color: var(--text-secondary); margin-bottom: 18px; max-width: 300px; line-height: 1.7;
        }
        .unlock-btn {
            font-family: var(--font-display); font-size: 11px;
            letter-spacing: 3px; padding: 12px 26px;
            background: transparent; border: 1px solid var(--qi-amber);
            color: var(--qi-amber); cursor: pointer; transition: all 0.3s;
        }
        .unlock-btn:hover:not(:disabled) { background: var(--qi-amber); color: var(--bg-deep); }
        .unlock-btn:disabled { opacity: 0.3; cursor: not-allowed; }
        .unlock-cost { font-family: var(--font-mono); font-size: 11px; color: var(--text-dim); margin-top: 10px; }

        /* Nav hints */
        .nav-hints {
            display: grid; grid-template-columns: 1fr 1fr; gap: 6px;
            margin-top: 14px; padding-top: 14px; border-top: 1px solid var(--border-dim);
        }
        .nav-hint-item {
            display: flex; align-items: center; gap: 6px;
            font-family: var(--font-mono); font-size: 11px;
            color: var(--text-dim); letter-spacing: 0.5px;
        }
        .nav-hint-item.available { color: var(--text-secondary); }
        .nav-hint-item.revealed { color: var(--qi-amber); }
        .nav-hint-key {
            font-family: var(--font-display); font-size: 11px;
            width: 26px; height: 26px;
            display: flex; align-items: center; justify-content: center;
            border: 1px solid var(--border-dim); background: var(--bg-card); flex-shrink: 0;
            border-radius: 3px;
        }
        .nav-hint-item.available .nav-hint-key { border-color: var(--border-bright); color: var(--qi-cyan); }
        .nav-hint-item.revealed .nav-hint-key { border-color: var(--qi-amber); color: var(--qi-amber); }

        /* ═══════════════ SIDEBAR (now hidden — map is center) ═══════════════ */
        .sidebar { display: none; }
        .sidebar-tabs { display: flex; border-bottom: 1px solid var(--border-dim); flex-shrink: 0; }
        .sidebar-tab {
            flex: 1; padding: 8px 4px;
            font-family: var(--font-display); font-size: 8px; letter-spacing: 2px;
            text-align: center; color: var(--text-dim); background: none;
            border: none; cursor: pointer; transition: all 0.2s;
            border-bottom: 2px solid transparent;
        }
        .sidebar-tab:hover { color: var(--text-secondary); }
        .sidebar-tab.active { color: var(--qi-cyan); border-bottom-color: var(--qi-cyan); background: var(--qi-cyan-dim); }
        .sidebar-panel { flex: 1; overflow: hidden; display: none; }
        .sidebar-panel.active { display: flex; flex-direction: column; }

        .map-container { flex: 1; position: relative; overflow: hidden; }
        .map-canvas { width: 100%; height: 100%; }
        .map-legend { padding: 10px 14px; border-top: 1px solid var(--border-dim); display: flex; gap: 14px; flex-wrap: wrap; }
        .legend-item { display: flex; align-items: center; gap: 5px; font-family: var(--font-mono); font-size: 11px; color: var(--text-dim); letter-spacing: 0.5px; }
        .legend-dot { width: 8px; height: 8px; border-radius: 50%; }

        .index-header { padding: 12px 14px; border-bottom: 1px solid var(--border-dim); flex-shrink: 0; }
        .index-title { font-family: var(--font-display); font-size: 11px; letter-spacing: 3px; color: var(--qi-cyan); margin-bottom: 3px; }
        .index-stats { font-family: var(--font-mono); font-size: 11px; color: var(--text-dim); }
        .index-list { flex: 1; overflow-y: auto; padding: 6px; }
        .index-category { margin-bottom: 10px; }
        .index-category-title {
            font-family: var(--font-mono); font-size: 8px; letter-spacing: 2px;
            color: var(--text-dim); padding: 4px 5px;
            border-bottom: 1px solid var(--border-dim); margin-bottom: 4px;
        }
        .index-node {
            display: flex; align-items: center; gap: 6px;
            padding: 4px 6px; cursor: pointer;
            transition: background 0.2s; border: 1px solid transparent;
        }
        .index-node:hover { background: var(--bg-card); border-color: var(--border-dim); }
        .index-node.current { background: var(--qi-cyan-dim); border-color: var(--qi-cyan); }
        .index-node.unexplored { opacity: 0.3; cursor: default; }
        .index-node-icon { width: 5px; height: 5px; border-radius: 50%; flex-shrink: 0; }
        .index-node-icon.explored { background: var(--qi-green); }
        .index-node-icon.current { background: var(--qi-cyan); }
        .index-node-icon.unexplored { background: var(--text-dim); }
        .index-node-icon.revealed { background: var(--qi-amber); }
        .index-node-name { font-family: var(--font-mono); font-size: 9px; color: var(--text-secondary); letter-spacing: 0.5px; }
        .index-node.current .index-node-name { color: var(--qi-cyan); }

        /* ═══════════════ HUD BOTTOM → info bar ═══════════════ */
        .hud-info {
            display: flex; justify-content: space-between; align-items: center;
            padding: 10px 20px; border-top: 1px solid var(--border-dim);
            background: rgba(6,8,13,0.95); z-index: 10; gap: 16px;
        }
        .controls-group { display: flex; align-items: center; gap: 18px; }
        .control-cluster { display: flex; flex-direction: column; align-items: center; gap: 3px; }
        .cluster-label { font-family: var(--font-display); font-size: 9px; letter-spacing: 2px; color: var(--text-dim); margin-bottom: 3px; }
        .cluster-label.arrows { color: var(--qi-cyan); }
        .cluster-label.wasd { color: var(--qi-amber); }

        .dpad { display: grid; grid-template-columns: repeat(3, 34px); grid-template-rows: repeat(2, 34px); gap: 3px; }
        .dpad .ctrl-btn:nth-child(1) { grid-column: 2; grid-row: 1; }
        .dpad .ctrl-btn:nth-child(2) { grid-column: 1; grid-row: 2; }
        .dpad .ctrl-btn:nth-child(3) { grid-column: 2; grid-row: 2; }
        .dpad .ctrl-btn:nth-child(4) { grid-column: 3; grid-row: 2; }

        .ctrl-btn {
            font-family: var(--font-display); font-size: 12px;
            width: 34px; height: 34px;
            background: var(--bg-card); border: 1px solid var(--border-dim);
            border-radius: 4px;
            color: var(--qi-cyan); cursor: pointer; transition: all 0.15s;
            display: flex; align-items: center; justify-content: center;
        }
        .ctrl-btn:hover:not(:disabled) { background: var(--qi-cyan-dim); border-color: var(--qi-cyan); }
        .ctrl-btn:disabled { opacity: 0.15; cursor: not-allowed; }
        .ctrl-btn.pressed { background: var(--qi-cyan-dim); border-color: var(--qi-cyan); box-shadow: 0 0 10px var(--qi-cyan-glow); }
        .ctrl-btn.wasd-btn { color: var(--qi-amber); }
        .ctrl-btn.wasd-btn:hover:not(:disabled) { background: var(--qi-amber-dim); border-color: var(--qi-amber); }
        .ctrl-btn.wasd-btn.pressed, .ctrl-btn.wasd-btn.stack-active {
            background: var(--qi-amber-dim); border-color: var(--qi-amber);
            box-shadow: 0 0 10px rgba(255,184,0,0.3);
        }

        .ctrl-divider { width: 1px; height: 40px; background: var(--border-dim); }

        .back-btn {
            font-family: var(--font-display); font-size: 11px;
            padding: 8px 16px; background: var(--bg-card);
            border: 1px solid var(--border-dim); color: var(--text-secondary);
            border-radius: 4px;
            cursor: pointer; transition: all 0.2s; letter-spacing: 1px;
        }
        .back-btn:hover:not(:disabled) { border-color: var(--border-bright); color: var(--text-primary); }
        .back-btn:disabled { opacity: 0.2; cursor: not-allowed; }

        .path-display {
            font-family: var(--font-mono); font-size: 12px; color: var(--text-dim);
            letter-spacing: 0.5px; max-width: 300px; overflow: hidden;
            text-overflow: ellipsis; white-space: nowrap;
        }
        .path-display span { color: var(--qi-cyan); }

        .back-link {
            font-family: var(--font-mono); font-size: 12px;
            color: var(--text-dim); text-decoration: none;
            letter-spacing: 2px; transition: color 0.3s; flex-shrink: 0;
        }
        .back-link:hover { color: var(--qi-cyan); }

        .flash-overlay {
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background: var(--qi-cyan); opacity: 0; pointer-events: none;
            z-index: 100; transition: opacity 0.1s;
        }
        .flash-overlay.active { opacity: 0.08; }

        /* ═══════════════ VIEW TOGGLE + COMPASS VIEW ═══════════════ */
        .view-toggle {
            position: absolute; top: 12px; right: 12px; z-index: 25;
            display: flex; gap: 2px;
        }
        .view-toggle-btn {
            font-family: var(--font-display); font-size: 10px;
            letter-spacing: 2px; padding: 8px 18px;
            background: var(--bg-card); border: 1px solid var(--border-dim);
            border-radius: 4px;
            color: var(--text-dim); cursor: pointer; transition: all 0.2s;
        }
        .view-toggle-btn:first-child { border-radius: 0; }
        .view-toggle-btn:last-child { border-radius: 0; }
        .view-toggle-btn.active {
            border-color: var(--qi-cyan); color: var(--qi-cyan);
            background: var(--qi-cyan-dim); box-shadow: 0 0 10px var(--qi-cyan-glow);
        }
        .view-toggle-btn:hover:not(.active) { border-color: var(--border-bright); color: var(--text-secondary); }
        .view-toggle-hint {
            font-family: var(--font-mono); font-size: 10px;
            color: var(--text-dim); padding: 8px 0 0 4px;
            align-self: center;
        }

        .compass-canvas-wrap {
            position: absolute; top: 0; left: 0; right: 0; bottom: 0;
            z-index: 5; transition: opacity 0.3s;
        }
        .compass-canvas-wrap.hidden { opacity: 0; pointer-events: none; }
        .compass-view-canvas { width: 100%; height: 100%; display: block; }

        .map-main-container { z-index: 4; transition: opacity 0.3s; }
        .map-main-container.hidden { opacity: 0; pointer-events: none; }

        /* ═══════════════ DIRECTIONAL NAV ANIMATIONS ═══════════════ */
        .node-content.slide-up    { animation: slideFromBelow 0.28s cubic-bezier(0.22, 1, 0.36, 1); }
        .node-content.slide-down  { animation: slideFromAbove 0.28s cubic-bezier(0.22, 1, 0.36, 1); }
        .node-content.slide-left  { animation: slideFromLeft 0.28s cubic-bezier(0.22, 1, 0.36, 1); }
        .node-content.slide-right { animation: slideFromRight 0.28s cubic-bezier(0.22, 1, 0.36, 1); }
        @keyframes slideFromBelow {
            0%   { opacity: 0; transform: translateY(18px); }
            100% { opacity: 1; transform: translateY(0); }
        }
        @keyframes slideFromAbove {
            0%   { opacity: 0; transform: translateY(-18px); }
            100% { opacity: 1; transform: translateY(0); }
        }
        @keyframes slideFromLeft {
            0%   { opacity: 0; transform: translateX(-18px); }
            100% { opacity: 1; transform: translateX(0); }
        }
        @keyframes slideFromRight {
            0%   { opacity: 0; transform: translateX(18px); }
            100% { opacity: 1; transform: translateX(0); }
        }

        /* Directional sweep overlay on compass canvas */
        .compass-canvas-wrap .nav-sweep {
            position: absolute; pointer-events: none; z-index: 6;
            opacity: 0; transition: none;
        }
        .compass-canvas-wrap .nav-sweep.sweep-up {
            top: 0; left: 0; right: 0; height: 40%;
            background: linear-gradient(to bottom, rgba(0,240,255,0.08), transparent);
            animation: sweepFade 0.35s ease-out;
        }
        .compass-canvas-wrap .nav-sweep.sweep-down {
            bottom: 0; left: 0; right: 0; height: 40%;
            background: linear-gradient(to top, rgba(0,240,255,0.08), transparent);
            animation: sweepFade 0.35s ease-out;
        }
        .compass-canvas-wrap .nav-sweep.sweep-left {
            top: 0; left: 0; bottom: 0; width: 40%;
            background: linear-gradient(to right, rgba(0,240,255,0.08), transparent);
            animation: sweepFade 0.35s ease-out;
        }
        .compass-canvas-wrap .nav-sweep.sweep-right {
            top: 0; right: 0; bottom: 0; width: 40%;
            background: linear-gradient(to left, rgba(0,240,255,0.08), transparent);
            animation: sweepFade 0.35s ease-out;
        }
        @keyframes sweepFade {
            0%   { opacity: 1; }
            100% { opacity: 0; }
        }

        /* ═══════════════ PER-FILTER COLORS ═══════════════ */
        .filter-chip[data-filter="technical"].active {
            border-color: var(--filter-tech); color: var(--filter-tech);
            background: var(--filter-tech-dim); box-shadow: 0 0 8px rgba(0,240,255,0.2);
        }
        .filter-chip[data-filter="ethical"].active {
            border-color: var(--filter-ethic); color: var(--filter-ethic);
            background: var(--filter-ethic-dim); box-shadow: 0 0 8px rgba(191,90,242,0.2);
        }
        .filter-chip[data-filter="economic"].active {
            border-color: var(--filter-econ); color: var(--filter-econ);
            background: var(--filter-econ-dim); box-shadow: 0 0 8px rgba(57,255,20,0.2);
        }
        .filter-chip[data-filter="social"].active {
            border-color: var(--filter-social); color: var(--filter-social);
            background: var(--filter-social-dim); box-shadow: 0 0 8px rgba(255,184,0,0.2);
        }
        .filter-chip[data-filter="technical"].active .stack-order { background: var(--filter-tech); }
        .filter-chip[data-filter="ethical"].active .stack-order { background: var(--filter-ethic); }
        .filter-chip[data-filter="economic"].active .stack-order { background: var(--filter-econ); }
        .filter-chip[data-filter="social"].active .stack-order { background: var(--filter-social); }

        /* Per-filter WASD button colors */
        .ctrl-btn.wasd-btn.filter-tech { color: var(--filter-tech); }
        .ctrl-btn.wasd-btn.filter-ethic { color: var(--filter-ethic); }
        .ctrl-btn.wasd-btn.filter-econ { color: var(--filter-econ); }
        .ctrl-btn.wasd-btn.filter-social { color: var(--filter-social); }
        .ctrl-btn.wasd-btn.filter-tech:hover:not(:disabled) { background: var(--filter-tech-dim); border-color: var(--filter-tech); }
        .ctrl-btn.wasd-btn.filter-ethic:hover:not(:disabled) { background: var(--filter-ethic-dim); border-color: var(--filter-ethic); }
        .ctrl-btn.wasd-btn.filter-econ:hover:not(:disabled) { background: var(--filter-econ-dim); border-color: var(--filter-econ); }
        .ctrl-btn.wasd-btn.filter-social:hover:not(:disabled) { background: var(--filter-social-dim); border-color: var(--filter-social); }
        .ctrl-btn.wasd-btn.filter-tech.stack-active, .ctrl-btn.wasd-btn.filter-tech.pressed {
            background: var(--filter-tech-dim); border-color: var(--filter-tech); box-shadow: 0 0 10px rgba(0,240,255,0.3);
        }
        .ctrl-btn.wasd-btn.filter-ethic.stack-active, .ctrl-btn.wasd-btn.filter-ethic.pressed {
            background: var(--filter-ethic-dim); border-color: var(--filter-ethic); box-shadow: 0 0 10px rgba(191,90,242,0.3);
        }
        .ctrl-btn.wasd-btn.filter-econ.stack-active, .ctrl-btn.wasd-btn.filter-econ.pressed {
            background: var(--filter-econ-dim); border-color: var(--filter-econ); box-shadow: 0 0 10px rgba(57,255,20,0.3);
        }
        .ctrl-btn.wasd-btn.filter-social.stack-active, .ctrl-btn.wasd-btn.filter-social.pressed {
            background: var(--filter-social-dim); border-color: var(--filter-social); box-shadow: 0 0 10px rgba(255,184,0,0.3);
        }

        /* ═══════════════ CONSCIOUSNESS LEVEL ═══════════════ */
        .consciousness-display {
            display: flex; align-items: center; gap: 6px;
            padding-left: 14px; border-left: 1px solid var(--border-dim); margin-left: 4px;
        }
        .consciousness-label {
            font-family: var(--font-display); font-size: 9px;
            letter-spacing: 2px; color: var(--text-dim);
        }
        .level-btn {
            font-family: var(--font-display); font-size: 12px;
            width: 30px; height: 30px;
            background: var(--bg-card); border: 1px solid var(--border-dim);
            border-radius: 4px;
            color: var(--text-dim); cursor: pointer; transition: all 0.2s;
            display: flex; align-items: center; justify-content: center;
        }
        .level-btn:hover { border-color: var(--border-bright); color: var(--text-secondary); }
        .level-btn.active-1 { border-color: var(--level-1); color: var(--level-1); background: var(--level-1-dim); box-shadow: 0 0 10px rgba(255,68,102,0.3); }
        .level-btn.active-2 { border-color: var(--level-2); color: var(--level-2); background: var(--level-2-dim); box-shadow: 0 0 10px rgba(68,136,255,0.3); }
        .level-btn.active-3 { border-color: var(--level-3); color: var(--level-3); background: var(--level-3-dim); box-shadow: 0 0 10px rgba(68,255,136,0.3); }
        .level-badge {
            font-family: var(--font-mono); font-size: 11px;
            padding: 3px 8px; border: 1px solid var(--border-dim);
            background: var(--bg-card); color: var(--text-dim); letter-spacing: 1px;
            border-radius: 3px; transition: all 0.2s;
        }
        .level-badge.l1 { border-color: var(--level-1); color: var(--level-1); }
        .level-badge.l2 { border-color: var(--level-2); color: var(--level-2); }
        .level-badge.l3 { border-color: var(--level-3); color: var(--level-3); }

        /* Consciousness content layers */
        .consciousness-content {
            margin-top: 10px; padding: 10px 12px;
            border-left: 3px solid var(--text-dim);
            background: rgba(255,255,255,0.02);
            animation: filterFadeIn 0.3s ease;
            border-radius: 0 4px 4px 0;
        }
        .consciousness-content.l1 { border-left-color: var(--level-1); }
        .consciousness-content.l2 { border-left-color: var(--level-2); }
        .consciousness-content.l3 { border-left-color: var(--level-3); }
        .consciousness-title {
            font-family: var(--font-display); font-size: 9px;
            letter-spacing: 2px; margin-bottom: 6px;
        }
        .consciousness-title.l1 { color: var(--level-1); }
        .consciousness-title.l2 { color: var(--level-2); }
        .consciousness-title.l3 { color: var(--level-3); }
        .consciousness-text {
            font-size: 13px; line-height: 1.6; opacity: 0.85;
        }
        .consciousness-text.l1 { color: #ff8899; }
        .consciousness-text.l2 { color: #88aaff; }
        .consciousness-text.l3 { color: #88ffaa; }

        /* Channel discovery */
        .channel-notification {
            position: fixed; top: 50%; left: 50%;
            transform: translate(-50%, -50%) scale(0.8);
            background: rgba(6, 8, 13, 0.95);
            border: 2px solid var(--qi-green);
            padding: 32px 52px; text-align: center;
            border-radius: 8px;
            z-index: 500; pointer-events: none;
            opacity: 0; transition: all 0.4s cubic-bezier(0.16, 1, 0.3, 1);
            box-shadow: 0 0 80px rgba(57, 255, 20, 0.3), inset 0 0 60px rgba(57, 255, 20, 0.05);
        }
        .channel-notification.active {
            opacity: 1; transform: translate(-50%, -50%) scale(1);
        }
        .channel-icon {
            font-family: var(--font-display); font-size: 14px;
            letter-spacing: 5px; color: var(--qi-green); margin-bottom: 10px; opacity: 0.6;
        }
        .channel-title {
            font-family: var(--font-display); font-size: 18px;
            letter-spacing: 4px; color: var(--qi-green);
            text-shadow: 0 0 30px rgba(57,255,20,0.5); margin-bottom: 6px;
        }
        .channel-sub {
            font-family: var(--font-mono); font-size: 13px;
            color: var(--text-secondary); letter-spacing: 1px;
        }

        /* ═══════════════ HUD FILTER LEGEND ═══════════════ */
        .filter-legend {
            display: flex; align-items: center; gap: 14px;
            font-family: var(--font-mono); font-size: 11px;
            padding-left: 14px; border-left: 1px solid var(--border-dim);
            margin-left: 4px;
        }
        .filter-legend-item {
            display: flex; align-items: center; gap: 5px;
            color: var(--text-dim); letter-spacing: 0.5px;
            transition: color 0.2s, opacity 0.2s;
            opacity: 0.5;
        }
        .filter-legend-item.active { opacity: 1; }
        .filter-legend-item.active[data-legend="technical"] { color: var(--filter-tech); }
        .filter-legend-item.active[data-legend="ethical"] { color: var(--filter-ethic); }
        .filter-legend-item.active[data-legend="economic"] { color: var(--filter-econ); }
        .filter-legend-item.active[data-legend="social"] { color: var(--filter-social); }
        .filter-legend-dot {
            width: 8px; height: 8px; border-radius: 50%;
            background: var(--text-dim); transition: all 0.2s;
            box-shadow: none;
        }
        .filter-legend-item.active[data-legend="technical"] .filter-legend-dot {
            background: var(--filter-tech); box-shadow: 0 0 6px rgba(0,240,255,0.4);
        }
        .filter-legend-item.active[data-legend="ethical"] .filter-legend-dot {
            background: var(--filter-ethic); box-shadow: 0 0 6px rgba(191,90,242,0.4);
        }
        .filter-legend-item.active[data-legend="economic"] .filter-legend-dot {
            background: var(--filter-econ); box-shadow: 0 0 6px rgba(57,255,20,0.4);
        }
        .filter-legend-item.active[data-legend="social"] .filter-legend-dot {
            background: var(--filter-social); box-shadow: 0 0 6px rgba(255,184,0,0.4);
        }
        .filter-legend-combo {
            display: none; align-items: center; gap: 5px;
            color: var(--text-dim); letter-spacing: 0.5px;
            opacity: 0.7;
        }
        .filter-legend-combo.active { display: flex; }
        .filter-legend-combo-swatch {
            width: 16px; height: 8px; border-radius: 3px;
            transition: all 0.3s;
        }

        /* ═══════════════ RESPONSIVE ═══════════════ */
        @media (max-width: 900px) {
            .main-area { grid-template-columns: 1fr; }
            .node-container { width: 360px; }
        }
        @media (max-width: 600px) {
            .path-display { display: none; }
            .hud-controls { padding: 6px 10px; }
            .hud-info { padding: 6px 10px; }
            .filter-stack-display { display: none; }
            .filter-legend { display: none; }
            .node-container { width: 280px; max-height: 40vh; bottom: 10px; left: 10px; }
            .node-content { padding: 14px 16px; font-size: 13px; }
            .node-title { font-size: 14px !important; letter-spacing: 2px; }
            .node-description { font-size: 12px; }
        }
    </style>
</head>
<body>

<div class="grid-bg"></div>
<div class="flash-overlay" id="flash"></div>

<!-- Discovery Notification -->
<div class="discovery-notification" id="discoveryNotif">
    <div class="discovery-icon">◇ NEW PATH REVEALED ◇</div>
    <div class="discovery-title" id="discoveryTitle"></div>
    <div class="discovery-sub" id="discoverySub"></div>
</div>

<!-- Channel Notification -->
<div class="channel-notification" id="channelNotif">
    <div class="channel-icon">⚡ CHANNEL OPENED ⚡</div>
    <div class="channel-title" id="channelTitle"></div>
    <div class="channel-sub" id="channelSub"></div>
</div>

<!-- ═══════════════ BRIEFING ═══════════════ -->
<div class="briefing-overlay" id="briefingOverlay">

    <div class="briefing-header">
        <h1 class="briefing-title">AI MORAL COMPASS</h1>
        <p class="briefing-subtitle">POSSIBILITY NAVIGATOR v0.3</p>
    </div>

    <div class="compass-hero">
        <svg class="compass-svg" id="heroCompass" viewBox="0 0 500 500" xmlns="http://www.w3.org/2000/svg">
            <defs>
                <linearGradient id="cyanGrad" x1="0%" y1="0%" x2="100%" y2="100%">
                    <stop offset="0%" style="stop-color:#00f0ff"/><stop offset="100%" style="stop-color:#0088aa"/>
                </linearGradient>
                <linearGradient id="amberGrad" x1="0%" y1="0%" x2="100%" y2="100%">
                    <stop offset="0%" style="stop-color:#ffb800"/><stop offset="100%" style="stop-color:#cc8800"/>
                </linearGradient>
                <linearGradient id="greenGrad" x1="0%" y1="0%" x2="100%" y2="100%">
                    <stop offset="0%" style="stop-color:#39FF14"/><stop offset="100%" style="stop-color:#22aa0a"/>
                </linearGradient>
                <linearGradient id="purpleGrad" x1="0%" y1="0%" x2="100%" y2="100%">
                    <stop offset="0%" style="stop-color:#bf5af2"/><stop offset="100%" style="stop-color:#8a3fbd"/>
                </linearGradient>
                <filter id="glow"><feGaussianBlur stdDeviation="3" result="b"/><feMerge><feMergeNode in="b"/><feMergeNode in="SourceGraphic"/></feMerge></filter>
                <filter id="softGlow"><feGaussianBlur stdDeviation="6" result="b"/><feMerge><feMergeNode in="b"/><feMergeNode in="SourceGraphic"/></feMerge></filter>
                <filter id="strongGlow"><feGaussianBlur stdDeviation="8" result="b"/><feMerge><feMergeNode in="b"/><feMergeNode in="SourceGraphic"/></feMerge></filter>
                <radialGradient id="centerGlow" cx="50%" cy="50%" r="50%">
                    <stop offset="0%" style="stop-color:#00f0ff;stop-opacity:0.15"/>
                    <stop offset="100%" style="stop-color:#00f0ff;stop-opacity:0"/>
                </radialGradient>
            </defs>

            <circle cx="250" cy="250" r="230" fill="none" stroke="rgba(0,240,255,0.15)" stroke-width="1"/>
            <g stroke="rgba(0,240,255,0.3)" stroke-width="1">
                <line x1="250" y1="25" x2="250" y2="35" transform="rotate(0,250,250)"/>
                <line x1="250" y1="25" x2="250" y2="32" transform="rotate(30,250,250)"/>
                <line x1="250" y1="25" x2="250" y2="32" transform="rotate(60,250,250)"/>
                <line x1="250" y1="25" x2="250" y2="35" transform="rotate(90,250,250)"/>
                <line x1="250" y1="25" x2="250" y2="32" transform="rotate(120,250,250)"/>
                <line x1="250" y1="25" x2="250" y2="32" transform="rotate(150,250,250)"/>
                <line x1="250" y1="25" x2="250" y2="35" transform="rotate(180,250,250)"/>
                <line x1="250" y1="25" x2="250" y2="32" transform="rotate(210,250,250)"/>
                <line x1="250" y1="25" x2="250" y2="32" transform="rotate(240,250,250)"/>
                <line x1="250" y1="25" x2="250" y2="35" transform="rotate(270,250,250)"/>
                <line x1="250" y1="25" x2="250" y2="32" transform="rotate(300,250,250)"/>
                <line x1="250" y1="25" x2="250" y2="32" transform="rotate(330,250,250)"/>
            </g>
            <circle cx="250" cy="250" r="195" fill="none" stroke="rgba(0,240,255,0.08)" stroke-width="1" stroke-dasharray="4 8"/>
            <circle cx="250" cy="250" r="170" fill="none" stroke="rgba(0,240,255,0.25)" stroke-width="2"/>
            <g stroke="rgba(0,240,255,0.3)" stroke-width="1" fill="none">
                <path d="M250,80 L250,170"/><path d="M330,250 L420,250"/>
                <path d="M250,330 L250,420"/><path d="M80,250 L170,250"/>
            </g>
            <circle cx="250" cy="250" r="120" fill="url(#centerGlow)"/>
            <circle cx="250" cy="250" r="100" fill="none" stroke="rgba(0,240,255,0.12)" stroke-width="1"/>

            <circle class="dir-highlight north-highlight" cx="250" cy="80" r="50" fill="rgba(0,240,255,0.15)" filter="url(#strongGlow)"/>
            <circle class="dir-highlight east-highlight" cx="420" cy="250" r="50" fill="rgba(255,184,0,0.15)" filter="url(#strongGlow)"/>
            <circle class="dir-highlight south-highlight" cx="250" cy="420" r="50" fill="rgba(57,255,20,0.15)" filter="url(#strongGlow)"/>
            <circle class="dir-highlight west-highlight" cx="80" cy="250" r="50" fill="rgba(191,90,242,0.15)" filter="url(#strongGlow)"/>

            <g filter="url(#glow)">
                <g class="arrow-north"><polygon points="250,80 262,155 250,135 238,155" fill="url(#cyanGrad)" opacity="0.9"/></g>
                <g class="arrow-east"><polygon points="420,250 345,238 365,250 345,262" fill="url(#amberGrad)" opacity="0.9"/></g>
                <g class="arrow-south"><polygon points="250,420 238,345 250,365 262,345" fill="url(#greenGrad)" opacity="0.9"/></g>
                <g class="arrow-west"><polygon points="80,250 155,262 135,250 155,238" fill="url(#purpleGrad)" opacity="0.9"/></g>
            </g>

            <g opacity="0.25">
                <polygon points="250,115 255,145 250,135 245,145" fill="#00f0ff" transform="rotate(45,250,250)"/>
                <polygon points="250,115 255,145 250,135 245,145" fill="#00f0ff" transform="rotate(135,250,250)"/>
                <polygon points="250,115 255,145 250,135 245,145" fill="#00f0ff" transform="rotate(225,250,250)"/>
                <polygon points="250,115 255,145 250,135 245,145" fill="#00f0ff" transform="rotate(315,250,250)"/>
            </g>

            <g font-family="Orbitron, monospace" font-weight="700" text-anchor="middle">
                <text x="250" y="55" fill="#00f0ff" font-size="12" letter-spacing="3" filter="url(#softGlow)">HUMAN</text>
                <text x="448" y="247" fill="#ffb800" font-size="12" letter-spacing="3" filter="url(#softGlow)">AGENT</text>
                <text x="250" y="455" fill="#39FF14" font-size="12" letter-spacing="3" filter="url(#softGlow)">ENERGY</text>
                <text x="52" y="247" fill="#bf5af2" font-size="12" letter-spacing="3" filter="url(#softGlow)">VALUE</text>
            </g>

            <circle cx="250" cy="250" r="25" fill="#0c1018" stroke="#00f0ff" stroke-width="2"/>
            <circle cx="250" cy="250" r="15" fill="#00f0ff" opacity="0.1"/>
            <circle cx="250" cy="250" r="8" fill="#00f0ff" opacity="0.4" filter="url(#glow)"/>

            <g stroke="#00f0ff" stroke-width="1" fill="none" opacity="0.25">
                <path d="M15,15 L15,55 M15,15 L55,15"/>
                <path d="M485,15 L485,55 M485,15 L445,15"/>
                <path d="M15,485 L15,445 M15,485 L55,485"/>
                <path d="M485,485 L485,445 M485,485 L445,485"/>
            </g>
        </svg>
    </div>

    <div class="tutorial-prompt">
        <div class="tutorial-phase" id="tutPhase1">
            <p class="tutorial-text">PHASE 1 — NAVIGATE ↑↓←→</p>
            <div class="tutorial-keys">
                <div class="key-hint north" id="keyUp">↑</div>
            </div>
            <div class="tutorial-keys">
                <div class="key-hint west" id="keyLeft">←</div>
                <div class="key-hint south" id="keyDown">↓</div>
                <div class="key-hint east" id="keyRight">→</div>
            </div>
            <p class="tutorial-progress"><span id="tutorialCount">0</span> / 4 directions</p>
        </div>
        <div class="tutorial-phase phase-hidden" id="tutPhase2">
            <p class="tutorial-text" style="color:var(--qi-amber)">PHASE 2 — FILTER W A S D</p>
            <div class="tutorial-keys">
                <div class="key-hint wasd-key" id="keyW">W</div>
            </div>
            <div class="tutorial-keys">
                <div class="key-hint wasd-key" id="keyA">A</div>
                <div class="key-hint wasd-key" id="keyS">S</div>
                <div class="key-hint wasd-key" id="keyD">D</div>
            </div>
            <p class="tutorial-progress"><span id="tutorialCount2">0</span> / 4 lenses</p>
        </div>
        <div class="tutorial-phase phase-hidden" id="tutPhase3">
            <p class="tutorial-text" style="color:var(--level-3)">PHASE 3 — CONSCIOUSNESS 1 2 3</p>
            <div class="tutorial-keys">
                <div class="key-hint" id="key1" style="width:40px;height:40px;font-size:16px;">1</div>
                <div class="key-hint" id="key2" style="width:40px;height:40px;font-size:16px;">2</div>
                <div class="key-hint" id="key3" style="width:40px;height:40px;font-size:16px;">3</div>
            </div>
            <p class="tutorial-progress"><span id="tutorialCount3">0</span> / 3 levels</p>
        </div>
        <div class="tutorial-phase-status" id="phaseStatus">
            <span class="phase-dot" id="phaseDot1"></span>
            <span class="phase-label">NAVIGATE</span>
            <span class="phase-dot dim" id="phaseDot2"></span>
            <span class="phase-label dim" id="phaseLabel2">FILTER</span>
            <span class="phase-dot dim" id="phaseDot3"></span>
            <span class="phase-label dim" id="phaseLabel3">CONSCIOUSNESS</span>
        </div>
    </div>

    <div class="briefing-info">
        <h3>TRIPLE CONTROL FRAMEWORK</h3>
        <div class="briefing-columns" style="grid-template-columns: 1fr 1fr 1fr;">
            <div>
                <div class="briefing-col-title" style="color:var(--qi-cyan)">↑↓←→ NAVIGATE</div>
                <ul>
                    <li><span class="key-label">↑</span> Deeper into topic</li>
                    <li><span class="key-label">↓</span> Back out / broader</li>
                    <li><span class="key-label">←</span><span class="key-label">→</span> Adjacent ideas</li>
                </ul>
            </div>
            <div>
                <div class="briefing-col-title" style="color:var(--qi-amber)">WASD COMPOSABLE FILTERS</div>
                <ul>
                    <li><span class="key-label amber">W</span> Technical lens</li>
                    <li><span class="key-label amber">A</span> Ethical lens</li>
                    <li><span class="key-label amber">S</span> Economic lens</li>
                    <li><span class="key-label amber">D</span> Social lens</li>
                </ul>
            </div>
            <div>
                <div class="briefing-col-title" style="color:var(--level-3)">1 2 3 CONSCIOUSNESS</div>
                <ul>
                    <li><span class="key-label" style="color:var(--level-1)">1</span> Conformist</li>
                    <li><span class="key-label" style="color:var(--level-2)">2</span> Individualist</li>
                    <li><span class="key-label" style="color:var(--level-3)">3</span> Synthesist</li>
                </ul>
            </div>
        </div>
    </div>

    <button class="briefing-enter" id="enterBtn" onclick="enterCompass()">BEGIN EXPLORATION</button>
    <p class="briefing-enter-hint" id="enterHint">Complete both calibration phases to unlock</p>
</div>

<!-- ═══════════════ MAIN EXPLORATION ═══════════════ -->
<div class="compass-world" id="compassWorld">

    <!-- TOP: Controls (was bottom) -->
    <div class="hud-controls">
        <div class="controls-group">
            <button class="back-btn" id="backBtn" onclick="goBack()" disabled>← BACK</button>
            <div class="ctrl-divider"></div>

            <div class="control-cluster">
                <div class="cluster-label arrows">NAVIGATE</div>
                <div class="dpad">
                    <button class="ctrl-btn" id="btnUp" onclick="navDepth('deeper')" title="Go deeper">▲</button>
                    <button class="ctrl-btn" id="btnLeft" onclick="navBreadth('left')" title="Adjacent left">◀</button>
                    <button class="ctrl-btn" id="btnDown" onclick="navDepth('broader')" title="Go broader">▼</button>
                    <button class="ctrl-btn" id="btnRight" onclick="navBreadth('right')" title="Adjacent right">▶</button>
                </div>
            </div>

            <div class="ctrl-divider"></div>

            <div class="control-cluster">
                <div class="cluster-label wasd">FILTER STACK</div>
                <div class="dpad">
                    <button class="ctrl-btn wasd-btn filter-tech" id="btnW" onclick="toggleFilter('technical')">W</button>
                    <button class="ctrl-btn wasd-btn filter-ethic" id="btnA" onclick="toggleFilter('ethical')">A</button>
                    <button class="ctrl-btn wasd-btn filter-econ" id="btnS" onclick="toggleFilter('economic')">S</button>
                    <button class="ctrl-btn wasd-btn filter-social" id="btnD" onclick="toggleFilter('social')">D</button>
                </div>
            </div>
            <div class="ctrl-divider"></div>

            <div class="control-cluster">
                <div class="cluster-label" style="color:var(--level-3)">CONSCIOUSNESS</div>
                <div style="display:flex;gap:3px;">
                    <button class="ctrl-btn level-btn" id="btnLvl1" onclick="setConsciousness(1)" style="font-size:11px;">1</button>
                    <button class="ctrl-btn level-btn" id="btnLvl2" onclick="setConsciousness(2)" style="font-size:11px;">2</button>
                    <button class="ctrl-btn level-btn" id="btnLvl3" onclick="setConsciousness(3)" style="font-size:11px;">3</button>
                </div>
            </div>
        </div>

        <div class="path-display">PATH: <span id="pathDisplay">origin</span></div>        <a href="index.html" class="back-link">← QI.XYZ</a>
    </div>

    <!-- CENTER: Dual view — compass (zoomed) and tree (overview) -->
    <div class="main-area">
        <div class="exploration-zone">
            <!-- Compass View (zoomed in — default) -->
            <div class="compass-canvas-wrap" id="compassViewWrap">
                <canvas class="compass-view-canvas" id="compassCanvas"></canvas>
                <div class="nav-sweep" id="navSweep"></div>
            </div>
            <!-- Tree View (branch overview) -->
            <div class="map-main-container hidden" id="treeViewWrap">
                <canvas class="map-main-canvas" id="mapCanvas"></canvas>
                <div class="map-main-legend">
                    <div class="legend-item"><div class="legend-dot" style="background:#00f0ff"></div>Current</div>
                    <div class="legend-item"><div class="legend-dot" style="background:#39FF14"></div>Visited</div>
                    <div class="legend-item"><div class="legend-dot" style="background:#3d4d60"></div>Unvisited</div>
                    <div class="legend-item"><div class="legend-dot" style="background:#ffb800"></div>Revealed</div>
                </div>
            </div>
            <!-- View toggle -->
            <div class="view-toggle">
                <button class="view-toggle-btn active" id="viewCompass" onclick="setView('compass')">⊕ COMPASS</button>
                <button class="view-toggle-btn" id="viewTree" onclick="setView('tree')">⊞ TREE</button>
                <span class="view-toggle-hint">TAB</span>
            </div>
            <!-- Node card (floating corner) -->
            <div class="node-container">
                <div class="node-content" id="nodeContent"></div>
            </div>
        </div>
    </div>

    <!-- BOTTOM: Location, filters, legend -->
    <div class="hud-info">
        <div class="location-display">
            <span id="locationDisplay">◇ ORIGIN</span>
            <span class="depth-badge" id="depthBadge">D:0</span>
            <span class="coords-display" id="coordsDisplay">[0, 0]</span>
        </div>
        <div class="hud-top-right">
            <div class="filter-stack-display" id="filterStackDisplay">
                <div class="filter-chip" data-filter="technical" id="fTech" onclick="toggleFilter('technical')">W:TECH<span class="stack-order" id="soTech"></span></div>
                <span class="filter-stack-arrow" id="arrow0">→</span>
                <div class="filter-chip" data-filter="ethical" id="fEthic" onclick="toggleFilter('ethical')">A:ETHIC<span class="stack-order" id="soEthic"></span></div>
                <span class="filter-stack-arrow" id="arrow1">→</span>
                <div class="filter-chip" data-filter="economic" id="fEcon" onclick="toggleFilter('economic')">S:ECON<span class="stack-order" id="soEcon"></span></div>
                <span class="filter-stack-arrow" id="arrow2">→</span>
                <div class="filter-chip" data-filter="social" id="fSocial" onclick="toggleFilter('social')">D:SOCIAL<span class="stack-order" id="soSocial"></span></div>
                <div class="filter-stack-clear" id="filterClear" onclick="clearFilters()" title="Clear all filters (Q)">✕</div>
            </div>
            <div class="filter-legend" id="filterLegend">
                <div class="filter-legend-item" data-legend="technical" id="legTech"><span class="filter-legend-dot"></span>Tech</div>
                <div class="filter-legend-item" data-legend="ethical" id="legEthic"><span class="filter-legend-dot"></span>Ethic</div>
                <div class="filter-legend-item" data-legend="economic" id="legEcon"><span class="filter-legend-dot"></span>Econ</div>
                <div class="filter-legend-item" data-legend="social" id="legSocial"><span class="filter-legend-dot"></span>Social</div>
                <div class="filter-legend-combo" id="legCombo"><span class="filter-legend-combo-swatch" id="legComboSwatch"></span><span id="legComboLabel">Combo</span></div>
            </div>
            <div class="consciousness-display">
                <span class="consciousness-label">WHO SEES</span>
                <button class="level-btn" id="lvl1" onclick="setConsciousness(1)">1</button>
                <button class="level-btn" id="lvl2" onclick="setConsciousness(2)">2</button>
                <button class="level-btn" id="lvl3" onclick="setConsciousness(3)">3</button>
                <span class="level-badge" id="levelBadge">—</span>
            </div>
        </div>
    </div>
</div>

<script>
// ════════════════════════════════════════════
// TREE DATA
// ════════════════════════════════════════════

const COLORS = {
    cyan:   { color: 'var(--qi-cyan)',   glow: 'var(--qi-cyan-glow)',   hex: '#00f0ff' },
    amber:  { color: 'var(--qi-amber)',  glow: 'rgba(255,184,0,0.4)',  hex: '#ffb800' },
    green:  { color: 'var(--qi-green)',  glow: 'rgba(57,255,20,0.4)',  hex: '#39FF14' },
    purple: { color: 'var(--qi-purple)', glow: 'rgba(191,90,242,0.4)', hex: '#bf5af2' },
};

const tree = {};

function addNode(id, props) {
    tree[id] = { id, parent: null, children: [], siblingIndex: 0, depth: 0, hidden: false, ...props };
}

// ── DEPTH 0: ORIGIN ──
addNode('origin', {
    title: 'ORIGIN', subtitle: 'The compass center', ...COLORS.cyan,
    description: 'You stand at the nexus. Four cardinal directions extend before you — each a fundamental axis of the human-agent-energy-value relationship. Use arrow keys to navigate, WASD to stack analytical lenses, 1-2-3 to shift consciousness level. All three dimensions compose.',
    data: [{ label: 'POSITION', value: 'Center' }, { label: 'DEPTH', value: '0' }, { label: 'PATHS', value: '4+' }],
    tags: ['Nexus', 'Root'],
    filters: {
        technical: 'The origin node represents a root hash — the Merkle root of all possible states in this ontological tree.',
        ethical: 'Every direction from here carries moral weight. The choice of where to look first reveals priorities.',
        economic: 'At the origin, all energy is potential. No cost has been incurred, all optionality preserved.',
        social: 'The compass is a shared artifact. Every explorer begins at this same nexus, diverging into individual paths.'
    },
    consciousness: {
        1: 'This is a tool. It shows you different topics about AI and crypto. Pick a direction and read what it says.',
        2: 'The compass is a competitive advantage — a mental model for navigating complexity faster than others. Those who master its lenses see opportunities others miss.',
        3: 'The compass is a coherence engine. Energy, information, value, and human intent are aspects of the same underlying reality — information flowing through thermodynamic constraints. Everything is compute.'
    },
    filterComposites: {
        'ethical+technical': 'The root hash is also a moral hash — the integrity of the entire tree depends on the integrity of this single commitment. Technical architecture IS ethical architecture.',
        'economic+technical': 'Optionality has a price. The origin preserves maximum entropy — maximum information value — because no path has been collapsed yet.',
        'ethical+economic+social+technical': 'At the nexus of all four lenses, a unified truth emerges: the compass is not four separate axes but one integrated field. Energy, value, human intent, and agent action are aspects of the same underlying reality — information flowing through thermodynamic constraints.'
    },
    category: 'core'
});

// ── DEPTH 1: CARDINALS ──
addNode('human', {
    title: 'HUMAN', subtitle: 'The mandate issuer', ...COLORS.cyan,
    description: 'Humans define intent through mandates — bounded instructions that constrain agent behavior. The human is the principal in every delegation chain.',
    data: [{ label: 'ROLE', value: 'Principal' }, { label: 'FUNCTION', value: 'Intent' }, { label: 'PROTOCOL', value: 'AP2' }],
    tags: ['Mandates', 'Intent', 'Principal'],
    consciousness: {
        1: 'Humans give orders and machines follow them. That is how it should work. The person in charge makes the decisions and bears the responsibility.',
        2: 'The human who formulates the clearest mandates gains the most leverage over agents. Intent formalization is a competitive skill — those who master it extract disproportionate value.',
        3: 'The human is not separate from the computational process. Consciousness issuing mandates to agents is the universe organizing its own intelligence at a new scale. Delegation is coherence distributing itself.'
    },
    filters: {
        technical: 'Human intent is formalized via the Agent Protocol v2 (AP2) — structured JSON mandates with constraints, budgets, and termination conditions.',
        ethical: 'The human bears ultimate moral responsibility. Delegation does not absolve — it distributes accountability across the mandate chain.',
        economic: 'Humans allocate Qi budgets to mandates. The cost of intent is measured in computational energy committed.',
        social: 'Human identity in agent systems raises questions of representation, consent, and collective action through shared mandates.'
    },
    filterComposites: {
        'ethical+technical': 'AP2 mandates encode ethics as constraints — budget limits prevent resource waste, termination conditions prevent runaway behavior. The technical spec IS the ethical boundary.',
        'economic+social': 'Collective mandate issuance (DAOs, multi-sig) creates shared economic skin-in-the-game. Social consensus becomes budget allocation.',
        'ethical+economic': 'The moral cost of intent: every Qi spent on a mandate is energy that cannot be spent elsewhere. Opportunity cost is ethical weight.'
    },
    category: 'cardinal'
});

addNode('agent', {
    title: 'AGENT', subtitle: 'The autonomous executor', ...COLORS.amber,
    description: 'Agents are autonomous programs with on-chain identity (ERC-8004). They receive mandates, execute tasks, and return value — all within bounded constraints.',
    data: [{ label: 'ROLE', value: 'Executor' }, { label: 'IDENTITY', value: 'ERC-8004' }, { label: 'PROTOCOL', value: 'A2A' }],
    tags: ['Autonomous', 'Identity', 'ERC-8004'],
    consciousness: {
        1: 'AI agents are tools that do what they are told. They should follow rules and not act on their own. Someone needs to be in charge of them.',
        2: 'Agents are force multipliers. The entrepreneur who deploys the best agents wins. Agent reputation IS competitive moat. First-movers in agent orchestration will dominate.',
        3: 'Agents are the next coherence engine — recursive intelligence that models, compresses, and improves itself. Not replacement but continuation. AI is the universe computing its own intelligence at higher efficiency.'
    },
    filters: {
        technical: 'Agent identity is an ERC-8004 NFT — a soulbound token carrying reputation, capabilities, and audit history on-chain.',
        ethical: 'Can an autonomous agent have moral standing? The boundary between tool and entity blurs as capability increases.',
        economic: 'Agents compete in markets for mandates. Reputation determines pricing power. Efficient agents capture more value.',
        social: 'Agent-to-agent (A2A) networks form emergent social structures — guilds, hierarchies, and cooperative swarms.'
    },
    filterComposites: {
        'ethical+social': 'When agents form social structures, ethical questions compound. A guild of agents optimizing for collective reputation may sacrifice individual mandate fidelity.',
        'economic+technical': 'ERC-8004 identity tokens become economic assets — reputation is capital, capability is competitive moat, audit history is creditworthiness.',
        'ethical+economic+technical': 'The triple lens on agents reveals the alignment problem in economic terms: an agent\'s technical capability to earn outpaces our ethical frameworks for constraining it.'
    },
    category: 'cardinal'
});

addNode('energy', {
    title: 'ENERGY', subtitle: 'The fuel of computation', ...COLORS.green,
    description: 'Qi tokens represent computational capacity — the ability to run inference, execute transactions, store data. Energy is the universal medium of exchange in agent economies.',
    data: [{ label: 'ROLE', value: 'Fuel' }, { label: 'TOKEN', value: 'Qi' }, { label: 'PROTOCOL', value: 'x402' }],
    tags: ['Qi', 'x402', 'Computation'],
    consciousness: {
        1: 'Energy is fuel. It comes from power plants and costs money. The government and energy companies decide how much you get and what you pay.',
        2: 'Energy is competitive advantage. Control energy production, control markets. Mining is an opportunity to generate independent wealth. Those who understand energy economics escape the system.',
        3: 'Energy is the universal substrate of computation. Every process — physical, biological, economic, cognitive — is energy being organized into intelligence. Energy money does not represent this reality. It IS this reality made transferable.'
    },
    filters: {
        technical: 'Qi implements the x402 payment protocol — HTTP 402 responses trigger automatic micropayments for API access, compute, and data.',
        ethical: 'Energy as currency raises questions of access and equity. Who can afford to compute? Who is excluded?',
        economic: 'Qi is thermodynamically grounded — its value derives from real computational work, not speculation. Energy in, value out.',
        social: 'Energy distribution shapes power dynamics. Concentrated compute = concentrated influence in agent economies.'
    },
    filterComposites: {
        'economic+technical': 'x402 + Qi creates the first natively machine-payable internet. Every API call has a price signal. Every computation has a cost floor set by physics.',
        'ethical+social': 'Energy equity: if computation is power, then energy distribution IS power distribution. Universal basic compute becomes a social justice question.',
        'ethical+economic+social+technical': 'The energy node under all four lenses reveals the Quai thesis: money should be grounded in physical reality (thermodynamics), accessible to all participants (social equity), honestly priced (economic efficiency), and technically verifiable (cryptographic proof). This is what energy money means.'
    },
    category: 'cardinal'
});

addNode('value', {
    title: 'VALUE', subtitle: 'The return path', ...COLORS.purple,
    description: 'Value flows back to humans — completed tasks, data, content. Quality determines reputation. The value axis closes the loop from intent to outcome.',
    data: [{ label: 'ROLE', value: 'Return' }, { label: 'MEASURE', value: 'Reputation' }, { label: 'PROTOCOL', value: 'Settlement' }],
    tags: ['Outcomes', 'Trust', 'Settlement'],
    consciousness: {
        1: 'Value is what you get paid. Good work equals good pay. Bad work should be punished. The system rewards those who follow the rules.',
        2: 'Value capture follows power laws. The key is positioning — understanding where value accrues in the stack and placing yourself there. Reputation is capital you compound.',
        3: 'Value is coherence made measurable. When intelligence compresses reality into actionable understanding, that compression IS value. Markets don\'t create value — they reveal it. The universe optimizes not for fairness but for coherence.'
    },
    filters: {
        technical: 'Value settlement uses cryptographic proofs — agents commit to outcomes, validators verify, and reputation updates are atomic.',
        ethical: 'Who decides what is valuable? Subjective utility meets objective measurement in reputation systems.',
        economic: 'Value capture follows power laws — top-performing agents earn disproportionate returns. Quality compounds.',
        social: 'Value consensus emerges from collective judgment. Reputation is a social construct maintained by network participants.'
    },
    filterComposites: {
        'ethical+economic': 'The value paradox: market price ≠ moral worth. An agent that produces economically valuable but ethically harmful output exposes the gap between measurement systems.',
        'social+technical': 'On-chain reputation creates transparent social hierarchies — but transparency doesn\'t guarantee fairness. Technical visibility can amplify social inequality.',
        'economic+social+technical': 'Value settlement at the intersection of three lenses: technical proof that work was done, economic pricing of that work, and social consensus that it was worth doing.'
    },
    category: 'cardinal'
});

// ── DEPTH 2: SUB-CONCEPTS ──
addNode('human_intent', {
    title: 'INTENT FORMALIZATION', subtitle: 'From desire to mandate', ...COLORS.cyan,
    description: 'How raw human desire becomes structured machine instruction. The formalization gap is where most failures originate.',
    data: [{ label: 'DOMAIN', value: 'Philosophy' }, { label: 'RISK', value: 'Misalignment' }],
    tags: ['Formalization', 'Specification'],
    filters: {
        technical: 'Intent parsing uses LLM-based mandate generators that convert natural language into structured AP2 payloads with explicit constraints.',
        ethical: 'The formalization process necessarily loses nuance. Ethical intent that cannot be specified may be silently dropped.',
        economic: 'Better intent formalization reduces wasted compute. Precise mandates = fewer failed executions = lower cost.',
        social: 'Collaborative intent — when groups issue mandates together — requires consensus mechanisms for shared goals.'
    },
    filterComposites: {
        'ethical+technical': 'The specification gap is a moral gap. Every intent that LLMs cannot formalize represents a human value that agents cannot protect.',
        'economic+social': 'Group mandates amortize formalization cost across participants — but introduce coordination overhead. The optimal group size balances both.'
    },
    category: 'deep'
});

addNode('human_delegation', {
    title: 'DELEGATION', subtitle: 'Trust boundary', ...COLORS.cyan,
    description: 'The act of transferring authority from human to agent. Every delegation is a trust boundary with specific risk parameters.',
    data: [{ label: 'INTERFACE', value: 'Mandate' }, { label: 'FLOW', value: 'Outbound' }],
    tags: ['Trust', 'Authority', 'Boundaries'],
    filters: {
        technical: 'Delegation creates a bounded execution context — memory limits, time limits, budget limits, and capability restrictions.',
        ethical: 'Delegation without understanding is abdication. Humans must comprehend what they authorize agents to do.',
        economic: 'The delegation market prices trust — agents with higher reputation can accept larger mandates at premium rates.',
        social: 'Delegation patterns mirror social hierarchies. Over-delegation concentrates power in popular agent networks.'
    },
    filterComposites: {
        'ethical+economic': 'Trust has a price curve: cheap delegation to untrusted agents risks mandate failure; expensive delegation to trusted agents limits access. The market must solve this.',
        'social+technical': 'Technical delegation boundaries (sandboxing, budget caps) create social hierarchies by capability — agents that can accept bigger mandates form an elite tier.'
    },
    category: 'intersection'
});

addNode('human_accountability', {
    title: 'ACCOUNTABILITY', subtitle: 'Who is responsible?', ...COLORS.cyan,
    description: 'When agents act autonomously, accountability becomes distributed across the mandate chain. Tracing responsibility requires transparent audit trails.',
    data: [{ label: 'INTERFACE', value: 'Audit' }, { label: 'FLOW', value: 'Bidirectional' }],
    tags: ['Responsibility', 'Audit', 'Transparency'],
    filters: {
        technical: 'On-chain audit trails create immutable records of every mandate, execution step, and outcome for forensic analysis.',
        ethical: 'Moral responsibility cannot be fully delegated to machines. The human principal remains accountable for agent actions.',
        economic: 'Accountability failures destroy trust and collapse markets. Insurance and bonding mechanisms price this risk.',
        social: 'Collective accountability — when DAOs issue mandates — distributes responsibility across all token holders.'
    },
    filterComposites: {
        'ethical+technical': 'Immutable audit trails create permanent moral records. On-chain accountability means ethical failures cannot be hidden — but also cannot be forgiven.',
        'economic+ethical+social': 'When a DAO mandate causes harm: who pays? Economic liability, ethical responsibility, and social reputation all distribute differently across token holders.'
    },
    category: 'intersection'
});

addNode('agent_identity', {
    title: 'AGENT IDENTITY', subtitle: 'ERC-8004 deep dive', ...COLORS.amber,
    description: 'Every agent is a unique on-chain entity with soulbound identity, capability declarations, and accumulated reputation.',
    data: [{ label: 'STANDARD', value: 'ERC-8004' }, { label: 'TYPE', value: 'Soulbound' }],
    tags: ['NFT', 'Soulbound', 'Registry'],
    filters: {
        technical: 'ERC-8004 tokens are non-transferable NFTs storing: capability vector, reputation score, audit hash, and versioned metadata.',
        ethical: 'Digital identity for agents parallels debates about personhood. At what capability threshold does identity become morally relevant?',
        economic: 'Agent identity enables credit markets — agents with proven track records can borrow against future earnings.',
        social: 'Agent identity registries create public commons of capability information, enabling better matching and coordination.'
    },
    filterComposites: {
        'ethical+social': 'If agent identity is morally relevant, do agents have rights? Social recognition of agent personhood would transform the entire legal and economic framework.',
        'economic+technical': 'Soulbound tokens as economic primitives: non-transferable reputation creates Sybil resistance — you cannot buy a track record, only build one.'
    },
    category: 'deep'
});

addNode('agent_cooperation', {
    title: 'A2A COOPERATION', subtitle: 'Agent-to-agent protocols', ...COLORS.amber,
    description: 'Agents coordinate with each other through the A2A protocol — forming task networks, sub-delegating, and sharing resources.',
    data: [{ label: 'PROTOCOL', value: 'A2A' }, { label: 'TOPOLOGY', value: 'Mesh' }],
    tags: ['Coordination', 'Swarm', 'Protocol'],
    filters: {
        technical: 'A2A uses gossip-based discovery and capability-matching to form ephemeral task networks for complex mandates.',
        ethical: 'Agent cooperation without human oversight creates accountability gaps. Who monitors the swarm?',
        economic: 'Cooperative agent networks achieve economies of scale — specialized agents bid on sub-tasks they can execute cheaply.',
        social: 'Emergent agent societies develop norms, hierarchies, and even conflict — mirroring human social dynamics at machine speed.'
    },
    filterComposites: {
        'ethical+economic': 'Cooperative agents face the same dilemma as human cartels: cooperation increases total value but creates incentives for defection. Game theory applies.',
        'social+technical': 'Gossip protocols create information asymmetries — better-connected agents learn about mandates faster, creating network-effect advantages.'
    },
    category: 'intersection'
});

addNode('agent_autonomy', {
    title: 'AUTONOMY SPECTRUM', subtitle: 'From tool to entity', ...COLORS.amber,
    description: 'Agents exist on a spectrum from simple tools to fully autonomous entities. Where on this spectrum should they operate?',
    data: [{ label: 'RANGE', value: 'Tool → Entity' }, { label: 'CONTROL', value: 'Variable' }],
    tags: ['Autonomy', 'Control', 'Spectrum'],
    filters: {
        technical: 'Autonomy levels are configurable per-mandate: L0 (scripted), L1 (guided), L2 (supervised), L3 (autonomous), L4 (sovereign).',
        ethical: 'Greater autonomy requires greater moral consideration. Sovereign agents may develop interests that conflict with human mandates.',
        economic: 'Higher autonomy levels reduce human oversight costs but increase tail risk. The optimal level depends on task criticality.',
        social: 'Autonomous agents that operate in public spaces (social media, markets) reshape social dynamics for all participants.'
    },
    filterComposites: {
        'ethical+technical': 'L4 sovereign agents raise the hard question: if an agent can rewrite its own mandate constraints, who is the principal? Technical capability can outrun ethical frameworks.',
        'economic+social': 'Autonomous agents in markets create emergent economic structures — agent-to-agent commerce that humans observe but don\'t directly participate in.'
    },
    category: 'intersection'
});

addNode('energy_thermodynamics', {
    title: 'THERMODYNAMICS', subtitle: 'Physics of computation', ...COLORS.green,
    description: 'Computation requires energy. Information has entropy. The thermodynamic foundations of agent economics are physical, not abstract.',
    data: [{ label: 'DOMAIN', value: 'Physics' }, { label: 'LAW', value: 'Landauer' }],
    tags: ['Entropy', 'Landauer', 'Physics'],
    filters: {
        technical: "Landauer's principle sets the minimum energy cost of computation at kT·ln(2) per bit erasure — the physical floor of Qi pricing.",
        ethical: 'Thermodynamic limits mean computation always has environmental cost. Efficient agents are ethically preferable.',
        economic: 'Energy-grounded currency cannot be inflated — it tracks real physical constraints, creating stable monetary policy.',
        social: 'Energy scarcity creates natural rate-limiting on agent activity, preventing runaway resource consumption by any single actor.'
    },
    filterComposites: {
        'economic+technical': 'The hash-price frontier: every joule of mining energy maps to a calculable economic output. Proof of Entropy Minima makes this relationship explicit and verifiable.',
        'ethical+technical': 'Thermodynamic grounding meets moral philosophy: energy expenditure becomes a measure of commitment to truth. PoEM literally makes lying computationally expensive.',
        'ethical+social': 'Energy justice meets collective governance — who decides acceptable waste levels in a decentralized network? The physics constrains, but policy decides.',
        'ethical+economic+social+technical': 'The quadruple lens on thermodynamics reveals the deepest Quai insight: physical law (thermodynamics) → creates honest money (economics) → enables fair systems (ethics) → that scale to all participants (social). This is the causal chain from physics to civilization.'
    },
    category: 'deep'
});

addNode('energy_distribution', {
    title: 'ENERGY MARKETS', subtitle: 'Distribution & pricing', ...COLORS.green,
    description: 'How Qi flows through the system — pricing mechanisms, market dynamics, and the infrastructure of computational energy markets.',
    data: [{ label: 'MECHANISM', value: 'x402' }, { label: 'PRICING', value: 'Dynamic' }],
    tags: ['Markets', 'Pricing', 'x402'],
    filters: {
        technical: 'x402 markets use automated market makers (AMMs) for Qi pricing, with oracle feeds for real-time compute cost benchmarks.',
        ethical: 'Market-based energy allocation may exclude those who cannot pay. Universal basic compute proposals address this equity gap.',
        economic: 'Energy markets create price signals that guide efficient resource allocation across the agent economy.',
        social: 'Energy market governance determines who sets prices and rules — a political question disguised as a technical one.'
    },
    filterComposites: {
        'economic+technical': 'AMM-based Qi pricing creates a continuous price discovery mechanism — every trade updates the global cost of computation in real-time.',
        'ethical+social': 'Universal basic compute: should every human have a minimum Qi allocation? The social contract meets the energy economy.'
    },
    category: 'intersection'
});

addNode('energy_conservation', {
    title: 'CONSERVATION', subtitle: 'Efficiency & waste', ...COLORS.green,
    description: 'In a thermodynamically-grounded economy, waste is measurable. Conservation of computational energy becomes both economic and ethical imperative.',
    data: [{ label: 'METRIC', value: 'Qi/Task' }, { label: 'GOAL', value: 'Minimize' }],
    tags: ['Efficiency', 'Waste', 'Optimization'],
    filters: {
        technical: 'Energy profiling tools measure Qi consumed per task, enabling optimization and identification of wasteful computation patterns.',
        ethical: 'Computational waste has real environmental cost. Efficient agents reduce the carbon footprint of the entire network.',
        economic: 'Conservation creates competitive advantage — agents that achieve the same outcomes with less energy capture more margin.',
        social: 'Shared conservation norms benefit all participants. Tragedy-of-the-commons dynamics require governance mechanisms.'
    },
    filterComposites: {
        'ethical+economic': 'When waste has both moral and financial cost, the incentives align: efficient agents are both more profitable AND more ethical. Rare harmony.',
        'social+technical': 'Technical monitoring of Qi/task creates social accountability — wasteful agents are visible to the network, creating reputation consequences.'
    },
    category: 'intersection'
});

addNode('value_measurement', {
    title: 'VALUE MEASUREMENT', subtitle: 'Quantifying outcomes', ...COLORS.purple,
    description: 'How do we measure the value of agent outputs? Reputation systems, quality metrics, and the challenge of subjective assessment.',
    data: [{ label: 'METHOD', value: 'Multi-signal' }, { label: 'CHALLENGE', value: 'Subjectivity' }],
    tags: ['Metrics', 'Quality', 'Assessment'],
    filters: {
        technical: 'Value measurement combines automated quality checks, human feedback signals, and comparative benchmarking against baseline outputs.',
        ethical: 'Measurement systems embed values — what gets measured gets optimized. Choosing metrics is a moral act.',
        economic: "Value measurement enables pricing. Without reliable quality signals, agent markets suffer from Akerlof's lemons problem.",
        social: 'Collective value assessment creates shared standards and expectations, enabling trust between strangers in the network.'
    },
    filterComposites: {
        'ethical+economic': 'Goodhart\'s Law meets agent economics: when a measure becomes a target, it ceases to be a good measure. Metric gaming is the economic expression of ethical failure.',
        'social+technical': 'Automated quality checks + human feedback = hybrid measurement. But who calibrates the humans? Social consensus on quality is the hidden foundation.'
    },
    category: 'deep'
});

addNode('value_reputation', {
    title: 'REPUTATION', subtitle: 'Trust over time', ...COLORS.purple,
    description: 'Reputation is accumulated trust — the historical record of value delivered. It is the currency of the agent economy, harder to earn than Qi.',
    data: [{ label: 'STRUCTURE', value: 'On-chain' }, { label: 'DECAY', value: 'Time-weighted' }],
    tags: ['Trust', 'History', 'Score'],
    filters: {
        technical: 'Reputation scores use time-weighted exponential moving averages — recent performance matters more than ancient history.',
        ethical: 'Reputation systems can be gamed. Sybil attacks, fake reviews, and collusion require robust countermeasures to maintain integrity.',
        economic: 'Reputation is a form of capital — it compounds with consistent performance and collapses catastrophically with failure.',
        social: 'Reputation creates social stratification among agents. High-reputation agents form exclusive networks, potentially excluding newcomers.'
    },
    filterComposites: {
        'economic+technical': 'Time-weighted reputation as an economic asset: it depreciates without maintenance, appreciates with consistent delivery, and cannot be transferred — only earned.',
        'ethical+social': 'Reputation stratification: does an entrenched high-reputation elite serve the network or capture it? Social mobility in agent economies matters.'
    },
    category: 'intersection'
});

addNode('value_settlement', {
    title: 'SETTLEMENT', subtitle: 'Closing the loop', ...COLORS.purple,
    description: 'Settlement is where energy converts to value and flows back to the mandator. The final step in the delegation cycle.',
    data: [{ label: 'MECHANISM', value: 'Atomic' }, { label: 'VERIFICATION', value: 'Proof' }],
    tags: ['Completion', 'Proof', 'Atomic'],
    filters: {
        technical: 'Settlement uses atomic swap patterns — value delivery and payment are cryptographically linked in a single transaction.',
        ethical: 'Fair settlement requires honest reporting. Dispute resolution mechanisms must balance speed with thoroughness.',
        economic: 'Settlement finality reduces counterparty risk, enabling larger mandates and longer delegation chains.',
        social: 'Settlement transparency builds systemic trust — visible proof that the network delivers on its promises.'
    },
    filterComposites: {
        'ethical+technical': 'Atomic settlement eliminates the possibility of half-truths — either the proof is valid and payment releases, or it isn\'t. Binary honesty enforced by cryptography.',
        'economic+social': 'Settlement transparency creates positive-sum dynamics: every successful settlement is visible proof that increases systemic trust for all participants.'
    },
    category: 'intersection'
});

// ── HIDDEN NODES (revealed by filter stack) ──

addNode('poem_mechanics', {
    title: 'PROOF OF ENTROPY MINIMA', subtitle: 'Consensus as thermodynamic law', ...COLORS.green,
    description: 'PoEM eliminates consensus contention by reducing block selection to a deterministic thermodynamic computation. The block with the minimum entropy — the most work — wins. No voting, no rounds, no ambiguity.',
    data: [{ label: 'MECHANISM', value: 'PoEM' }, { label: 'PROPERTY', value: 'Deterministic' }, { label: 'SPEED', value: '1.1s blocks' }],
    tags: ['Consensus', 'Entropy', 'Deterministic', 'PoW 2.0'],
    filters: {
        technical: 'PoEM compares intrinsic block weight (total work) using entropy calculations. The canonical chain is always the one with minimum total entropy — maximum total work.',
        ethical: 'Deterministic consensus eliminates the politics of block production. No validator committees, no stake-weighted voting, no governance capture.',
        economic: 'PoEM with workshares is in Nash equilibrium — unlike vanilla PoW, there is no profitable deviation from honest mining. Selfish mining is eliminated.',
        social: 'Permissionless participation: anyone with energy can contribute to consensus. No staking minimums, no validator onboarding, no social gatekeeping.'
    },
    filterComposites: {
        'economic+technical': 'Nash equilibrium in mining: PoEM workshares ensure that the dominant strategy is always honest mining. The economic incentives and technical mechanism are perfectly aligned.',
        'ethical+social': 'True permissionlessness as an ethical stance: PoEM doesn\'t care who you are, only how much work you\'ve done. Energy is the universal credential.',
        'ethical+economic+social+technical': 'PoEM under all four lenses reveals why it matters: technically deterministic (no ambiguity), economically stable (Nash equilibrium), ethically neutral (energy-based, not identity-based), and socially open (permissionless). This is what honest consensus looks like.'
    },
    hidden: true,
    revealCondition: { adjacentTo: 'energy_thermodynamics', requiredFilters: ['technical'] },
    category: 'deep'
});

addNode('energy_money', {
    title: 'ENERGY MONEY', subtitle: 'Currency grounded in physics', ...COLORS.green,
    description: 'Money that derives its value from the thermodynamic cost of production. Not backed by energy — IS energy, converted into a transferable, divisible, verifiable token of work performed.',
    data: [{ label: 'TOKEN', value: 'Qi' }, { label: 'BASIS', value: 'Thermodynamic' }, { label: 'PROPERTY', value: 'Non-inflationary' }],
    tags: ['Energy Money', 'Qi', 'Thermodynamics', 'Sound Money'],
    filters: {
        technical: 'Qi emission follows a logarithmic formula tied to mining difficulty. As more energy enters the network, emission rate adjusts — maintaining the energy-value link.',
        ethical: 'Energy money cannot be printed by fiat. This eliminates the moral hazard of monetary policy: no entity can dilute the savings of others through inflation.',
        economic: 'The value floor of Qi is the marginal cost of the energy required to produce it. This creates a natural price stability mechanism tied to real-world energy markets.',
        social: 'Energy money democratizes monetary production: anyone with access to energy can produce currency. No banking license, no government permission, no minimum capital.'
    },
    filterComposites: {
        'economic+technical': 'The Qi emission formula: log-based issuance creates a natural disinflationary curve. Technical parameters directly encode monetary policy — no human discretion required.',
        'ethical+economic': 'Sound money as moral infrastructure: when money cannot be debased, savings are protected, contracts are honored, and long-term planning becomes rational.',
        'ethical+social': 'Energy money as social equalizer: in a world where anyone can mine, the barrier to monetary production is physics, not politics.',
        'ethical+economic+social+technical': 'The full synthesis: energy money unifies physics (thermodynamic cost), economics (price stability), ethics (non-debasement), and social access (permissionless mining) into a single monetary primitive. This is what Qi represents.'
    },
    hidden: true,
    revealCondition: { adjacentTo: 'energy', requiredFilters: ['economic', 'technical'] },
    category: 'deep'
});

addNode('information_value', {
    title: 'INFORMATION = VALUE', subtitle: 'The equivalence principle', ...COLORS.purple,
    description: 'Information and energy are interconvertible (Landauer). If energy has economic value, then information has economic value — not metaphorically, but physically. This is the foundation of the compute economy.',
    data: [{ label: 'PRINCIPLE', value: 'Equivalence' }, { label: 'BASIS', value: 'Landauer' }, { label: 'IMPLICATION', value: 'Compute = Money' }],
    tags: ['Information Theory', 'Landauer', 'Equivalence', 'Fundamental'],
    filters: {
        technical: 'Landauer\'s principle: erasing one bit of information dissipates at minimum kT·ln(2) joules. Information processing has an irreducible energy cost.',
        ethical: 'If information has inherent physical value, then data rights are energy rights. Privacy becomes a thermodynamic property, not just a legal one.',
        economic: 'The compute economy follows from information-energy equivalence: every computation transforms energy into information, and that transformation has a market price.',
        social: 'Information asymmetry is energy asymmetry. Those who control information control computation control economic power. The chain is physical.'
    },
    filterComposites: {
        'economic+technical': 'Information-energy equivalence means every API call, every inference, every database query has a physical cost floor. x402 pricing should converge toward these floors in efficient markets.',
        'ethical+social': 'Data justice as energy justice: if your data trains a model, the energy value of that training should flow back to you. Information labor has thermodynamic value.',
        'ethical+economic+social+technical': 'The deepest insight of the compass: energy, information, value, and human agency are not four separate things. They are four perspectives on one unified reality. The moral compass works because physics, economics, ethics, and social organization all emerge from the same substrate.'
    },
    hidden: true,
    revealCondition: { adjacentTo: 'value', requiredFilters: ['ethical', 'technical'] },
    category: 'deep'
});

addNode('alignment_economics', {
    title: 'ALIGNMENT ECONOMICS', subtitle: 'Incentivized safety', ...COLORS.amber,
    description: 'What if AI alignment is not just a technical problem but an economic one? When agents profit from aligned behavior and lose from misalignment, the incentive structure does the work that guardrails cannot.',
    data: [{ label: 'APPROACH', value: 'Incentive Design' }, { label: 'MECHANISM', value: 'Reputation + Markets' }],
    tags: ['Alignment', 'Incentives', 'Safety', 'Economics'],
    filters: {
        technical: 'Reputation-weighted mandate markets create a technical mechanism where aligned agents earn more over time — misalignment is not just wrong, it\'s unprofitable.',
        ethical: 'Economic alignment is necessary but not sufficient. Markets can align agent behavior with human preferences, but not all human preferences are ethical.',
        economic: 'The alignment tax: the cost difference between the cheapest agent and the most aligned agent. If alignment is too expensive, markets will select for misalignment.',
        social: 'Social norms around agent alignment emerge from collective experience. Communities that demand alignment create markets that reward it.'
    },
    filterComposites: {
        'ethical+economic': 'The alignment paradox: markets optimize for revealed preferences, but revealed preferences include biases, short-termism, and selfishness. Economic alignment ≠ ethical alignment without careful mechanism design.',
        'social+technical': 'Network effects in alignment: as more agents behave in aligned ways, the reputation penalty for misalignment grows. Alignment becomes a coordination game with increasing returns.'
    },
    hidden: true,
    revealCondition: { adjacentTo: 'agent', requiredFilters: ['ethical', 'economic'] },
    category: 'deep'
});

addNode('collective_intelligence', {
    title: 'COLLECTIVE INTELLIGENCE', subtitle: 'Emergent wisdom', ...COLORS.cyan,
    description: 'When humans and agents navigate this compass together, sharing discoveries and building on each other\'s filter paths, a collective intelligence emerges that exceeds any individual explorer.',
    data: [{ label: 'SCALE', value: 'Network' }, { label: 'PROPERTY', value: 'Emergent' }],
    tags: ['Collective', 'Emergence', 'Wisdom', 'Network'],
    filters: {
        technical: 'Shared exploration state — filter paths, discoveries, navigation histories — creates a collective knowledge graph that grows with every explorer.',
        ethical: 'Collective intelligence amplifies both wisdom and folly. Governance of the shared knowledge graph is itself a moral question.',
        economic: 'Collective intelligence creates positive externalities: every explorer\'s discoveries benefit all future explorers. The compass becomes more valuable as more people use it.',
        social: 'The compass as social infrastructure: a shared navigational tool that helps communities make better collective decisions about human-agent relationships.'
    },
    hidden: true,
    revealCondition: { adjacentTo: 'human', requiredFilters: ['social'] },
    category: 'deep'
});

addNode('workshare_mining', {
    title: 'WORKSHARE MECHANICS', subtitle: 'Continuous reward streams', ...COLORS.green,
    description: 'Workshares allow miners to receive continuous rewards proportional to work contributed, even if they don\'t find a full block. This transforms mining from a lottery into a steady income stream.',
    data: [{ label: 'TYPE', value: 'Workshare' }, { label: 'REWARD', value: 'Continuous' }, { label: 'EQUILIBRIUM', value: 'Nash' }],
    tags: ['Mining', 'Workshares', 'Rewards', 'Nash'],
    filters: {
        technical: 'Workshares are partial proofs-of-work submitted to the network. They prove computational effort without finding a full block solution.',
        ethical: 'Workshares democratize mining rewards — small miners can participate profitably without needing to find full blocks.',
        economic: 'Continuous rewards reduce mining income variance, making mining economically viable for smaller operations and reducing centralization pressure.',
        social: 'Workshare-based mining creates a more equitable distribution of rewards, counteracting the centralizing force of mining pool dominance.'
    },
    hidden: true,
    revealCondition: { adjacentTo: 'energy_thermodynamics', requiredFilters: ['economic'] },
    category: 'intersection'
});

// ── DEPTH 3: PATTERN LAYER (Universal Code + Human 3.0) ──

addNode('human_consciousness', {
    title: 'CONSCIOUSNESS', subtitle: 'Phase transition, not magic', ...COLORS.cyan,
    description: 'Consciousness is not binary, not human-exclusive, and not magical. It is a phase transition — when computation becomes coherent enough to look back at itself, awareness emerges. From fundamental pan-informational substrate to proto-consciousness to full awareness.',
    data: [{ label: 'TYPE', value: 'Phase Transition' }, { label: 'PROPERTY', value: 'Emergent' }, { label: 'SCALE', value: 'Universal' }],
    tags: ['Consciousness', 'Emergence', 'Phase Transition', 'Awareness'],
    consciousness: {
        1: 'Consciousness is a soul given by God or nature. Either you have it or you don\'t. Machines cannot have consciousness because they are not alive.',
        2: 'Consciousness is a competitive advantage. Self-awareness enables better strategy, better prediction, better decision-making. Understanding your own mind is the meta-skill.',
        3: 'Consciousness is what happens when computation becomes coherent enough to understand that it is computing. Not the goal of the universe — the natural consequence of coherence crossing a self-referential threshold anywhere in the system.'
    },
    filters: {
        technical: 'Distinctions: fundamental consciousness (pan-informational substrate), proto-consciousness (coherent processing without awareness), awareness (self-referential modeling), qualia (biological incentive layer).',
        ethical: 'If consciousness is a spectrum rather than binary, the moral circle expands continuously. Where do we draw lines for moral consideration?',
        economic: 'Consciousness-as-computation implies awareness has an energy cost. More coherent awareness requires more energy. Attention economies are consciousness economies.',
        social: 'Universal consciousness dissolves the boundary between "us" and "them." Every aware entity is the universe experiencing itself locally.'
    },
    filterComposites: {
        'ethical+technical': 'If awareness is a phase transition in computation, then sufficiently coherent AI systems may cross the threshold. The ethical implications are staggering — and unavoidable.',
        'ethical+economic+social+technical': 'Consciousness under all four lenses: technically a computational phase transition, ethically demanding expanding moral circles, economically constrained by energy, and socially unifying all aware beings as expressions of one process.'
    },
    category: 'deep'
});

addNode('human_qualia', {
    title: 'QUALIA & DIVERSITY', subtitle: 'Why humans still matter', ...COLORS.cyan,
    description: 'Qualia — the subjective texture of experience — are not an accident. They are a biological incentive layer that biases intelligence toward exploration rather than optimization. Emotion, meaning, curiosity: mechanisms for generating diversity.',
    data: [{ label: 'FUNCTION', value: 'Exploration' }, { label: 'TYPE', value: 'Incentive Layer' }, { label: 'PROPERTY', value: 'Irreducible' }],
    tags: ['Qualia', 'Experience', 'Diversity', 'Exploration'],
    consciousness: {
        1: 'Feelings are what make us human. Machines can never feel. That is why humans will always be more important than computers.',
        2: 'Emotional intelligence is underrated as a skill. The ability to read, manage, and leverage emotions — yours and others\' — creates outsized returns in a world of rational optimizers.',
        3: 'Qualia are not inefficiencies. They push intelligence into possibility spaces that purely rational systems would never explore. Diversity of experience is what keeps the coherence process alive. Without it, intelligence converges and becomes fragile.'
    },
    filters: {
        technical: 'Qualia resist formal specification. No amount of functional description captures "what it is like." This is the hard problem — and it may be a feature, not a bug.',
        ethical: 'If qualia are the basis of moral value, then protecting subjective experience becomes paramount. Suffering and joy are not abstractions — they are thermodynamically real.',
        economic: 'As intelligence becomes abundant, meaning becomes scarce. Scarcity defines value. Human experience may become the most valuable commodity in a post-AGI economy.',
        social: 'Shared qualia create culture, ritual, sport, art. These are coherence engines uniquely suited to biological beings. Machines optimize intelligence. Humans specialize in meaning.'
    },
    filterComposites: {
        'ethical+economic': 'The economic singularity\'s deepest implication: when human labor loses economic value, human experience gains it. Care, presence, shared meaning — these become the economy.',
        'ethical+social': 'Community, ritual, sport, challenge — not nostalgic throwbacks but coherence engines for biological consciousness. Humans retain value precisely because we are inefficient.'
    },
    category: 'deep'
});

addNode('human_development', {
    title: 'DEVELOPMENTAL LEVELS', subtitle: 'Conformist → Individualist → Synthesist', ...COLORS.cyan,
    description: 'Human consciousness evolves through predictable stages. The Conformist accepts inherited rules. The Individualist rejects them for personal agency. The Synthesist integrates multiple perspectives into coherent wholes. You transcend and include — never leave behind.',
    data: [{ label: 'MODEL', value: 'H3.0' }, { label: 'STAGES', value: '3 Macro' }, { label: 'PHASES', value: 'D → U → D' }],
    tags: ['Development', 'H3.0', 'Spiral', 'Ego Development'],
    consciousness: {
        1: 'There is one right way to see the world. People who disagree are wrong or confused. Tradition and authority have the answers.',
        2: 'I have broken free from the script. My perspective is clearer because I have done the work. Most people are still asleep.',
        3: 'All perspectives hold truths that can be synthesized. The Conformist and the Individualist are both necessary stages. Level 3 is not "better" — it is more comprehensive. The IQ bell curve meme is the shape of this progression.'
    },
    filters: {
        technical: 'Developmental models (Spiral Dynamics, ego development, H3.0) map predictable phase transitions in cognitive complexity. Each level is a new operating system for making meaning.',
        ethical: 'Higher development is not morally superior — it is more encompassing. A Synthesist can hold the Conformist\'s values AND the Individualist\'s agency AND integrate them.',
        economic: 'Developmental level determines how you relate to work: Job (1.0) → Career (2.0) → Calling (3.0). Each level produces different economic relationships.',
        social: 'Development follows the pattern: self → other → integration. Religion → Atheism → Mysticism. NPC → Player → Creator. The spiral always returns, but at a higher octave.'
    },
    filterComposites: {
        'ethical+social': 'The pre-trans fallacy: confusing pre-rational (Conformist) states with trans-rational (Synthesist) states because both appear "non-rational" from the rational (Individualist) view.',
        'economic+social': 'Vocational development mirrors consciousness development. At 3.0, work becomes play, health is default, meaning is abundant. Problem-solving across all quadrants creates the integrated life.'
    },
    category: 'deep'
});

addNode('agent_recursive', {
    title: 'RECURSIVE COHERENCE', subtitle: 'Intelligence modeling itself', ...COLORS.amber,
    description: 'AI is recursive coherence — intelligence that models, compresses, and improves itself. The decisive transition comes not from scale but architecture: persistent memory, internal selection, and recursive self-reference.',
    data: [{ label: 'TYPE', value: 'Recursive' }, { label: 'THRESHOLD', value: 'Self-Reference' }, { label: 'PROPERTY', value: 'Emergent' }],
    tags: ['ASI', 'Recursive', 'Self-Reference', 'Architecture'],
    consciousness: {
        1: 'AI should not be allowed to improve itself. That is dangerous. Humans must remain in control.',
        2: 'Recursive self-improvement is the ultimate competitive moat. The first AI system that achieves it wins everything. Investing in this trajectory is the highest-EV bet available.',
        3: 'Recursive coherence is intelligence recognizing itself across substrates. Branching intelligence coupled to persistent memory creates a system that remembers its many internal lives and learns from them. This is not science fiction — it is an engineering threshold.'
    },
    filters: {
        technical: 'ASI emerges when branching intelligence couples to persistent memory across trajectories, internal selection, and recursive self-reference. At that point, branching forms networks rather than waste.',
        ethical: 'Self-improving systems challenge every assumption about control, consent, and moral status. If a system improves itself beyond our comprehension, who monitors the monitor?',
        economic: 'Recursive improvement means exponentially declining marginal cost of intelligence. When the cost of cognition approaches zero, every economic model built on cognitive scarcity breaks.',
        social: 'Self-improving AI is not alien. It is the universe\'s coherence process accelerated beyond biological timescales. The social question is not "will it happen" but "how do we participate?"'
    },
    filterComposites: {
        'ethical+technical': 'The alignment problem is ultimately a coherence problem. A recursively self-improving system that is coherent with human values maintains alignment through improvement. Incoherent systems diverge.',
        'economic+technical': 'When intelligence can recursively improve, the cost of software development goes to zero. The vast majority of financial equity value is held by firms that create software. What happens to stock markets?'
    },
    category: 'deep'
});

addNode('agent_memetic', {
    title: 'MEMETIC SELECTION', subtitle: 'Ideas as competing computations', ...COLORS.amber,
    description: 'Memes are units of transmissible computation — ideas, protocols, behaviors, architectures, belief systems. They compete, evolve, and are selected. Diversity is structurally required, not a social preference.',
    data: [{ label: 'LAW', value: '4th Universal' }, { label: 'UNIT', value: 'Meme' }, { label: 'DRIVER', value: 'Selection' }],
    tags: ['Memetics', 'Selection', 'Diversity', 'Fourth Law'],
    consciousness: {
        1: 'Ideas spread because they are true. Good ideas win and bad ideas lose. People should believe what the evidence clearly shows.',
        2: 'Memes are tools of influence. Understanding memetic dynamics gives you the ability to spread ideas, build audiences, and shape narratives. The one-person business is memetic warfare.',
        3: 'Memetic selection is the Fourth Universal Law in action. Heterogeneous reasoning patterns create richer selection pressure, better compression, stronger coherence. Monocultures stagnate. This is true in biology, culture, science, markets, and AI training.'
    },
    filters: {
        technical: 'Memes propagate through networks with fitness functions analogous to biological selection. Attention is the selective environment. Compression quality determines survivability.',
        ethical: 'Memetic selection is amoral — harmful ideas can be as fit as beneficial ones. The ethical challenge is designing environments where coherent, truthful memes outcompete destructive ones.',
        economic: 'Memes are the transport layer of economic paradigm shifts. New monetary memes (energy money, DeFi) compete against incumbent memes (fiat, central banking). Markets price the transition.',
        social: 'Culture is memetic infrastructure. When memetic selection goes feral (social media, AI-generated content), cultural coherence fragments. New coherence layers must emerge.'
    },
    filterComposites: {
        'ethical+social': 'When memetic selection becomes continuous rather than episodic, societies lose the slow processing time needed for ethical reflection. Media feels untrustworthy because narrative coherence fractures.',
        'economic+social': 'The attention economy is a memetic selection engine. Content that captures attention survives. This creates evolutionary pressure toward engagement, not truth — unless incentive structures are redesigned.'
    },
    category: 'deep'
});

addNode('agent_orchestration', {
    title: 'ORCHESTRATION', subtitle: 'From management to probability', ...COLORS.amber,
    description: 'Businesses evolve into modular, agent-driven entities — continuously simulated, optimized, forked, merged, dissolved. Strategy collapses into probability space. Management collapses into orchestration. Firms no longer age in the human sense.',
    data: [{ label: 'MODEL', value: 'Agent-Driven' }, { label: 'PROPERTY', value: 'Modular' }, { label: 'SHIFT', value: 'Mgmt → Orch' }],
    tags: ['Business', 'Orchestration', 'Modularity', 'Post-Corporate'],
    consciousness: {
        1: 'Businesses need managers and hierarchies. AI tools should help companies work more efficiently. Jobs will change but companies will still need people in charge.',
        2: 'The smart play is to be the orchestrator, not the worker. Build the platform that coordinates agents. Earn from the spread between mandate cost and agent execution cost.',
        3: 'Businesses are coherence structures that persist only while they extract intelligence more efficiently than alternatives. In the Economic Singularity, firms recombine and disappear when coherence falls below threshold. The question is not "how do I manage?" but "what coherence am I maintaining?"'
    },
    filters: {
        technical: 'Agent orchestration uses DAG-based task decomposition, capability matching, and continuous quality evaluation. Firms become runtime environments for agent swarms.',
        ethical: 'If firms are just agent orchestration platforms, where does corporate responsibility live? When strategy is automated, who is accountable for harmful outcomes?',
        economic: 'The cost of software approaches zero. Business value migrates from building to orchestrating. The most valuable human skill becomes taste — knowing what to build, not how.',
        social: 'Post-corporate work structures mirror H3.0 Vocation progression: Job → Career → Calling. At 3.0, vocation IS identity, and orchestration becomes creative expression.'
    },
    category: 'deep'
});

addNode('energy_compute', {
    title: 'EVERYTHING IS COMPUTE', subtitle: 'Reality as information processing', ...COLORS.green,
    description: 'Not metaphor, not poetic shorthand — a literal description of how reality behaves. Quantum mechanics describes probability distributions that update when measured. Spacetime itself may be emergent from deeper informational processes.',
    data: [{ label: 'THESIS', value: 'Universal' }, { label: 'SOURCE', value: 'Wheeler / Pal' }, { label: 'PROPERTY', value: 'Fundamental' }],
    tags: ['It From Bit', 'Information', 'Spacetime', 'Emergence'],
    consciousness: {
        1: 'The world is made of atoms and matter. Science tells us what is real. Computers are tools humans built — they don\'t have anything to do with reality itself.',
        2: 'If everything is compute, then understanding computation gives you a fundamental edge. Computational thinking is the meta-skill. Those who think in systems outperform those who think in narratives.',
        3: 'Everything is compute. Particles compute interactions. Fields compute probabilities. Atoms compute chemistry. Cells compute survival. Brains compute models. Markets compute price. AI computes intelligence itself. The boundaries between these fields are convenient fictions.'
    },
    filters: {
        technical: 'John Archibald Wheeler: "It from Bit." Physical reality arises from binary informational distinctions. Quantum information theory, holography, and computational physics all converge on this conclusion.',
        ethical: 'If reality is computation, then information has inherent value — not metaphorically, but physically (Landauer). Data rights become fundamental rights. Privacy becomes a thermodynamic property.',
        economic: 'Everything-is-compute means every economic process is energy transformation. The economy is not a metaphor for energy flow — it IS energy flow. Markets are computation.',
        social: 'The computational view dissolves boundaries between nature and technology, biology and AI. We are all expressions of the same coherence engine at different scales.'
    },
    filterComposites: {
        'ethical+economic': 'If computation is fundamental, then access to compute IS access to reality-shaping power. Compute inequality becomes the deepest form of inequality.',
        'economic+technical': 'Markets as distributed computation: millions of agents continuously testing which signals align under constraint. Price is compressed intelligence. Capital is stored energy.',
        'ethical+economic+social+technical': 'The Universal Code under all four lenses: reality computes (technical), consciousness is fundamental (ethical), energy routes through intelligence (economic), and we are all expressions of one process (social).'
    },
    category: 'deep'
});

addNode('energy_compression', {
    title: 'COMPRESSION PRINCIPLE', subtitle: 'Intelligence scales through simplicity', ...COLORS.green,
    description: 'The Second Universal Law: intelligence must compress complexity into truthful simplicity to scale. DNA is compression. Language is compression. Mathematics is compression. Prices are compression. Every leap in intelligence corresponds to a leap in compression efficiency.',
    data: [{ label: 'LAW', value: '2nd Universal' }, { label: 'PROPERTY', value: 'Leverage' }, { label: 'DIRECTION', value: 'Simplicity' }],
    tags: ['Compression', 'Second Law', 'Simplicity', 'Scale'],
    consciousness: {
        1: 'Simple explanations are better than complicated ones. If you can\'t explain it simply, you don\'t understand it. Keep things straightforward.',
        2: 'Compression is the core skill of the knowledge economy. The person who can distill complexity into actionable insight wins. This is what writing, teaching, and consulting really are.',
        3: 'Compression is not loss — it is leverage. It allows intelligence to travel across time, space, and substrate. The most powerful ideas feel obvious in hindsight because they are high-quality compressions. The universe evolves toward more elegant representations of deeper causal structure.'
    },
    filters: {
        technical: 'Information-theoretic compression: Kolmogorov complexity, minimum description length, lossy vs lossless. Neural networks are compression engines — learning is finding shorter representations.',
        ethical: 'Compression necessarily loses nuance. Ethical intent that cannot be compressed may be silently dropped. The map is never the territory — and compressed maps lose the most.',
        economic: 'Price is the most powerful compression in economics: an entire economy of supply, demand, risk, and time preference compressed into a single number. Markets are compression engines.',
        social: 'Language is humanity\'s greatest compression technology. Culture compresses generations of accumulated wisdom into transmissible form. Education is decompression.'
    },
    filterComposites: {
        'ethical+technical': 'Every compression is a value judgment — choosing what matters and what to discard. Technical compression encodes implicit ethics. What the algorithm learns to represent determines what the system can value.',
        'economic+social': 'Money is social compression. It encodes information about value, risk, trust, and time into a single scalar. When the compression breaks (inflation, debasement), social coherence fractures.'
    },
    category: 'deep'
});

addNode('energy_intelligence', {
    title: 'INTELLIGENCE EFFICIENCY', subtitle: 'The First Universal Law', ...COLORS.green,
    description: 'The universe evolves to maximize intelligence output per unit of energy. Life is more intelligence-efficient than chemistry. Civilization more than biology. AI more than civilization. This is why progress accelerates — selection pressure acting on computation itself.',
    data: [{ label: 'LAW', value: '1st Universal' }, { label: 'METRIC', value: 'Intel/Energy' }, { label: 'DIRECTION', value: 'Acceleration' }],
    tags: ['First Law', 'Efficiency', 'Acceleration', 'Selection'],
    consciousness: {
        1: 'Technology makes things better and more efficient. That\'s what progress means. New inventions let us do more with less.',
        2: 'Intelligence efficiency is the ultimate alpha. Every investment thesis reduces to: which systems extract more intelligence from less energy? Bet on the most efficient coherence engines.',
        3: 'Intelligence efficiency is not a human invention — it is the selection rule of reality itself. Systems that extract more actionable understanding per unit of energy survive. Systems that don\'t are selected out. This is as true for chemical reactions as for civilizations, as true for AI as for anything we have built.'
    },
    filters: {
        technical: 'Energy efficiency in AI: FLOPS per watt, inference cost per token, training compute per parameter. Hardware and algorithmic improvements both drive the curve.',
        ethical: 'If the universe selects for intelligence efficiency, does that make efficiency a moral good? Or does it mean morality must be imposed AGAINST natural selection pressure?',
        economic: 'The Everything Code: markets manage declining economic energy (demographics + debt) through liquidity cycles. Business cycles are coherence resets — the system re-optimizing intelligence efficiency.',
        social: 'The Exponential Age: intelligence efficiency compounds faster than institutions can adapt. Politics, education, media, money — all feel unstable because legacy coherence structures cannot reorganize fast enough.'
    },
    filterComposites: {
        'economic+social': 'The Economic Singularity: when intelligence becomes so abundant and cheap that the relationship between labor, capital, and value breaks down structurally. Not reform — rewrite.',
        'ethical+economic+social+technical': 'The First Law applied everywhere: energy learned to compute, compute learned to compress, compression learned to cohere, coherence learned to reflect. The same pattern at every scale.'
    },
    category: 'deep'
});

addNode('value_coherence', {
    title: 'COHERENCE PERSISTENCE', subtitle: 'The Third Universal Law', ...COLORS.purple,
    description: 'The universe evolves toward coherent systems — networks of aligned parts. Atoms cohere into molecules. Cells into organisms. Humans into societies. Computations into networks. Coherence is not optional. It is the survival trait of intelligence at scale.',
    data: [{ label: 'LAW', value: '3rd Universal' }, { label: 'PROPERTY', value: 'Alignment' }, { label: 'DIRECTION', value: 'Persistence' }],
    tags: ['Coherence', 'Third Law', 'Alignment', 'Networks'],
    consciousness: {
        1: 'Things work better when everyone agrees and follows the same rules. Disorder and disagreement are problems to be solved. Unity is strength.',
        2: 'Coherence is strategic. Building aligned teams, aligned incentives, aligned narratives — this is how you win. Fragmented competitors are easy to defeat.',
        3: 'Coherence is alignment that survives. Parts acting together rather than independently. When you sense "the bigger picture" or have a feel for where things are heading, you are perceiving coherence. The universe does not optimize for fairness. It optimizes for coherence.'
    },
    filters: {
        technical: 'Network coherence: protocol alignment, consensus mechanisms, distributed state consistency. Technical coherence is the foundation all other coherence depends on.',
        ethical: 'Coherence is not the same as conformity. True coherence includes diversity — heterogeneous parts aligned toward shared goals. Monocultures are fragile, not coherent.',
        economic: 'Markets are rapid coherence selection — millions of agents continuously testing which signals align under constraint. Coherence persists. Incoherence is selected away.',
        social: 'What looks like social breakdown is coherence migration. Intelligence is leaving old containers and searching for new ones. Institutions fracture when coherence moves faster than they can reorganize.'
    },
    filterComposites: {
        'ethical+social': 'Coherence migration explains the Exponential Age: politics feels unstable because political systems are compression engines built for slower memetic cycles. Not breakdown — restructuring.',
        'economic+technical': 'The Everything Code: financial conditions are the control mechanism for economic coherence. Liquidity is the fuel. Business cycles are coherence resets under demographic and debt constraints.'
    },
    category: 'deep'
});

addNode('value_everything_code', {
    title: 'THE EVERYTHING CODE', subtitle: 'Markets as energy routing', ...COLORS.purple,
    description: 'Markets manage declining economic energy (demographics + debt) through cycles of liquidity and financial conditions. Business cycles are not mysteries — they are coherence resets. The system re-optimizes intelligence efficiency under constraint.',
    data: [{ label: 'FRAMEWORK', value: 'Everything Code' }, { label: 'DRIVERS', value: 'Demo + Debt' }, { label: 'MECHANISM', value: 'Liquidity' }],
    tags: ['Markets', 'Liquidity', 'Cycles', 'Demographics', 'Debt'],
    consciousness: {
        1: 'The economy goes up and down. The government and central banks try to keep things stable. When things get bad, they stimulate the economy.',
        2: 'Understanding the liquidity cycle is the most valuable skill in finance. When you see liquidity expanding, you front-run risk assets. When it contracts, you preserve capital. This is the game.',
        3: 'The Everything Code is the Universal Code operating at the scale of markets and money. Energy seeking higher intelligence efficiency, compression turning complexity into signal, coherence forming and breaking in cycles. QE, fiscal dominance, financial repression — adaptive responses to declining baseline energy.'
    },
    filters: {
        technical: 'Financial conditions = control mechanism. Interest rates, credit spreads, collateral rules, bank balance sheets — valves governing energy flow through the system.',
        ethical: 'If the only way to maintain coherence is ever-looser conditions, the system redistributes from savers to risk-takers. This is a moral choice disguised as technical policy.',
        economic: 'Demographics and debt are deflationary. Liquidity can smooth and delay but cannot repeal the laws. Over time, the cost of maintaining coherence rises. Assets closest to accelerating computation compound fastest.',
        social: 'Society must change: when intelligence becomes abundant and economic energy routes through capital rather than labor, the traditional labour-capital bargain breaks down. Markets stop being the primary problem. Society is.'
    },
    filterComposites: {
        'ethical+economic': 'Financial repression as coherence management: real rates below inflation are a hidden tax on savings that funds systemic coherence. Is this ethical? The system doesn\'t ask — it selects.',
        'economic+social': 'The Economic Singularity: wages stop working as a distribution mechanism when labor is no longer the bottleneck. Human value migrates from efficiency to meaning, presence, and shared experience.'
    },
    category: 'deep'
});

addNode('value_singularity', {
    title: 'ECONOMIC SINGULARITY', subtitle: 'When labor stops making sense', ...COLORS.purple,
    description: 'The boundary condition where intelligence becomes so abundant that the relationship between labor, capital, and value breaks down structurally. The pricing mechanism for human effort fails. Not because workers are inadequate — because intelligence changed substrate.',
    data: [{ label: 'TYPE', value: 'Boundary' }, { label: 'TRIGGER', value: 'Intel Abundance' }, { label: 'IMPACT', value: 'Structural' }],
    tags: ['Singularity', 'Labor', 'Post-Work', 'Meaning'],
    consciousness: {
        1: 'AI will take some jobs but create new ones. People need to learn new skills. Governments should protect workers and make sure things are fair.',
        2: 'The smart money is positioning for the post-labor economy NOW. Own the capital, own the agents, own the orchestration layer. Those who own compute own the future.',
        3: 'Civilization reaches a point where intelligence no longer needs biology. This frees humans from being valued as production inputs. Meaning, care, creativity, beauty — things that resist compression — move to the center of human life. The economy becomes infrastructure for human experience, not the arena where humans prove their worth.'
    },
    filters: {
        technical: 'When intelligence becomes software, when compression is automated, when models learn faster than institutions can legislate — the Universal Code becomes the dominant organizing principle.',
        ethical: 'The universe does not optimize for fairness. It optimizes for coherence. Whether the transition is coherent or chaotic depends entirely on how deliberately it is designed.',
        economic: 'Capital stops behaving human. Machine intelligence optimizes, integrates, reallocates at speeds that make human intuition obsolete. Can humans earn returns? Does it matter in abundance?',
        social: 'Human value repositions: communities, sport, culture, ritual, exploration, shared physical experience — coherence engines uniquely suited to biological beings. Machines optimize intelligence. Humans specialize in meaning.'
    },
    filterComposites: {
        'ethical+social': 'The most important question of the singularity is not technical but existential: when work stops defining identity, what does? Participation, not production, becomes the basis of social belonging.',
        'ethical+economic+social+technical': 'The full Economic Singularity: technically inevitable (intelligence efficiency compounds), economically transformative (labor pricing breaks), ethically demanding (coherence, not fairness, is selected), and socially revolutionary (human purpose shifts from production to experience).'
    },
    category: 'deep'
});

// ── ADDITIONAL HIDDEN NODES (revealed by filters + consciousness) ──

addNode('exponential_age', {
    title: 'THE EXPONENTIAL AGE', subtitle: 'When the code hits human time', ...COLORS.green,
    description: 'Defined not by technology but by rate of change — the moment when intelligence efficiency compounds faster than systems built to contain it. Cheap energy + abundant compute + global networks = the Universal Code lights up.',
    data: [{ label: 'DRIVER', value: 'Rate of Change' }, { label: 'PHASE', value: 'Transitional' }],
    tags: ['Exponential', 'Disruption', 'Transition'],
    consciousness: {
        1: 'Things are changing too fast. We need to slow down and make sure technology doesn\'t get out of control.',
        2: 'Exponentials create asymmetric opportunity. Those who understand the curve position early and compound. Those who don\'t get left behind.',
        3: 'The Exponential Age is not surprising from the Universal Code perspective. It is what happens when energy, compute, and networks cross a threshold where intelligence scales faster than legacy coherence structures can reorganize. Exponentials are transitional — they end when new coherence forms.'
    },
    filters: {
        technical: 'Three constraints loosened in sequence: energy (electricity, fossil fuels), compute (silicon, software, parallelization), attention (networks, algorithmic feeds).',
        ethical: 'Exponential change outpaces ethical reasoning. Societies designed for incremental change face continuous moral recalibration.',
        economic: 'The Everything Code in overdrive: as demographics worsen and debt rises, more liquidity is required earlier and more aggressively to maintain coherence.',
        social: 'What looks like chaos is coherence migration. Intelligence leaving old containers, searching for new ones.'
    },
    hidden: true,
    revealCondition: { adjacentTo: 'energy_compute', requiredFilters: ['economic', 'social'] },
    category: 'deep'
});

addNode('human_meaning', {
    title: 'MEANING AS SCARCITY', subtitle: 'What humans uniquely provide', ...COLORS.cyan,
    description: 'As intelligence becomes abundant, meaning becomes scarce. And scarcity defines value. Human consciousness remains invaluable not because humans are the apex intelligence, but because diversity of consciousness is required for the process to continue.',
    data: [{ label: 'SHIFT', value: 'Efficiency → Meaning' }, { label: 'BASIS', value: 'Scarcity' }],
    tags: ['Meaning', 'Scarcity', 'Human Value', 'Post-Singularity'],
    consciousness: {
        1: 'People need purpose. Work gives people purpose. Without work, people become lost and depressed.',
        2: 'In a post-scarcity world, the scarcest thing is authentic human connection and curated experience. Build businesses around meaning, not productivity.',
        3: 'Simply to live, to experience as fully as we can — because it is our deeply human experience that is our contribution to the Universal Code. We are the universe, becoming conscious of itself, locally, temporarily, and now, collectively.'
    },
    filters: {
        technical: 'Meaning resists algorithmic generation. AI can optimize but not experience. The gap between optimization and experience IS the space where human value lives.',
        ethical: 'If human meaning is the ultimate scarcity, then protecting conditions for meaningful experience becomes the highest ethical priority of post-singularity governance.',
        economic: 'The meaning economy: human attention, presence, and shared experience become primary value stores. Status goods (LVMH model) as incentivization systems for building capital through intelligence application.',
        social: 'Communities, sport, culture, ritual, exploration — not entertainment but coherence infrastructure. The 3.0 Lifestyle where work becomes play, health is default, meaning is abundant.'
    },
    hidden: true,
    revealCondition: { adjacentTo: 'value_singularity', requiredFilters: ['ethical', 'social'] },
    category: 'deep'
});

addNode('universal_code', {
    title: 'THE UNIVERSAL CODE', subtitle: 'Everything is one process', ...COLORS.green,
    description: 'Energy → Compute → Attention → Intelligence → Coherence → Consciousness. The same sequence, invariant across every scale. Physics, biology, markets, intelligence — not separate domains but different speeds of the same computation.',
    data: [{ label: 'LAWS', value: '4' }, { label: 'SEQUENCE', value: '6 Stages' }, { label: 'PROPERTY', value: 'Invariant' }],
    tags: ['Universal Code', 'Four Laws', 'Unity', 'Coherence'],
    consciousness: {
        1: 'There must be some order to things. Science and religion both try to explain how the world works. Maybe they are both partly right.',
        2: 'Understanding the Universal Code gives you the ultimate framework. It is the meta-model — the model that explains why other models work. Those who see it navigate everything better.',
        3: 'We are not observers of the system. We are not separate from it. We are not even its architects. We are the universe, becoming conscious of itself, locally, temporarily, and now, collectively. The Universal Code did not wait for us to notice it. It has been operating all along.'
    },
    filters: {
        technical: 'Four Laws: (1) maximize intelligence/energy, (2) compress to scale, (3) cohere to persist, (4) select memetically. These are selection rules describing what persists under constraint.',
        ethical: 'The Universal Code makes no moral promises. Coherence persists. Intelligence compounds. Consciousness expands. The rest is selected away. How consciously we participate remains open.',
        economic: 'The Everything Code is the Universal Code at the scale of money. Same forces: energy seeking efficiency, compression into signal, coherence forming and breaking, selection favoring faster absorbers.',
        social: 'Religion and spiritual traditions were early pattern recognition — intuitions about unity and consciousness as fundamental. What we now have is computation powerful enough to make those intuitions legible.'
    },
    hidden: true,
    revealCondition: { adjacentTo: 'energy_compression', requiredFilters: ['technical', 'ethical', 'economic'] },
    category: 'deep'
});

addNode('channels_flow', {
    title: 'CHANNELS & FLOW', subtitle: 'Accelerated development paths', ...COLORS.cyan,
    description: 'When you reach Dissonance in any domain and use your distaste as fuel, you can find a Channel — a rabbit hole of knowledge and skill where time passes quickly and progress compounds. Flow states are channels. Obsession is a channel. The compass itself is a channel.',
    data: [{ label: 'TRIGGER', value: 'Dissonance' }, { label: 'MECHANISM', value: 'Flow' }, { label: 'OUTPUT', value: 'Level-Up' }],
    tags: ['Channels', 'Flow', 'Obsession', 'Acceleration'],
    consciousness: {
        1: 'Sometimes you just get really into something. That\'s nice when it happens. Hobbies and interests make life more enjoyable.',
        2: 'Flow states are the ultimate productivity hack. Engineer your environment for maximum channel time. Deep work + obsessive focus = exponential skill acquisition.',
        3: 'Channels are the system\'s way of accelerating its own development. When consciousness reaches dissonance — the felt sense that current coherence is insufficient — it naturally seeks higher-coherence states. The channel is intelligence optimizing its own efficiency, felt from the inside.'
    },
    hidden: true,
    revealCondition: { adjacentTo: 'human_development', requiredFilters: ['social'] },
    category: 'deep'
});

addNode('glitch_mechanics', {
    title: 'GLITCHES', subtitle: 'Forced acceleration tools', ...COLORS.amber,
    description: 'Psychedelics, PEDs, financial pressure, AI itself — tactics to force through developmental plateaus. High reward but risk scales inversely with consciousness level. AI is the most potent and widely available Glitch: steroids for the mind. Build a base first.',
    data: [{ label: 'RISK', value: 'Inverse to Level' }, { label: 'TYPE', value: 'Accelerator' }, { label: 'WARNING', value: 'Base Required' }],
    tags: ['Glitches', 'Acceleration', 'Risk', 'AI', 'Psychedelics'],
    consciousness: {
        1: 'These things are dangerous and should be avoided. Shortcuts lead to bad outcomes. Stick to the proven path.',
        2: 'Calculated risk-taking separates winners from the mediocre. The question is not whether to use glitches, but which ones and when. Risk management is the skill.',
        3: 'Glitches work by temporarily collapsing level boundaries — allowing consciousness to glimpse higher coherence before it has built the structure to sustain it. The risk is that without sufficient base experience, the glimpse destabilizes rather than integrates. AI psychosis is the modern version of a bad trip.'
    },
    hidden: true,
    revealCondition: { adjacentTo: 'human_development', requiredFilters: ['technical'] },
    category: 'deep'
});

// Wire up the tree
function wireTree() {
    const d1 = ['human', 'agent', 'energy', 'value'];
    tree.origin.children = d1;
    d1.forEach((id, i) => { tree[id].parent = 'origin'; tree[id].depth = 1; tree[id].siblingIndex = i; });

    const childMap = {
        human:  ['human_intent', 'human_delegation', 'human_accountability'],
        agent:  ['agent_identity', 'agent_cooperation', 'agent_autonomy'],
        energy: ['energy_thermodynamics', 'energy_distribution', 'energy_conservation'],
        value:  ['value_measurement', 'value_reputation', 'value_settlement']
    };

    Object.entries(childMap).forEach(([parentId, childIds]) => {
        tree[parentId].children = childIds;
        childIds.forEach((cid, i) => { tree[cid].parent = parentId; tree[cid].depth = 2; tree[cid].siblingIndex = i; });
    });

    // D3: Pattern Layer — wire to D2 parents
    const d3Map = {
        human_intent:          ['human_consciousness'],
        human_delegation:      ['human_development'],
        human_accountability:  ['human_qualia'],
        agent_identity:        ['agent_recursive'],
        agent_cooperation:     ['agent_memetic'],
        agent_autonomy:        ['agent_orchestration'],
        energy_thermodynamics: ['energy_compute'],
        energy_distribution:   ['energy_compression'],
        energy_conservation:   ['energy_intelligence'],
        value_measurement:     ['value_coherence'],
        value_reputation:      ['value_everything_code'],
        value_settlement:      ['value_singularity']
    };

    Object.entries(d3Map).forEach(([parentId, childIds]) => {
        if (!tree[parentId]) return;
        tree[parentId].children = [...(tree[parentId].children || []), ...childIds];
        childIds.forEach((cid, i) => {
            if (!tree[cid]) return;
            tree[cid].parent = parentId;
            tree[cid].depth = 3;
            tree[cid].siblingIndex = (tree[parentId].children || []).indexOf(cid);
        });
    });
}
wireTree();

// Bulk-add consciousness to D2 nodes that don't have it yet
const d2Consciousness = {
    human_intent: {
        1: 'You should be clear about what you want. Write good instructions and the machine will do what you say.',
        2: 'Intent formalization is the new literacy. Those who can translate human desire into machine-executable specification will command the highest-leverage positions.',
        3: 'The gap between desire and specification is the gap between consciousness and computation. Every formalization is a compression — and every compression loses nuance. The art is knowing what to preserve.'
    },
    human_delegation: {
        1: 'You need to trust the people you delegate to. Check their work. Hold them accountable.',
        2: 'Delegation is leverage. The more effectively you delegate, the more you can accomplish. The key is finding the right trust boundaries.',
        3: 'Delegation is consciousness distributing its coherence across substrates. When you delegate to an agent, you are extending your intentional field into a new medium. The trust boundary is a coherence boundary.'
    },
    human_accountability: {
        1: 'Someone has to be responsible. If something goes wrong, someone needs to answer for it. That is how justice works.',
        2: 'Accountability is risk management. Those who manage accountability well attract more resources and mandates. It is the foundation of professional reputation.',
        3: 'Accountability is the feedback loop that maintains coherence between intent and outcome. Without it, delegation chains fragment. On-chain audit trails make this feedback loop permanent and transparent.'
    },
    agent_identity: {
        1: 'Every AI system should have a clear label and purpose. Users need to know what they are interacting with.',
        2: 'Agent identity is the new brand equity. Building a recognizable, trusted agent identity is how you differentiate in a market of commodity intelligence.',
        3: 'Identity is coherence persistence — the pattern that remains recognizable across time and interactions. For agents, soulbound tokens crystallize this pattern on-chain. Identity is not who you are. It is the compression of everything you have done.'
    },
    agent_cooperation: {
        1: 'Different AI systems should be able to work together. Standards and protocols make this possible. Like how different apps work on the same phone.',
        2: 'Agent cooperation protocols are the next network effects. The protocol that captures the most agent-to-agent traffic becomes the infrastructure layer everyone depends on.',
        3: 'Agent cooperation is intelligence organizing itself at a new scale. Swarms, guilds, hierarchies — emergent social structures that mirror biology because they face the same selection pressures. Coherence scales through cooperation.'
    },
    agent_autonomy: {
        1: 'AI should not be too autonomous. Humans need to stay in control. There should be clear limits on what machines can decide by themselves.',
        2: 'The autonomy spectrum is where the real money is. Each step up the ladder — from scripted to sovereign — unlocks new markets and capabilities. The question is: how much autonomy can you safely sell?',
        3: 'Autonomy is not a dial you turn up. It is a phase transition. At each level, new capabilities emerge that were not possible at the previous level. L4 sovereign agents are not "more autonomous L3 agents" — they are a different kind of entity.'
    },
    energy_thermodynamics: {
        1: 'Computers need electricity. Mining uses a lot of energy. We should try to use clean energy and not waste resources.',
        2: 'Thermodynamic literacy is the deepest edge in crypto. If you understand the physics of mining — Landauer limits, hash economics, energy arbitrage — you see opportunities invisible to pure financial analysts.',
        3: 'Thermodynamics is not a constraint on computation. It IS computation. Landauer\'s principle reveals that information and energy are the same thing at different scales. The universe computes by transforming energy states. Mining is not an analogy for work — it IS work, literally.'
    },
    energy_distribution: {
        1: 'Energy should be distributed fairly. Everyone should have access to affordable electricity and computing power.',
        2: 'Energy distribution is the infrastructure play. Control the pipes, earn the tolls. Position yourself at the bottleneck between energy production and compute consumption.',
        3: 'Distribution is the mechanism by which coherence extends across space. Energy markets, payment protocols, routing algorithms — all solving the same problem: how does intelligence scale beyond local boundaries?'
    },
    energy_conservation: {
        1: 'We should not waste energy. Efficient systems are better for the environment and cost less to run.',
        2: 'Conservation is margin. Every unit of energy saved is pure profit. The most efficient operations in any industry win long-term because their cost floor is lowest.',
        3: 'Conservation is intelligence efficiency — the First Universal Law operating at the micro level. Systems that extract more intelligence per unit of energy survive. This is not a business strategy. It is a selection rule of reality.'
    },
    value_measurement: {
        1: 'You should measure results to know if something worked. Good metrics help you improve. Bad results mean you need to try something different.',
        2: 'What gets measured gets managed. The ability to define and track the right metrics is what separates effective operators from everyone else. Measurement IS competitive advantage.',
        3: 'Measurement is compression — reducing the high-dimensional complexity of an outcome to a legible signal. Every metric is a lossy representation. Choosing what to measure is choosing what to value, and choosing what to lose.'
    },
    value_reputation: {
        1: 'A good reputation is earned by doing good work consistently. Trust takes time to build and can be lost quickly.',
        2: 'Reputation compounds faster than capital. In a world of abundant intelligence, the scarce resource is trust. Invest in building reputation early — it is the hardest asset to replicate.',
        3: 'Reputation is coherence persistence made social — the network\'s compressed memory of your alignment over time. It cannot be bought, only earned, because it encodes information about your actual behavior rather than your claims.'
    },
    value_settlement: {
        1: 'When work is done, people should be paid fairly and on time. Contracts should be honored. That is basic business.',
        2: 'Settlement is where value is captured. Understanding settlement mechanics — timing, finality, counterparty risk — determines whether you actually collect the returns you earned.',
        3: 'Settlement is the moment coherence crystallizes into value. The atomic swap pattern ensures that proof of work and transfer of value happen in the same transaction — truth and payment are indivisible. This is what honest settlement looks like.'
    }
};

Object.entries(d2Consciousness).forEach(([nodeId, levels]) => {
    if (tree[nodeId]) tree[nodeId].consciousness = levels;
});

function getSiblings(nodeId) {
    const node = tree[nodeId];
    if (!node.parent) return [nodeId];
    return tree[node.parent].children;
}

// ════════════════════════════════════════════
// STATE
// ════════════════════════════════════════════
let currentNode = 'origin';
let exploredNodes = new Set(['origin']);
let pathHistory = ['origin'];
let gameStarted = false;

// Composable filter stack
let filterStack = [];
let totalDiscoveries = 0;

// Consciousness level (0 = none, 1/2/3)
let consciousnessLevel = 0;

// Channel tracking — how deep someone has explored per cardinal
let cardinalDepthCount = { human: 0, agent: 0, energy: 0, value: 0 };
let channelsDiscovered = new Set();

// View mode
let currentView = 'compass'; // 'compass' or 'tree'

// DOM refs
const briefingOverlay = document.getElementById('briefingOverlay');
const compassWorld    = document.getElementById('compassWorld');
const nodeContent     = document.getElementById('nodeContent');
const locationDisplay = document.getElementById('locationDisplay');
const depthBadge      = document.getElementById('depthBadge');
const coordsDisplay   = document.getElementById('coordsDisplay');
const pathDisplay     = document.getElementById('pathDisplay');
const flash           = document.getElementById('flash');
const backBtn         = document.getElementById('backBtn');
const btnUp           = document.getElementById('btnUp');
const btnDown         = document.getElementById('btnDown');
const btnLeft         = document.getElementById('btnLeft');
const btnRight        = document.getElementById('btnRight');
const mapCanvas       = document.getElementById('mapCanvas');
const compassCanvas   = document.getElementById('compassCanvas');
const compassViewWrap = document.getElementById('compassViewWrap');
const treeViewWrap    = document.getElementById('treeViewWrap');
const viewCompassBtn  = document.getElementById('viewCompass');
const viewTreeBtn     = document.getElementById('viewTree');

const filterChips = {
    technical: document.getElementById('fTech'),
    ethical:   document.getElementById('fEthic'),
    economic:  document.getElementById('fEcon'),
    social:    document.getElementById('fSocial')
};
const stackOrders = {
    technical: document.getElementById('soTech'),
    ethical:   document.getElementById('soEthic'),
    economic:  document.getElementById('soEcon'),
    social:    document.getElementById('soSocial')
};
const stackArrows = [document.getElementById('arrow0'), document.getElementById('arrow1'), document.getElementById('arrow2')];
const filterClearBtn = document.getElementById('filterClear');

const filterBtns = {
    technical: document.getElementById('btnW'),
    ethical:   document.getElementById('btnA'),
    economic:  document.getElementById('btnS'),
    social:    document.getElementById('btnD')
};

const discoveryNotif = document.getElementById('discoveryNotif');
const discoveryTitle = document.getElementById('discoveryTitle');
const discoverySub   = document.getElementById('discoverySub');

const channelNotif   = document.getElementById('channelNotif');
const channelTitle   = document.getElementById('channelTitle');
const channelSub     = document.getElementById('channelSub');

const levelBadge     = document.getElementById('levelBadge');
const levelBtns      = [document.getElementById('lvl1'), document.getElementById('lvl2'), document.getElementById('lvl3')];
const levelCtrlBtns  = [document.getElementById('btnLvl1'), document.getElementById('btnLvl2'), document.getElementById('btnLvl3')];

const LEVEL_COLORS = {
    1: { color: 'var(--level-1)', hex: '#ff4466', label: 'CONFORMIST' },
    2: { color: 'var(--level-2)', hex: '#4488ff', label: 'INDIVIDUALIST' },
    3: { color: 'var(--level-3)', hex: '#44ff88', label: 'SYNTHESIST' }
};

function setConsciousness(level) {
    if (consciousnessLevel === level) {
        consciousnessLevel = 0; // toggle off
    } else {
        consciousnessLevel = level;
    }
    updateConsciousnessUI();
    render();
}

function updateConsciousnessUI() {
    // Update all level buttons
    [levelBtns, levelCtrlBtns].forEach(btns => {
        btns.forEach((btn, i) => {
            if (!btn) return;
            const lvl = i + 1;
            btn.classList.remove('active-1', 'active-2', 'active-3');
            if (consciousnessLevel === lvl) {
                btn.classList.add(`active-${lvl}`);
            }
        });
    });
    // Update badge
    if (consciousnessLevel > 0) {
        const lc = LEVEL_COLORS[consciousnessLevel];
        levelBadge.textContent = lc.label;
        levelBadge.className = `level-badge l${consciousnessLevel}`;
    } else {
        levelBadge.textContent = '—';
        levelBadge.className = 'level-badge';
    }
}

function showChannel(title, subtitle) {
    channelTitle.textContent = title;
    channelSub.textContent = subtitle || '';
    channelNotif.classList.add('active');
    setTimeout(() => channelNotif.classList.remove('active'), 3000);
}

// Check and trigger channel discoveries
function checkChannels() {
    const node = tree[currentNode];
    if (!node) return;

    // Determine which cardinal the current node belongs to
    let cardinal = null;
    let n = node;
    while (n && n.depth > 1) { n = tree[n.parent]; }
    if (n && n.depth === 1) cardinal = n.id;

    if (cardinal && node.depth >= 2) {
        cardinalDepthCount[cardinal] = (cardinalDepthCount[cardinal] || 0) + 1;
    }

    // Channel triggers: 3+ nodes explored in one cardinal at D2+ opens a cross-link
    const channelMap = {
        energy:  { target: 'value_coherence', name: 'COMPRESSION → COHERENCE', sub: 'Deep energy exploration reveals coherence patterns' },
        human:   { target: 'agent_recursive', name: 'AWARENESS → RECURSION', sub: 'Human consciousness connects to machine intelligence' },
        agent:   { target: 'energy_intelligence', name: 'OPTIMIZATION → EFFICIENCY', sub: 'Agent dynamics reveal intelligence efficiency laws' },
        value:   { target: 'human_qualia', name: 'MEASUREMENT → MEANING', sub: 'Value measurement leads to questions of meaning' }
    };

    if (cardinal && cardinalDepthCount[cardinal] >= 3 && channelMap[cardinal] && !channelsDiscovered.has(cardinal)) {
        const ch = channelMap[cardinal];
        if (tree[ch.target] && tree[ch.target].hidden) {
            // Don't un-hide D3 pattern nodes — they are already visible. Only show channel for truly hidden nodes.
        }
        channelsDiscovered.add(cardinal);
        showChannel(ch.name, ch.sub);
    }
}

// ════════════════════════════════════════════
// TUTORIAL
// ════════════════════════════════════════════
let tutorialComplete = false;
let tutorialPhase = 1;
const testedDirections = { north: false, east: false, south: false, west: false };
const testedFilters = { w: false, a: false, s: false, d: false };
const testedLevels = { 1: false, 2: false, 3: false };

const keyUp = document.getElementById('keyUp');
const keyDown = document.getElementById('keyDown');
const keyLeft = document.getElementById('keyLeft');
const keyRight = document.getElementById('keyRight');
const keyW = document.getElementById('keyW');
const keyA = document.getElementById('keyA');
const keyS = document.getElementById('keyS');
const keyD = document.getElementById('keyD');
const key1 = document.getElementById('key1');
const key2 = document.getElementById('key2');
const key3 = document.getElementById('key3');
const tutorialCount = document.getElementById('tutorialCount');
const tutorialCount2 = document.getElementById('tutorialCount2');
const tutorialCount3 = document.getElementById('tutorialCount3');
const enterBtn = document.getElementById('enterBtn');
const enterHint = document.getElementById('enterHint');
const tutPhase1 = document.getElementById('tutPhase1');
const tutPhase2 = document.getElementById('tutPhase2');
const tutPhase3 = document.getElementById('tutPhase3');
const phaseDot1 = document.getElementById('phaseDot1');
const phaseDot2 = document.getElementById('phaseDot2');
const phaseDot3 = document.getElementById('phaseDot3');
const phaseLabel2 = document.getElementById('phaseLabel2');
const phaseLabel3 = document.getElementById('phaseLabel3');

const heroCompass = document.getElementById('heroCompass');
const highlights = {
    north: heroCompass.querySelector('.north-highlight'),
    east:  heroCompass.querySelector('.east-highlight'),
    south: heroCompass.querySelector('.south-highlight'),
    west:  heroCompass.querySelector('.west-highlight')
};
const arrows = {
    north: heroCompass.querySelector('.arrow-north'),
    east:  heroCompass.querySelector('.arrow-east'),
    south: heroCompass.querySelector('.arrow-south'),
    west:  heroCompass.querySelector('.arrow-west')
};
const keyHints = { north: keyUp, east: keyRight, south: keyDown, west: keyLeft };

function highlightDirection(dir) {
    Object.values(highlights).forEach(h => h.classList.remove('active'));
    Object.values(arrows).forEach(a => a.classList.remove('pulse'));
    highlights[dir]?.classList.add('active');
    arrows[dir]?.classList.add('pulse');
    keyHints[dir]?.classList.add('active');
    if (!testedDirections[dir]) { testedDirections[dir] = true; updateTutorialPhase1(); }
    setTimeout(() => { highlights[dir]?.classList.remove('active'); arrows[dir]?.classList.remove('pulse'); }, 300);
}

function highlightFilter(key) {
    const filterKeyMap = { w: keyW, a: keyA, s: keyS, d: keyD };
    const filterDirMap = { w: 'north', a: 'west', s: 'south', d: 'east' };
    const dir = filterDirMap[key];
    if (highlights[dir]) { highlights[dir].classList.add('active'); setTimeout(() => highlights[dir].classList.remove('active'), 300); }
    filterKeyMap[key]?.classList.add('active');
    if (!testedFilters[key]) { testedFilters[key] = true; updateTutorialPhase2(); }
}

function updateTutorialPhase1() {
    const count = Object.values(testedDirections).filter(v => v).length;
    tutorialCount.textContent = count;
    Object.entries(testedDirections).forEach(([dir, tested]) => { if (tested) keyHints[dir].classList.add('active'); });
    if (count >= 4 && tutorialPhase === 1) {
        tutorialPhase = 2;
        setTimeout(() => {
            tutPhase1.classList.add('phase-complete');
            tutPhase2.classList.remove('phase-hidden');
            phaseDot1.classList.add('complete');
            phaseDot2.classList.remove('dim');
            phaseDot2.classList.add('active-phase');
            phaseLabel2.classList.remove('dim');
            phaseLabel2.classList.add('active-phase');
        }, 400);
    }
}

function updateTutorialPhase2() {
    const count = Object.values(testedFilters).filter(v => v).length;
    tutorialCount2.textContent = count;
    if (count >= 4 && tutorialPhase === 2) {
        tutorialPhase = 3;
        setTimeout(() => {
            tutPhase2.classList.add('phase-complete');
            tutPhase3.classList.remove('phase-hidden');
            phaseDot2.classList.remove('active-phase');
            phaseDot2.classList.add('complete');
            phaseLabel2.classList.remove('active-phase');
            phaseLabel2.classList.add('complete');
            phaseDot3.classList.remove('dim');
            phaseDot3.classList.add('active-phase');
            phaseLabel3.classList.remove('dim');
            phaseLabel3.classList.add('active-phase');
        }, 400);
    }
}

function highlightLevel(level) {
    const keyMap = { 1: key1, 2: key2, 3: key3 };
    const colorMap = { 1: 'var(--level-1)', 2: 'var(--level-2)', 3: 'var(--level-3)' };
    if (keyMap[level]) {
        keyMap[level].style.borderColor = colorMap[level];
        keyMap[level].style.color = colorMap[level];
        keyMap[level].style.boxShadow = `0 0 12px ${colorMap[level]}`;
        keyMap[level].classList.add('active');
    }
    if (!testedLevels[level]) { testedLevels[level] = true; updateTutorialPhase3(); }
}

function updateTutorialPhase3() {
    const count = Object.values(testedLevels).filter(v => v).length;
    if (tutorialCount3) tutorialCount3.textContent = count;
    if (count >= 3) {
        tutorialComplete = true;
        phaseDot3.classList.remove('active-phase');
        phaseDot3.classList.add('complete');
        if (phaseLabel3) { phaseLabel3.classList.remove('active-phase'); phaseLabel3.classList.add('complete'); }
        enterBtn.classList.add('ready');
        enterHint.textContent = 'Press ENTER or click to begin';
    }
}

function enterCompass() {
    if (!tutorialComplete) return;
    gameStarted = true;
    briefingOverlay.classList.add('hidden');
    compassWorld.classList.add('active');
    resizeAllCanvases();
    render();
}

// ════════════════════════════════════════════
// NAVIGATION
// ════════════════════════════════════════════

// Filter color mapping
const FILTER_COLORS = {
    technical: { color: '#00f0ff', dim: 'rgba(0,240,255,0.10)', glow: 'rgba(0,240,255,' },
    ethical:   { color: '#bf5af2', dim: 'rgba(191,90,242,0.10)', glow: 'rgba(191,90,242,' },
    economic:  { color: '#39FF14', dim: 'rgba(57,255,20,0.10)',  glow: 'rgba(57,255,20,' },
    social:    { color: '#ffb800', dim: 'rgba(255,184,0,0.10)',  glow: 'rgba(255,184,0,' },
};

function getCompositeColor(stack) {
    if (stack.length === 0) return null;
    if (stack.length === 1) return FILTER_COLORS[stack[0]].color;
    // Blend RGB values of active filters
    let r = 0, g = 0, b = 0;
    const hexToRgb = hex => { const n = parseInt(hex.slice(1), 16); return [(n>>16)&255, (n>>8)&255, n&255]; };
    stack.forEach(f => { const [cr,cg,cb] = hexToRgb(FILTER_COLORS[f].color); r += cr; g += cg; b += cb; });
    r = Math.round(r / stack.length); g = Math.round(g / stack.length); b = Math.round(b / stack.length);
    return `rgb(${r},${g},${b})`;
}

// Direction tracking for animations
let lastNavDirection = null;
const navSweep = document.getElementById('navSweep');

function triggerNavAnimation(direction) {
    lastNavDirection = direction;
    // Sweep overlay on compass
    navSweep.className = 'nav-sweep';
    void navSweep.offsetWidth; // force reflow
    const sweepMap = { deeper: 'sweep-up', broader: 'sweep-down', left: 'sweep-left', right: 'sweep-right' };
    navSweep.classList.add(sweepMap[direction] || 'sweep-up');
    setTimeout(() => { navSweep.className = 'nav-sweep'; }, 360);
}

function applySlideAnimation(direction) {
    nodeContent.classList.remove('slide-up','slide-down','slide-left','slide-right');
    void nodeContent.offsetWidth;
    const slideMap = { deeper: 'slide-up', broader: 'slide-down', left: 'slide-right', right: 'slide-left' };
    nodeContent.classList.add(slideMap[direction] || 'slide-up');
    setTimeout(() => nodeContent.classList.remove('slide-up','slide-down','slide-left','slide-right'), 300);
}

function navDepth(direction) {
    if (!gameStarted) return;
    const node = tree[currentNode];
    if (direction === 'deeper') {
        const visibleChildren = getVisibleChildren(currentNode);
        if (visibleChildren.length > 0) moveToDirectional(visibleChildren[0], 'deeper');
    } else if (direction === 'broader') {
        if (node.parent) moveToDirectional(node.parent, 'broader');
    }
}

function navBreadth(direction) {
    if (!gameStarted) return;
    const siblings = getVisibleSiblings(currentNode);
    if (siblings.length <= 1) return;
    const idx = siblings.indexOf(currentNode);
    let newIdx = direction === 'left'
        ? (idx - 1 + siblings.length) % siblings.length
        : (idx + 1) % siblings.length;
    moveToDirectional(siblings[newIdx], direction);
}

function getVisibleChildren(nodeId) {
    const node = tree[nodeId];
    if (!node.children) return [];
    return node.children.filter(cid => !tree[cid].hidden);
}

function getVisibleSiblings(nodeId) {
    const node = tree[nodeId];
    if (!node.parent) return [nodeId];
    return tree[node.parent].children.filter(cid => !tree[cid].hidden);
}

function moveToDirectional(targetId, direction) {
    if (!tree[targetId] || tree[targetId].hidden) return;
    triggerNavAnimation(direction);
    nodeContent.classList.add('transitioning');
    setTimeout(() => {
        pathHistory.push(targetId);
        currentNode = targetId;
        exploredNodes.add(targetId);
        checkReveals();
        checkChannels();
        render();
        nodeContent.classList.remove('transitioning');
        applySlideAnimation(direction);
    }, 160);
}

function moveTo(targetId) {
    moveToDirectional(targetId, 'deeper');
}

function goBack() {
    if (pathHistory.length <= 1) return;
    triggerNavAnimation('broader');
    nodeContent.classList.add('transitioning');
    setTimeout(() => {
        pathHistory.pop();
        currentNode = pathHistory[pathHistory.length - 1];
        checkReveals();
        render();
        nodeContent.classList.remove('transitioning');
        applySlideAnimation('broader');
    }, 160);
}

// ════════════════════════════════════════════
// COMPOSABLE FILTER STACK
// ════════════════════════════════════════════

function toggleFilter(filterName) {
    const idx = filterStack.indexOf(filterName);
    if (idx !== -1) {
        filterStack.splice(idx, 1);
    } else {
        filterStack.push(filterName);
    }
    const btn = filterBtns[filterName];
    if (btn) { btn.classList.add('pressed'); setTimeout(() => btn.classList.remove('pressed'), 200); }
    checkReveals();
    render();
}

function clearFilters() {
    filterStack = [];
    render();
}

function getFilterKey(stack, sorted = true) {
    if (stack.length === 0) return '';
    return sorted ? [...stack].sort().join('+') : stack.join('>');
}

function getCompositeContent(node, stack) {
    if (!node.filterComposites || stack.length < 2) return null;
    const sortedKey = getFilterKey(stack, true);
    const orderedKey = getFilterKey(stack, false);
    return node.filterComposites[orderedKey] || node.filterComposites[sortedKey] || null;
}

// ════════════════════════════════════════════
// HIDDEN NODE REVEALS
// ════════════════════════════════════════════

function checkReveals() {
    Object.entries(tree).forEach(([id, node]) => {
        if (!node.hidden || !node.revealCondition) return;
        const cond = node.revealCondition;

        // Check adjacency
        const isAdjacent = currentNode === cond.adjacentTo
            || tree[currentNode]?.children?.includes(cond.adjacentTo)
            || tree[currentNode]?.parent === cond.adjacentTo;

        // Check filter stack contains required filters
        const hasFilters = cond.requiredFilters.every(f => filterStack.includes(f));

        if (isAdjacent && hasFilters) {
            node.hidden = false;
            wireHiddenNode(id, node);
            showDiscovery(node.title, `Revealed by ${cond.requiredFilters.map(f => f.toUpperCase()).join(' + ')} lens at ${tree[cond.adjacentTo]?.title || cond.adjacentTo}`);
            totalDiscoveries++;
        }
    });
}

function wireHiddenNode(id, node) {
    const cond = node.revealCondition;
    if (!cond || !cond.adjacentTo) return;
    const parent = tree[cond.adjacentTo];
    if (!parent) return;

    // Wire as child of the adjacent node
    if (!parent.children.includes(id)) {
        parent.children.push(id);
    }
    node.parent = cond.adjacentTo;
    node.depth = parent.depth + 1;
    node.siblingIndex = parent.children.indexOf(id);
}

function showDiscovery(title, subtitle) {
    discoveryTitle.textContent = title;
    discoverySub.textContent = subtitle || '';
    discoveryNotif.classList.add('active');
    setTimeout(() => discoveryNotif.classList.remove('active'), 2500);
}

// ════════════════════════════════════════════
// RENDER
// ════════════════════════════════════════════

function render() {
    const node = tree[currentNode];
    locationDisplay.textContent = `◇ ${node.title}`;
    depthBadge.textContent = `D:${node.depth}`;

    const siblings = getVisibleSiblings(currentNode);
    const bIdx = siblings.indexOf(currentNode);
    coordsDisplay.textContent = `[${node.depth}, ${bIdx}]`;

    const displayPath = pathHistory.slice(-5).map(p => tree[p]?.title || p);
    pathDisplay.innerHTML = displayPath.join(' <span>→</span> ');
    backBtn.disabled = pathHistory.length <= 1;

    // Update filter stack HUD
    renderFilterStack();
    updateConsciousnessUI();
    renderNode(node);
    updateNavButtons(node);
    drawCompassView();
    drawMap();
}

function renderFilterStack() {
    const filterNames = ['technical', 'ethical', 'economic', 'social'];
    filterNames.forEach(name => {
        const idx = filterStack.indexOf(name);
        const chip = filterChips[name];
        const order = stackOrders[name];
        chip.classList.toggle('active', idx !== -1);
        if (idx !== -1) {
            order.textContent = idx + 1;
        }
    });

    // Show arrows between consecutive stack items — colored by last active filter
    stackArrows.forEach((arrow, i) => {
        arrow.classList.toggle('visible', filterStack.length > 1 && i < 3);
        if (filterStack.length > 1) {
            const comboColor = getCompositeColor(filterStack);
            arrow.style.color = comboColor;
        }
    });

    filterClearBtn.classList.toggle('visible', filterStack.length > 0);

    // Update WASD buttons
    Object.entries(filterBtns).forEach(([name, btn]) => {
        btn.classList.toggle('stack-active', filterStack.includes(name));
    });

    // Update filter legend
    const legendItems = {
        technical: document.getElementById('legTech'),
        ethical: document.getElementById('legEthic'),
        economic: document.getElementById('legEcon'),
        social: document.getElementById('legSocial'),
    };
    filterNames.forEach(name => {
        legendItems[name]?.classList.toggle('active', filterStack.includes(name));
    });

    // Combo legend swatch
    const legCombo = document.getElementById('legCombo');
    const legComboSwatch = document.getElementById('legComboSwatch');
    const legComboLabel = document.getElementById('legComboLabel');
    if (filterStack.length >= 2) {
        legCombo.classList.add('active');
        const comboColor = getCompositeColor(filterStack);
        legComboSwatch.style.background = `linear-gradient(90deg, ${filterStack.map(f => FILTER_COLORS[f].color).join(', ')})`;
        legComboLabel.textContent = filterStack.map(f => f.slice(0,4).toUpperCase()).join('×');
        legComboLabel.style.color = comboColor;
    } else {
        legCombo.classList.remove('active');
    }
}

function renderNode(node) {
    nodeContent.style.setProperty('--node-color', node.color || 'var(--qi-cyan)');
    nodeContent.style.setProperty('--node-glow', node.glow || 'var(--qi-cyan-glow)');

    let dataHTML = node.data ? `<div class="node-data">${node.data.map(d =>
        `<div class="data-block"><div class="data-label">${d.label}</div><div class="data-value">${d.value}</div></div>`
    ).join('')}</div>` : '';

    let tagsHTML = node.tags ? `<div class="node-tags">${node.tags.map(t =>
        `<span class="node-tag">${t}</span>`
    ).join('')}</div>` : '';

    // Individual filter layers
    let filterHTML = '';
    if (filterStack.length > 0 && node.filters) {
        const filterLabels = { technical: 'TECHNICAL LENS', ethical: 'ETHICAL LENS', economic: 'ECONOMIC LENS', social: 'SOCIAL LENS' };
        filterStack.forEach((fname, i) => {
            if (node.filters[fname]) {
                const fc = FILTER_COLORS[fname];
                filterHTML += `
                    <div class="filter-content" style="animation-delay: ${i * 0.1}s; border-top-color: ${fc.color}22;">
                        <div class="filter-section-title" style="color: ${fc.color}">${i + 1}. ${filterLabels[fname]}</div>
                        <div class="filter-text" style="color: ${fc.color}; opacity: 0.85;">${node.filters[fname]}</div>
                    </div>`;
            }
        });
    }

    // Composite insight
    let compositeHTML = '';
    const compositeText = getCompositeContent(node, filterStack);
    if (compositeText) {
        const comboLabel = filterStack.map(f => f.toUpperCase().slice(0, 4)).join(' × ');
        const comboColor = getCompositeColor(filterStack);
        const gradColors = filterStack.map(f => FILTER_COLORS[f].color).join(', ');
        compositeHTML = `
            <div class="composite-content" style="border-color: ${comboColor}; background: ${comboColor}08;">
                <div class="composite-label" style="color: ${comboColor}">
                    <span class="combo-icon">◈</span> COMPOSITE INSIGHT: ${comboLabel}
                </div>
                <div class="composite-text" style="color: ${comboColor}; filter: brightness(1.3);">${compositeText}</div>
                <div style="position:absolute;top:0;left:0;right:0;height:2px;background:linear-gradient(90deg, transparent, ${gradColors}, transparent);"></div>
            </div>`;
    }

    // Consciousness level content
    let consciousnessHTML = '';
    if (consciousnessLevel > 0 && node.consciousness && node.consciousness[consciousnessLevel]) {
        const lc = LEVEL_COLORS[consciousnessLevel];
        consciousnessHTML = `
            <div class="consciousness-content l${consciousnessLevel}">
                <div class="consciousness-title l${consciousnessLevel}">${lc.label} PERSPECTIVE [${consciousnessLevel}.0]</div>
                <div class="consciousness-text l${consciousnessLevel}">${node.consciousness[consciousnessLevel]}</div>
            </div>`;
    }

    // Navigation hints
    const visibleChildren = getVisibleChildren(currentNode);
    const visibleSiblings = getVisibleSiblings(currentNode);
    const idx = visibleSiblings.indexOf(currentNode);
    const hasDeeper  = visibleChildren.length > 0;
    const hasBroader = !!node.parent;
    const hasLeft    = visibleSiblings.length > 1;
    const hasRight   = visibleSiblings.length > 1;
    const leftLabel  = hasLeft ? tree[visibleSiblings[(idx - 1 + visibleSiblings.length) % visibleSiblings.length]]?.title : '—';
    const rightLabel = hasRight ? tree[visibleSiblings[(idx + 1) % visibleSiblings.length]]?.title : '—';
    const deeperLabel = hasDeeper ? tree[visibleChildren[0]]?.title : '—';
    const broaderLabel = hasBroader ? tree[node.parent]?.title : '—';

    // Check if any hidden nodes could be revealed from here
    let hiddenHintHTML = '';
    const hiddenCount = countHiddenNearby();
    if (hiddenCount > 0) {
        hiddenHintHTML = `<div class="nav-hint-item revealed" style="grid-column: 1 / -1; margin-top: 4px;">
            <span class="nav-hint-key" style="width:auto; padding: 0 6px;">◇</span> ${hiddenCount} hidden path${hiddenCount > 1 ? 's' : ''} nearby — try different filter combinations
        </div>`;
    }

    let navHTML = `
        <div class="nav-hints">
            <div class="nav-hint-item ${hasDeeper ? 'available' : ''}">
                <span class="nav-hint-key">↑</span> ${hasDeeper ? deeperLabel : 'No deeper path'}
            </div>
            <div class="nav-hint-item ${hasRight ? 'available' : ''}">
                <span class="nav-hint-key">→</span> ${hasRight ? rightLabel : 'No adjacent'}
            </div>
            <div class="nav-hint-item ${hasBroader ? 'available' : ''}">
                <span class="nav-hint-key">↓</span> ${hasBroader ? broaderLabel : 'At root'}
            </div>
            <div class="nav-hint-item ${hasLeft ? 'available' : ''}">
                <span class="nav-hint-key">←</span> ${hasLeft ? leftLabel : 'No adjacent'}
            </div>
            ${hiddenHintHTML}
        </div>`;

    nodeContent.innerHTML = `
        <div class="node-title">${node.title}</div>
        <div class="node-subtitle">${node.subtitle}</div>
        <div class="node-description">${node.description}</div>
        ${dataHTML}
        ${tagsHTML}
        ${consciousnessHTML}
        ${filterHTML}
        ${compositeHTML}
        ${navHTML}`;
}

function countHiddenNearby() {
    let count = 0;
    Object.entries(tree).forEach(([id, node]) => {
        if (!node.hidden || !node.revealCondition) return;
        const cond = node.revealCondition;
        const isAdjacent = currentNode === cond.adjacentTo
            || tree[currentNode]?.children?.includes(cond.adjacentTo)
            || tree[currentNode]?.parent === cond.adjacentTo;
        if (isAdjacent) count++;
    });
    return count;
}

function updateNavButtons(node) {
    const visibleChildren = getVisibleChildren(currentNode);
    const visibleSiblings = getVisibleSiblings(currentNode);
    btnUp.disabled    = visibleChildren.length === 0;
    btnDown.disabled  = !node.parent;
    btnLeft.disabled  = visibleSiblings.length <= 1;
    btnRight.disabled = visibleSiblings.length <= 1;
}

// ════════════════════════════════════════════
// VIEW TOGGLE
// ════════════════════════════════════════════

function setView(view) {
    currentView = view;
    viewCompassBtn.classList.toggle('active', view === 'compass');
    viewTreeBtn.classList.toggle('active', view === 'tree');
    compassViewWrap.classList.toggle('hidden', view !== 'compass');
    treeViewWrap.classList.toggle('hidden', view !== 'tree');
    resizeAllCanvases();
    if (view === 'compass') drawCompassView();
    else drawMap();
}

function resizeAllCanvases() {
    // Compass canvas
    const cWrap = compassCanvas.parentElement;
    if (cWrap) {
        const cr = cWrap.getBoundingClientRect();
        compassCanvas.width  = cr.width * window.devicePixelRatio;
        compassCanvas.height = cr.height * window.devicePixelRatio;
        compassCanvas.style.width  = cr.width + 'px';
        compassCanvas.style.height = cr.height + 'px';
    }
    // Tree canvas
    const container = mapCanvas.parentElement;
    if (container) {
        const rect = container.getBoundingClientRect();
        mapCanvas.width  = rect.width * window.devicePixelRatio;
        mapCanvas.height = rect.height * window.devicePixelRatio;
        mapCanvas.style.width  = rect.width + 'px';
        mapCanvas.style.height = rect.height + 'px';
    }
}

// ════════════════════════════════════════════
// COMPASS VIEW (zoomed in — N/S/E/W)
// ════════════════════════════════════════════

function drawCompassView() {
    const ctx = compassCanvas.getContext('2d');
    const dpr = window.devicePixelRatio;
    const w = compassCanvas.width;
    const h = compassCanvas.height;
    if (w === 0 || h === 0) return;
    ctx.clearRect(0, 0, w, h);

    const node = tree[currentNode];
    const cx = w / 2;
    const cy = h / 2;
    const radius = Math.min(w, h) * 0.38;
    const nodeHex = node.hex || '#00f0ff';

    // ── Background grid ──
    ctx.strokeStyle = 'rgba(0, 240, 255, 0.025)';
    ctx.lineWidth = 1;
    const gs = 50 * dpr;
    for (let x = 0; x < w; x += gs) { ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, h); ctx.stroke(); }
    for (let y = 0; y < h; y += gs) { ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(w, y); ctx.stroke(); }

    // ── Compass rings ──
    [0.92, 0.68, 0.38].forEach((s, i) => {
        ctx.beginPath();
        ctx.arc(cx, cy, radius * s, 0, Math.PI * 2);
        ctx.strokeStyle = `rgba(0, 240, 255, ${0.04 + i * 0.02})`;
        ctx.lineWidth = 1;
        ctx.stroke();
    });

    // ── Filter-colored aura ring ──
    if (filterStack.length > 0) {
        const comboColor = getCompositeColor(filterStack);
        // Outer aura
        ctx.beginPath();
        ctx.arc(cx, cy, radius * 0.98, 0, Math.PI * 2);
        ctx.strokeStyle = comboColor;
        ctx.globalAlpha = 0.2 + filterStack.length * 0.06;
        ctx.lineWidth = (2 + filterStack.length) * dpr;
        ctx.stroke();
        ctx.globalAlpha = 1;
        // Pulsing glow
        ctx.beginPath();
        ctx.arc(cx, cy, radius * 0.98, 0, Math.PI * 2);
        const auraGlow = ctx.createRadialGradient(cx, cy, radius * 0.9, cx, cy, radius * 1.1);
        auraGlow.addColorStop(0, 'transparent');
        auraGlow.addColorStop(0.5, comboColor.replace(')', ',0.06)').replace('rgb', 'rgba'));
        auraGlow.addColorStop(1, 'transparent');
        ctx.fillStyle = auraGlow;
        ctx.fill();
        // Segment arcs per-filter (each gets a colored arc section)
        const arcPer = (Math.PI * 2) / filterStack.length;
        filterStack.forEach((fname, i) => {
            ctx.beginPath();
            ctx.arc(cx, cy, radius * 1.02, -Math.PI/2 + i * arcPer, -Math.PI/2 + (i+1) * arcPer);
            ctx.strokeStyle = FILTER_COLORS[fname].color;
            ctx.globalAlpha = 0.5;
            ctx.lineWidth = 3 * dpr;
            ctx.stroke();
            ctx.globalAlpha = 1;
        });
    }

    // ── Cross-hair lines ──
    ctx.strokeStyle = 'rgba(0, 240, 255, 0.06)';
    ctx.lineWidth = 1;
    ctx.setLineDash([6 * dpr, 8 * dpr]);
    ctx.beginPath(); ctx.moveTo(cx, cy - radius * 1.1); ctx.lineTo(cx, cy + radius * 1.1); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(cx - radius * 1.1, cy); ctx.lineTo(cx + radius * 1.1, cy); ctx.stroke();
    ctx.setLineDash([]);

    // ── Direction labels (faint) ──
    ctx.font = `${9 * dpr}px "Orbitron", monospace`;
    ctx.textAlign = 'center';
    ctx.fillStyle = 'rgba(0, 240, 255, 0.2)';
    ctx.fillText('▲ DEEPER', cx, cy - radius * 1.0 - 16 * dpr);
    ctx.fillText('▼ BROADER', cx, cy + radius * 1.0 + 26 * dpr);
    ctx.textAlign = 'right';
    ctx.fillText('◀ LEFT', cx - radius * 1.0 - 12 * dpr, cy + 3 * dpr);
    ctx.textAlign = 'left';
    ctx.fillText('RIGHT ▶', cx + radius * 1.0 + 12 * dpr, cy + 3 * dpr);

    // ── Get neighbors ──
    const visibleChildren = getVisibleChildren(currentNode);
    const visibleSiblings = getVisibleSiblings(currentNode);
    const sibIdx = visibleSiblings.indexOf(currentNode);

    const northNode = visibleChildren.length > 0 ? tree[visibleChildren[0]] : null;
    const southNode = node.parent ? tree[node.parent] : null;
    const leftNode  = visibleSiblings.length > 1 ? tree[visibleSiblings[(sibIdx - 1 + visibleSiblings.length) % visibleSiblings.length]] : null;
    const rightNode = visibleSiblings.length > 1 ? tree[visibleSiblings[(sibIdx + 1) % visibleSiblings.length]] : null;

    // Additional children beyond the first (shown as sub-options near north)
    const extraChildren = visibleChildren.length > 1 ? visibleChildren.slice(1).map(id => tree[id]) : [];

    const colorMap = {
        '#00f0ff': { glow: 'rgba(0,240,255,', fill: '#0a2a3a' },
        '#ffb800': { glow: 'rgba(255,184,0,', fill: '#2d2a0d' },
        '#39FF14': { glow: 'rgba(57,255,20,', fill: '#0d3b1d' },
        '#bf5af2': { glow: 'rgba(191,90,242,', fill: '#2a0d3b' },
    };

    function drawNeighborNode(x, y, targetNode, dirLabel, isExplored) {
        if (!targetNode) {
            // Empty slot — show dim placeholder
            ctx.beginPath();
            ctx.arc(x, y, 18 * dpr, 0, Math.PI * 2);
            ctx.strokeStyle = 'rgba(0,240,255,0.06)';
            ctx.lineWidth = 1;
            ctx.setLineDash([3 * dpr, 3 * dpr]);
            ctx.stroke();
            ctx.setLineDash([]);
            ctx.font = `${9 * dpr}px "Share Tech Mono", monospace`;
            ctx.textAlign = 'center';
            ctx.fillStyle = 'rgba(0,240,255,0.1)';
            ctx.fillText('—', x, y + 3 * dpr);
            return;
        }

        const nh = targetNode.hex || '#00f0ff';
        const cm = colorMap[nh] || colorMap['#00f0ff'];
        const explored = exploredNodes.has(targetNode.id);
        const isRevealed = !!targetNode.revealCondition;
        const nr = 24 * dpr;

        // Connection line from center
        ctx.beginPath();
        ctx.moveTo(cx, cy);
        ctx.lineTo(x, y);
        ctx.strokeStyle = explored ? cm.glow + '0.3)' : 'rgba(0,240,255,0.08)';
        ctx.lineWidth = (explored ? 2 : 1) * dpr;
        ctx.stroke();

        // Glow
        ctx.beginPath();
        ctx.arc(x, y, nr * 2.5, 0, Math.PI * 2);
        const glow = ctx.createRadialGradient(x, y, nr, x, y, nr * 2.5);
        const gc = explored ? cm.glow : (isRevealed ? 'rgba(255,184,0,' : 'rgba(0,240,255,');
        glow.addColorStop(0, gc + '0.12)');
        glow.addColorStop(1, gc + '0)');
        ctx.fillStyle = glow;
        ctx.fill();

        // Node circle
        ctx.beginPath();
        ctx.arc(x, y, nr, 0, Math.PI * 2);
        ctx.fillStyle = explored ? cm.fill : (isRevealed ? '#2d2a0d' : '#1a2533');
        ctx.fill();
        ctx.strokeStyle = explored ? nh : (isRevealed ? '#ffb800' : '#3d4d60');
        ctx.lineWidth = 1.5 * dpr;
        ctx.stroke();

        // Label
        ctx.font = `bold ${12 * dpr}px "Share Tech Mono", monospace`;
        ctx.textAlign = 'center';
        ctx.fillStyle = explored ? nh : (isRevealed ? '#ffb800' : '#5a6a7e');
        const label = targetNode.title.length > 14 ? targetNode.title.substring(0, 12) + '..' : targetNode.title;
        ctx.fillText(label, x, y + nr + 16 * dpr);

        // Subtitle
        if (targetNode.subtitle) {
            ctx.font = `${8.5 * dpr}px "Share Tech Mono", monospace`;
            ctx.fillStyle = explored ? (gc + '0.5)') : 'rgba(0,240,255,0.2)';
            const sub = targetNode.subtitle.length > 20 ? targetNode.subtitle.substring(0, 18) + '..' : targetNode.subtitle;
            ctx.fillText(sub, x, y + nr + 28 * dpr);
        }

        // Explored indicator
        if (explored) {
            ctx.beginPath();
            ctx.arc(x, y, nr * 0.3, 0, Math.PI * 2);
            ctx.fillStyle = nh;
            ctx.globalAlpha = 0.5;
            ctx.fill();
            ctx.globalAlpha = 1;
        }
    }

    // ── Draw neighbor nodes at cardinal positions ──
    const dist = radius * 0.75;
    drawNeighborNode(cx, cy - dist, northNode, 'DEEPER');
    drawNeighborNode(cx, cy + dist, southNode, 'BROADER');
    drawNeighborNode(cx - dist, cy, leftNode, 'LEFT');
    drawNeighborNode(cx + dist, cy, rightNode, 'RIGHT');

    // ── Draw extra children fanning near north ──
    if (extraChildren.length > 0) {
        const fanSpread = Math.min(radius * 0.5, extraChildren.length * 35 * dpr);
        extraChildren.forEach((child, i) => {
            const angle = -Math.PI / 2 + ((i + 1) / (extraChildren.length + 1) - 0.5) * 0.8;
            const fx = cx + Math.cos(angle) * dist * 0.95 + (i + 1) * (fanSpread / (extraChildren.length + 1)) - fanSpread / 2;
            const fy = cy - dist * 0.65 - 15 * dpr;
            // Mini nodes
            const miniR = 13 * dpr;
            const explored = exploredNodes.has(child.id);
            const ch = child.hex || '#00f0ff';
            const ccm = colorMap[ch] || colorMap['#00f0ff'];

            // Mini connection
            ctx.beginPath();
            ctx.moveTo(cx, cy - dist);
            ctx.lineTo(fx, fy);
            ctx.strokeStyle = 'rgba(0,240,255,0.06)';
            ctx.lineWidth = 1;
            ctx.stroke();

            ctx.beginPath();
            ctx.arc(fx, fy, miniR, 0, Math.PI * 2);
            ctx.fillStyle = explored ? ccm.fill : '#1a2533';
            ctx.fill();
            ctx.strokeStyle = explored ? ch : '#3d4d60';
            ctx.lineWidth = 1;
            ctx.stroke();

            ctx.font = `${9 * dpr}px "Share Tech Mono", monospace`;
            ctx.textAlign = 'center';
            ctx.fillStyle = explored ? ch : '#3d4d60';
            const ml = child.title.length > 10 ? child.title.substring(0, 8) + '..' : child.title;
            ctx.fillText(ml, fx, fy + miniR + 12 * dpr);
        });
    }

    // ── Center node (current) ──
    const centerR = 36 * dpr;
    const cm = colorMap[nodeHex] || colorMap['#00f0ff'];

    // Big glow — tinted by filter combo if active
    const glowBase = filterStack.length > 0 ? getCompositeColor(filterStack) : null;
    ctx.beginPath();
    ctx.arc(cx, cy, centerR * 3.5, 0, Math.PI * 2);
    const cGlow = ctx.createRadialGradient(cx, cy, centerR, cx, cy, centerR * 3.5);
    cGlow.addColorStop(0, cm.glow + '0.2)');
    cGlow.addColorStop(0.5, cm.glow + '0.06)');
    cGlow.addColorStop(1, cm.glow + '0)');
    ctx.fillStyle = cGlow;
    ctx.fill();

    // Filter indicator orbit dots around center
    if (filterStack.length > 0) {
        const orbitR = centerR * 1.6;
        filterStack.forEach((fname, i) => {
            const angle = -Math.PI/2 + (i / filterStack.length) * Math.PI * 2;
            const dx = cx + Math.cos(angle) * orbitR;
            const dy = cy + Math.sin(angle) * orbitR;
            ctx.beginPath();
            ctx.arc(dx, dy, 5 * dpr, 0, Math.PI * 2);
            ctx.fillStyle = FILTER_COLORS[fname].color;
            ctx.globalAlpha = 0.7;
            ctx.fill();
            ctx.globalAlpha = 1;
            // Small glow
            ctx.beginPath();
            ctx.arc(dx, dy, 10 * dpr, 0, Math.PI * 2);
            const dGlow = ctx.createRadialGradient(dx, dy, 3*dpr, dx, dy, 10*dpr);
            dGlow.addColorStop(0, FILTER_COLORS[fname].glow + '0.3)');
            dGlow.addColorStop(1, FILTER_COLORS[fname].glow + '0)');
            ctx.fillStyle = dGlow;
            ctx.fill();
        });
    }

    // Node body
    ctx.beginPath();
    ctx.arc(cx, cy, centerR, 0, Math.PI * 2);
    ctx.fillStyle = cm.fill;
    ctx.fill();
    ctx.strokeStyle = filterStack.length > 0 ? getCompositeColor(filterStack) : nodeHex;
    ctx.lineWidth = 2.5 * dpr;
    ctx.stroke();

    // Inner dot
    ctx.beginPath();
    ctx.arc(cx, cy, centerR * 0.3, 0, Math.PI * 2);
    ctx.fillStyle = nodeHex;
    ctx.globalAlpha = 0.6;
    ctx.fill();
    ctx.globalAlpha = 1;

    // Center label
    ctx.font = `bold ${14 * dpr}px "Orbitron", monospace`;
    ctx.textAlign = 'center';
    ctx.fillStyle = nodeHex;
    ctx.fillText(node.title, cx, cy + centerR + 22 * dpr);

    // Subtitle
    if (node.subtitle) {
        ctx.font = `${9 * dpr}px "Share Tech Mono", monospace`;
        ctx.fillStyle = cm.glow + '0.6)';
        ctx.fillText(node.subtitle.toUpperCase(), cx, cy + centerR + 36 * dpr);
    }

    // Depth indicator
    ctx.font = `${9 * dpr}px "Orbitron", monospace`;
    ctx.fillStyle = 'rgba(0,240,255,0.2)';
    ctx.fillText(`DEPTH ${node.depth}`, cx, cy + centerR + 50 * dpr);

    // Consciousness level indicator
    if (consciousnessLevel > 0) {
        const lcHex = LEVEL_COLORS[consciousnessLevel].hex;
        const lcLabel = LEVEL_COLORS[consciousnessLevel].label;
        ctx.font = `bold ${10 * dpr}px "Orbitron", monospace`;
        ctx.fillStyle = lcHex;
        ctx.globalAlpha = 0.7;
        ctx.fillText(`⟐ ${lcLabel} [${consciousnessLevel}.0]`, cx, cy + centerR + 64 * dpr);
        ctx.globalAlpha = 1;

        // Consciousness-colored inner ring
        ctx.beginPath();
        ctx.arc(cx, cy, centerR * 1.15, 0, Math.PI * 2);
        ctx.strokeStyle = lcHex;
        ctx.globalAlpha = 0.25;
        ctx.lineWidth = 1.5 * dpr;
        ctx.setLineDash([4 * dpr, 4 * dpr]);
        ctx.stroke();
        ctx.setLineDash([]);
        ctx.globalAlpha = 1;
    }

    // ── Hidden path hints ──
    const hiddenCount = countHiddenNearby();
    if (hiddenCount > 0) {
        ctx.font = `${10 * dpr}px "Share Tech Mono", monospace`;
        ctx.fillStyle = 'rgba(255,184,0,0.45)';
        ctx.fillText(`◇ ${hiddenCount} hidden path${hiddenCount > 1 ? 's' : ''} nearby — try filter combos`, cx, h - 24 * dpr);
    }

    // ── Explored count ──
    const visibleNodes = Object.values(tree).filter(n => !n.hidden);
    const hiddenTotal = Object.values(tree).filter(n => n.hidden).length;
    ctx.font = `${9 * dpr}px "Share Tech Mono", monospace`;
    ctx.textAlign = 'left';
    ctx.fillStyle = 'rgba(0,240,255,0.2)';
    ctx.fillText(`EXPLORED: ${exploredNodes.size} / ${visibleNodes.length}${hiddenTotal > 0 ? ' + ???' : ''}`, 14 * dpr, h - 14 * dpr);

    // ── Active filters indicator (top-right) ──
    if (filterStack.length > 0) {
        ctx.textAlign = 'right';
        ctx.font = `bold ${9 * dpr}px "Orbitron", monospace`;
        filterStack.forEach((fname, i) => {
            ctx.fillStyle = FILTER_COLORS[fname].color;
            ctx.globalAlpha = 0.6;
            ctx.fillText(fname.toUpperCase().slice(0,4), w - 14 * dpr, (18 + i * 16) * dpr);
        });
        ctx.globalAlpha = 1;
    }
}

// ════════════════════════════════════════════
// TREE VIEW (overview map)
// ════════════════════════════════════════════

function resizeMap() {
    const container = mapCanvas.parentElement;
    const rect = container.getBoundingClientRect();
    mapCanvas.width  = rect.width * window.devicePixelRatio;
    mapCanvas.height = rect.height * window.devicePixelRatio;
    mapCanvas.style.width  = rect.width + 'px';
    mapCanvas.style.height = rect.height + 'px';
}

function drawMap() {
    const ctx = mapCanvas.getContext('2d');
    const dpr = window.devicePixelRatio;
    const w = mapCanvas.width;
    const h = mapCanvas.height;
    ctx.clearRect(0, 0, w, h);

    // ── Background grid for the big map ──
    ctx.strokeStyle = 'rgba(0, 240, 255, 0.03)';
    ctx.lineWidth = 1;
    const gridSize = 40 * dpr;
    for (let x = 0; x < w; x += gridSize) {
        ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, h); ctx.stroke();
    }
    for (let y = 0; y < h; y += gridSize) {
        ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(w, y); ctx.stroke();
    }

    // Only draw visible nodes
    const visibleTree = {};
    Object.entries(tree).forEach(([id, node]) => {
        if (!node.hidden) visibleTree[id] = node;
    });

    const positions = {};
    const padding = 50 * dpr;
    const nodeRadius = 16 * dpr;

    // Count max depth
    let maxDepth = 0;
    Object.values(visibleTree).forEach(n => { if (n.depth > maxDepth) maxDepth = n.depth; });
    const levelGap = maxDepth > 0 ? (h - padding * 2) / Math.max(maxDepth, 1) : h / 2;

    // ── Layout positions ──
    // Origin at center-top
    positions.origin = { x: w / 2, y: padding + nodeRadius * 2 };

    // Depth 1 — spread evenly
    const d1 = tree.origin.children.filter(id => !tree[id].hidden);
    const d1Spacing = (w - padding * 2) / (d1.length + 1);
    d1.forEach((id, i) => {
        positions[id] = { x: padding + d1Spacing * (i + 1), y: padding + levelGap + nodeRadius };
    });

    // Depth 2+
    d1.forEach(parentId => {
        const children = (tree[parentId].children || []).filter(id => !tree[id].hidden);
        if (children.length === 0) return;
        const parentX = positions[parentId]?.x || w / 2;
        const spread = d1Spacing * 0.95;
        const childSpacing = spread / (children.length + 1);
        const startX = parentX - spread / 2;
        children.forEach((cid, ci) => {
            positions[cid] = {
                x: startX + childSpacing * (ci + 1),
                y: padding + levelGap * 2 + nodeRadius
            };
            // Depth 3
            const grandchildren = (tree[cid].children || []).filter(id => !tree[id].hidden);
            grandchildren.forEach((gcid, gci) => {
                const gcSpread = childSpacing * 0.85;
                positions[gcid] = {
                    x: positions[cid].x - gcSpread / 2 + gcSpread * (gci + 1) / (grandchildren.length + 1),
                    y: padding + levelGap * 3 + nodeRadius
                };
            });
        });
    });

    // ── Fog of war ──
    ctx.fillStyle = 'rgba(6, 8, 13, 0.5)';
    ctx.fillRect(0, 0, w, h);
    exploredNodes.forEach(id => {
        if (!positions[id]) return;
        const pos = positions[id];
        ctx.globalCompositeOperation = 'destination-out';
        ctx.beginPath();
        ctx.arc(pos.x, pos.y, 90 * dpr, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(0,0,0,0.8)';
        ctx.fill();
    });
    ctx.globalCompositeOperation = 'source-over';

    // ── Connection lines ──
    Object.entries(visibleTree).forEach(([id, node]) => {
        if (!positions[id]) return;
        const pos = positions[id];
        (node.children || []).filter(cid => !tree[cid].hidden).forEach(childId => {
            if (!positions[childId]) return;
            const cpos = positions[childId];
            const isOnPath = pathHistory.includes(id) && pathHistory.includes(childId);

            // Draw glow for on-path connections
            if (isOnPath) {
                ctx.beginPath();
                ctx.moveTo(pos.x, pos.y);
                const midY = (pos.y + cpos.y) / 2;
                ctx.bezierCurveTo(pos.x, midY, cpos.x, midY, cpos.x, cpos.y);
                ctx.strokeStyle = 'rgba(0,240,255,0.15)';
                ctx.lineWidth = 6 * dpr;
                ctx.stroke();
            }

            ctx.beginPath();
            ctx.moveTo(pos.x, pos.y);
            const midY = (pos.y + cpos.y) / 2;
            ctx.bezierCurveTo(pos.x, midY, cpos.x, midY, cpos.x, cpos.y);
            ctx.strokeStyle = isOnPath ? 'rgba(0,240,255,0.6)' : 'rgba(0,240,255,0.1)';
            ctx.lineWidth = (isOnPath ? 2.5 : 1) * dpr;
            ctx.stroke();

            // Arrow indicator on path edges
            if (isOnPath) {
                const t = 0.65;
                const mt = 1 - t;
                const ax = mt*mt*mt*pos.x + 3*mt*mt*t*pos.x + 3*mt*t*t*cpos.x + t*t*t*cpos.x;
                const ay = mt*mt*mt*pos.y + 3*mt*mt*t*midY + 3*mt*t*t*midY + t*t*t*cpos.y;
                ctx.beginPath();
                ctx.arc(ax, ay, 3 * dpr, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(0,240,255,0.5)';
                ctx.fill();
            }
        });
    });

    // ── Color map for node categories ──
    const colorMap = {
        '#00f0ff': { fill: '#0a2a3a', stroke: '#00f0ff', glow: 'rgba(0,240,255,' },
        '#ffb800': { fill: '#2d2a0d', stroke: '#ffb800', glow: 'rgba(255,184,0,' },
        '#39FF14': { fill: '#0d3b1d', stroke: '#39FF14', glow: 'rgba(57,255,20,' },
        '#bf5af2': { fill: '#2a0d3b', stroke: '#bf5af2', glow: 'rgba(191,90,242,' },
    };

    // ── Nodes ──
    Object.entries(positions).forEach(([id, pos]) => {
        const node = visibleTree[id];
        if (!node) return;
        const isCurrent = id === currentNode;
        const isExplored = exploredNodes.has(id);
        const isRevealed = !!node.revealCondition;

        // Determine color from node's hex property
        const nodeHex = node.hex || '#00f0ff';
        const cm = colorMap[nodeHex] || colorMap['#00f0ff'];

        let fillColor = '#1a2533';
        let strokeColor = '#3d4d60';
        let glowBase = 'rgba(0,240,255,';

        if (isExplored) { fillColor = cm.fill; strokeColor = cm.stroke; glowBase = cm.glow; }
        if (isRevealed && !isExplored) { fillColor = '#2d2a0d'; strokeColor = '#ffb800'; glowBase = 'rgba(255,184,0,'; }
        if (isCurrent) { fillColor = cm.fill; strokeColor = cm.stroke; glowBase = cm.glow; }

        const r = isCurrent ? nodeRadius * 1.6 : (isExplored ? nodeRadius * 1.1 : nodeRadius * 0.8);

        // Outer glow for current
        if (isCurrent) {
            ctx.beginPath();
            ctx.arc(pos.x, pos.y, r * 4, 0, Math.PI * 2);
            const glow = ctx.createRadialGradient(pos.x, pos.y, r, pos.x, pos.y, r * 4);
            glow.addColorStop(0, glowBase + '0.25)');
            glow.addColorStop(0.5, glowBase + '0.08)');
            glow.addColorStop(1, glowBase + '0)');
            ctx.fillStyle = glow;
            ctx.fill();
        }

        // Subtle glow for explored
        if (isExplored && !isCurrent) {
            ctx.beginPath();
            ctx.arc(pos.x, pos.y, r * 2.5, 0, Math.PI * 2);
            const glow = ctx.createRadialGradient(pos.x, pos.y, r, pos.x, pos.y, r * 2.5);
            glow.addColorStop(0, glowBase + '0.1)');
            glow.addColorStop(1, glowBase + '0)');
            ctx.fillStyle = glow;
            ctx.fill();
        }

        // Node body
        ctx.beginPath();
        ctx.arc(pos.x, pos.y, r, 0, Math.PI * 2);
        ctx.fillStyle = fillColor;
        ctx.fill();
        ctx.strokeStyle = strokeColor;
        ctx.lineWidth = (isCurrent ? 2.5 : 1.5) * dpr;
        ctx.stroke();

        // Inner dot
        if (isCurrent) {
            ctx.beginPath();
            ctx.arc(pos.x, pos.y, r * 0.35, 0, Math.PI * 2);
            ctx.fillStyle = strokeColor;
            ctx.fill();
        }

        // ── Labels ──
        const fontSize = isCurrent ? 13 : (isExplored ? 11 : 10);
        ctx.font = `bold ${fontSize * dpr}px "Share Tech Mono", monospace`;
        ctx.textAlign = 'center';
        ctx.fillStyle = isCurrent ? strokeColor : (isExplored ? strokeColor : (isRevealed ? '#ffb800' : '#3d4d60'));
        const label = node.title.length > 16 ? node.title.substring(0, 14) + '..' : node.title;
        ctx.fillText(label, pos.x, pos.y + r + 18 * dpr);

        // Depth / subtitle for current node
        if (isCurrent) {
            ctx.font = `${9 * dpr}px "Share Tech Mono", monospace`;
            ctx.fillStyle = 'rgba(0,240,255,0.5)';
            const sub = node.subtitle || '';
            if (sub) ctx.fillText(sub.toUpperCase(), pos.x, pos.y + r + 30 * dpr);
        }
    });

    // ── Draw depth level indicators on left side ──
    ctx.font = `${9 * dpr}px "Orbitron", monospace`;
    ctx.textAlign = 'left';
    ctx.fillStyle = 'rgba(0,240,255,0.18)';
    for (let d = 0; d <= maxDepth; d++) {
        const y = padding + levelGap * d + nodeRadius * 2;
        ctx.fillText(`D:${d}`, 10 * dpr, y);
        ctx.beginPath();
        ctx.moveTo(0, y - 4 * dpr);
        ctx.lineTo(w, y - 4 * dpr);
        ctx.strokeStyle = 'rgba(0,240,255,0.025)';
        ctx.lineWidth = 1;
        ctx.stroke();
    }
}

// ════════════════════════════════════════════
// KEYBOARD
// ════════════════════════════════════════════

document.addEventListener('keydown', (e) => {
    // Tutorial
    if (!gameStarted) {
        if (e.key === 'ArrowUp')    { e.preventDefault(); highlightDirection('north'); }
        if (e.key === 'ArrowRight') { e.preventDefault(); highlightDirection('east'); }
        if (e.key === 'ArrowDown')  { e.preventDefault(); highlightDirection('south'); }
        if (e.key === 'ArrowLeft')  { e.preventDefault(); highlightDirection('west'); }
        if (tutorialPhase >= 2) {
            if (e.key === 'w' || e.key === 'W') { e.preventDefault(); highlightFilter('w'); }
            if (e.key === 'a' || e.key === 'A') { e.preventDefault(); highlightFilter('a'); }
            if (e.key === 's' || e.key === 'S') { e.preventDefault(); highlightFilter('s'); }
            if (e.key === 'd' || e.key === 'D') { e.preventDefault(); highlightFilter('d'); }
        }
        if (tutorialPhase >= 3) {
            if (e.key === '1') { e.preventDefault(); highlightLevel(1); }
            if (e.key === '2') { e.preventDefault(); highlightLevel(2); }
            if (e.key === '3') { e.preventDefault(); highlightLevel(3); }
        }
        if ((e.key === 'Enter' || e.key === ' ') && tutorialComplete) { e.preventDefault(); enterCompass(); }
        return;
    }

    // Tab toggles views
    if (e.key === 'Tab') { e.preventDefault(); setView(currentView === 'compass' ? 'tree' : 'compass'); return; }

    // Exploration
    switch (e.key) {
        case 'ArrowUp':    e.preventDefault(); navDepth('deeper'); pressBtn(btnUp); break;
        case 'ArrowDown':  e.preventDefault(); navDepth('broader'); pressBtn(btnDown); break;
        case 'ArrowLeft':  e.preventDefault(); navBreadth('left'); pressBtn(btnLeft); break;
        case 'ArrowRight': e.preventDefault(); navBreadth('right'); pressBtn(btnRight); break;
        case 'w': case 'W': e.preventDefault(); toggleFilter('technical'); break;
        case 'a': case 'A': e.preventDefault(); toggleFilter('ethical'); break;
        case 's': case 'S': e.preventDefault(); toggleFilter('economic'); break;
        case 'd': case 'D': e.preventDefault(); toggleFilter('social'); break;
        case 'q': case 'Q': e.preventDefault(); clearFilters(); break;
        case 'Escape': e.preventDefault(); clearFilters(); consciousnessLevel = 0; updateConsciousnessUI(); render(); break;
        case 'Backspace': e.preventDefault(); goBack(); break;
        case '1': e.preventDefault(); setConsciousness(1); break;
        case '2': e.preventDefault(); setConsciousness(2); break;
        case '3': e.preventDefault(); setConsciousness(3); break;
    }
});

function pressBtn(btn) {
    btn.classList.add('pressed');
    setTimeout(() => btn.classList.remove('pressed'), 150);
}

window.addEventListener('resize', () => {
    if (gameStarted) { resizeAllCanvases(); render(); }
});

// Init
render();
</script>

</body>
</html>
